<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>赤木酱</title>
    <link>/zh/</link>
      <atom:link href="/zh/index.xml" rel="self" type="application/rss+xml" />
    <description>赤木酱</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Mon, 26 Mar 2018 13:46:50 +0800</lastBuildDate>
    <image>
      <url>/img/akhead.png</url>
      <title>赤木酱</title>
      <link>/zh/</link>
    </image>
    
    <item>
      <title>EOS 合约开发之 token</title>
      <link>/zh/post/eos-contract-token/</link>
      <pubDate>Mon, 26 Mar 2018 13:46:50 +0800</pubDate>
      <guid>/zh/post/eos-contract-token/</guid>
      <description>&lt;h2 id=&#34;开发环境&#34;&gt;开发环境&lt;/h2&gt;
&lt;p&gt;使用 
&lt;a href=&#34;http://hub.docker.com/r/eosio/builder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eos/builder&lt;/a&gt;
 作为开发环境, 使用 master 分支最新代码.&lt;/p&gt;
&lt;h2 id=&#34;启动-eos-单节点&#34;&gt;启动 EOS 单节点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在一个终端启动 &lt;code&gt;nodeosd.sh&lt;/code&gt;, 可以看到不断有区块产生, 后续操作在另一个终端中进行.&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;get info&lt;/code&gt; api, 来检查是否运行正常&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# http get http://127.0.0.1:8888/v1/chain/get_info
HTTP/1.1 200 OK
Content-Length: 235
Content-type: application/json
Server: WebSocket++/0.7.0

{
    &amp;quot;head_block_id&amp;quot;: &amp;quot;000000418661452eb2d425d0f1caed204af15d117bbf4ab1c82764235aff6d62&amp;quot;,
    &amp;quot;head_block_num&amp;quot;: 65,
    &amp;quot;head_block_producer&amp;quot;: &amp;quot;eosio&amp;quot;,
    &amp;quot;head_block_time&amp;quot;: &amp;quot;2018-03-26T06:03:48&amp;quot;,
    &amp;quot;last_irreversible_block_num&amp;quot;: 64,
    &amp;quot;server_version&amp;quot;: &amp;quot;83f6ce54&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建钱包以及账户&#34;&gt;创建钱包以及账户&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建钱包 &lt;code&gt;cleos wallet create&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos wallet create
Creating wallet: default
Save password to use in the future to unlock this wallet.
Without password imported keys will not be retrievable.
&amp;quot;PW5Jg1u5EuNpcMiTMqM78a6NVbvNd9CHnYa39Mfu3TZ35XQvQZeur&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;导入 &lt;code&gt;eosio&lt;/code&gt; 系统账户的 private key, 保存在 genesis.json.&lt;code&gt;cleos wallet import 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos wallet import 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3
imported private key for: EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;为 &lt;code&gt;token&lt;/code&gt; 合约创建账户.&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;owner_key&lt;/code&gt;: &lt;code&gt;cleos create key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos create key
Private key: 5JBrL9JTBxooBAxCU41PEXX1hFpPiPiCVH6PyFAtqEMAKNw8gwT
Public key: EOS6rgmK4g6L8nu7y2tXnfk4F8JZctZ5QKkvga3CAsfv9DFfLFmr1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建 &lt;code&gt;active_key&lt;/code&gt;: &lt;code&gt;cleos create key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos create key
Private key: 5K6bPikRThnWYM6XgvaWdezJrri1RRjoEthfZcUPvekHNKMyrX6
Public key: EOS4xAHcZfLjXbBiLYYYhohXjFyC2Ct45sc5hTRMCGyYRKbLyyNLD
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建 &lt;code&gt;token&lt;/code&gt; 账户.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos create account eosio token EOS6rgmK4g6L8nu7y2tXnfk4F8JZctZ5QKkvga3CAsfv9DFfLFmr1 EOS4xAHcZfLjXbBiLYYYhohXjFyC2Ct45sc5hTRMCGyYRKbLyyNLD
{
  &amp;quot;transaction_id&amp;quot;: &amp;quot;103744a19981c7bd08e5b33e00d6fbca73a9b5f34ed062700f625fa8c3048379&amp;quot;,
  &amp;quot;processed&amp;quot;: {
    &amp;quot;status&amp;quot;: &amp;quot;executed&amp;quot;,
    &amp;quot;id&amp;quot;: &amp;quot;103744a19981c7bd08e5b33e00d6fbca73a9b5f34ed062700f625fa8c3048379&amp;quot;,
    &amp;quot;action_traces&amp;quot;: [{
        &amp;quot;receiver&amp;quot;: &amp;quot;eosio&amp;quot;,
        &amp;quot;act&amp;quot;: {
          &amp;quot;account&amp;quot;: &amp;quot;eosio&amp;quot;,
          &amp;quot;name&amp;quot;: &amp;quot;newaccount&amp;quot;,
          &amp;quot;authorization&amp;quot;: [{
              &amp;quot;actor&amp;quot;: &amp;quot;eosio&amp;quot;,
              &amp;quot;permission&amp;quot;: &amp;quot;active&amp;quot;
            }
          ],
          &amp;quot;data&amp;quot;: &amp;quot;0000000000ea30550000000080a920cd01000000010003034c349df8bdaa38b98ca9911c3a26fd9b6d1d7af167b2eb5c3a287cf09f4b570100000100000001000208560867098550d4c51c4e62dedc1192906e7e83cbb406d3d9b7d726d9833eed0100000100000000010000000000ea305500000000a8ed32320100&amp;quot;
        },
        &amp;quot;console&amp;quot;: &amp;quot;&amp;quot;,
        &amp;quot;region_id&amp;quot;: 0,
        &amp;quot;cycle_index&amp;quot;: 0,
        &amp;quot;data_access&amp;quot;: [{
            &amp;quot;type&amp;quot;: &amp;quot;write&amp;quot;,
            &amp;quot;code&amp;quot;: &amp;quot;eosio&amp;quot;,
            &amp;quot;scope&amp;quot;: &amp;quot;eosio.auth&amp;quot;,
            &amp;quot;sequence&amp;quot;: 3
          }
        ]
      }
    ],
    &amp;quot;deferred_transactions&amp;quot;: []
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;获取账户信息 &lt;code&gt;cleos get account&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos get account token
{
  &amp;quot;account_name&amp;quot;: &amp;quot;token&amp;quot;,
  &amp;quot;permissions&amp;quot;: [{
      &amp;quot;perm_name&amp;quot;: &amp;quot;active&amp;quot;,
      &amp;quot;parent&amp;quot;: &amp;quot;owner&amp;quot;,
      &amp;quot;required_auth&amp;quot;: {
        &amp;quot;threshold&amp;quot;: 1,
        &amp;quot;keys&amp;quot;: [{
            &amp;quot;key&amp;quot;: &amp;quot;EOS4xAHcZfLjXbBiLYYYhohXjFyC2Ct45sc5hTRMCGyYRKbLyyNLD&amp;quot;,
            &amp;quot;weight&amp;quot;: 1
          }
        ],
        &amp;quot;accounts&amp;quot;: []
      }
    },{
      &amp;quot;perm_name&amp;quot;: &amp;quot;owner&amp;quot;,
      &amp;quot;parent&amp;quot;: &amp;quot;&amp;quot;,
      &amp;quot;required_auth&amp;quot;: {
        &amp;quot;threshold&amp;quot;: 1,
        &amp;quot;keys&amp;quot;: [{
            &amp;quot;key&amp;quot;: &amp;quot;EOS6rgmK4g6L8nu7y2tXnfk4F8JZctZ5QKkvga3CAsfv9DFfLFmr1&amp;quot;,
            &amp;quot;weight&amp;quot;: 1
          }
        ],
        &amp;quot;accounts&amp;quot;: []
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;导入 &lt;code&gt;token&lt;/code&gt; 账户 active private key.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cleos wallet import 5K6bPikRThnWYM6XgvaWdezJrri1RRjoEthfZcUPvekHNKMyrX6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;上传-token-合约到区块链&#34;&gt;上传 &lt;code&gt;token&lt;/code&gt; 合约到区块链&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;验证 &lt;code&gt;token&lt;/code&gt; 账户没有部署合约.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cleos get code token
code hash: 0000000000000000000000000000000000000000000000000000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;上传合约, 来到 &lt;code&gt;/tmp/build&lt;/code&gt; 目录下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:~# cd /tmp/build
root@199345c94897:~# cleos set contract token contracts/eosio.token/eosio.token.wast contracts/eosio.token/eosio.token.abi

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看合约地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;root@199345c94897:/tmp/build# cleos get code token
code hash: 8a7e86ac5dc972c1b79f2f7c90ef73ef07ed78a8aee6e546459307eee213e299
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试-token-合约&#34;&gt;测试 token 合约&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cleos push action token create &#39;{&amp;quot;issuer&amp;quot;:&amp;quot;token&amp;quot;, &amp;quot;maximum_supply&amp;quot;: &amp;quot;1000000000.0000 CUR&amp;quot;, &amp;quot;can_freeze&amp;quot;: 1, &amp;quot;can_recall&amp;quot;: 1, &amp;quot;can_whitelist&amp;quot;: 1}&#39; -p token@active
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;issue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cleos push action token issue &#39;{&amp;quot;to&amp;quot;:&amp;quot;token&amp;quot;,&amp;quot;quantity&amp;quot;:&amp;quot;1000.0000 CUR&amp;quot;,&amp;quot;memo&amp;quot;:&amp;quot;issue&amp;quot;}&#39; --permission token@active
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;transfer&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cleos push action token transfer &#39;{&amp;quot;from&amp;quot;:&amp;quot;token&amp;quot;,&amp;quot;to&amp;quot;:&amp;quot;eosio&amp;quot;,&amp;quot;quantity&amp;quot;:&amp;quot;20.0000 CUR&amp;quot;,&amp;quot;memo&amp;quot;:&amp;quot;my first transfer&amp;quot;}&#39; --permission token@active
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看转账后账户-balance&#34;&gt;查看转账后账户 balance&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注意目前 master 分支 table 有 bug, 等待官方进行 fix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看 eosio 账户:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cleos get table eosio token account
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看 token 账户:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cleos get table token token account
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HLS 协议详解</title>
      <link>/zh/post/hls-explained/</link>
      <pubDate>Wed, 22 Mar 2017 17:04:50 +0800</pubDate>
      <guid>/zh/post/hls-explained/</guid>
      <description>&lt;h2 id=&#34;hls-概述&#34;&gt;HLS 概述&lt;/h2&gt;
&lt;p&gt;HLS 全称是 HTTP Live Streaming, 是一个由 Apple 公司实现的基于 HTTP 的媒体流传输协议. 他跟 DASH 协议的原理非常类似. 通过将整条流切割成一个小的可以通过 HTTP 下载的媒体文件, 然后提供一个配套的媒体列表文件, 提供给客户端, 让客户端顺序地拉取这些媒体文件播放, 来实现看上去是在播放一条流的效果.&lt;/p&gt;
&lt;p&gt;由于传输层协议只需要标准的 HTTP 协议, HLS 可以方便的透过防火墙或者代理服务器, 而且可以很方便的利用 CDN 进行分发加速, 并且客户端实现起来也很方便.&lt;/p&gt;
&lt;p&gt;HLS 目前广泛地应用于点播和直播领域.&lt;/p&gt;
&lt;p&gt;在 HTML5 页面上使用 HLS 非常简单:&lt;/p&gt;
&lt;p&gt;直接:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;video src=&amp;quot;example.m3u8&amp;quot; controls&amp;gt;&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;video controls&amp;gt;
    &amp;lt;source src=&amp;quot;example.m3u8&amp;quot;&amp;gt;&amp;lt;/source&amp;gt;
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面, 我将会概括性地介绍 HLS 协议的方方面面(暂时不包括 AES 加密部分的内容), 配合 HLS 的 RFC 食用效果更佳.&lt;/p&gt;
&lt;h2 id=&#34;hls-协议详解&#34;&gt;HLS 协议详解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/hls_arch.png&#34; alt=&#34;hls_arch&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面是 HLS 整体架构图, 可以看出, 总共有三个部分: Server, CDN, Client.&lt;/p&gt;
&lt;p&gt;其实, HLS 协议的主要内容是关于 M3U8 这个文本协议的, 其实生成与解析都非常简单. 为了更加直接地说明这一点, 我下面举两个简单的例子:&lt;/p&gt;
&lt;p&gt;简单的 Media Playlist:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:8
#EXT-X-MEDIA-SEQUENCE:2680

#EXTINF:7.975,
https://priv.example.com/fileSequence2680.ts
#EXTINF:7.941,
https://priv.example.com/fileSequence2681.ts
#EXTINF:7.975,
https://priv.example.com/fileSequence2682.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包含多种比特率的 Master Playlist:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#EXTM3U
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1280000
http://example.com/low.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2560000
http://example.com/mid.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=7680000
http://example.com/hi.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=65000,CODECS=&amp;quot;mp4a.40.5&amp;quot;
http://example.com/audio-only.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;HLS 通过 URI(RFC3986) 指向的一个 Playlist 来表示一个媒体流.&lt;/li&gt;
&lt;li&gt;一个 Playlist 可以是一个 Media Playlist 或者 Master Playlist, 使用 UTF-8 编码的文本文件, 包含一些 URI 跟描述性的 tags.&lt;/li&gt;
&lt;li&gt;一个 Media Playlist 包含一个 Media Segments 列表,当顺序播放时, 能播放整个完整的流.&lt;/li&gt;
&lt;li&gt;要想播放这个 Playlist, 客户端需要首先下载他, 然后播放里面的每一个 Media Segment.&lt;/li&gt;
&lt;li&gt;更加复杂的情况是, Playlist 是一个 Master Playlist, 包含一个 Variant Stream 集合, 通常每个 Variant Stream 里面是同一个流的多个不同版本(如: 分辨率, 码率不同).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hls-media-segments&#34;&gt;HLS Media Segments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每一个 Media Segment 通过一个 URI 指定, 可能包含一个 byte range.&lt;/li&gt;
&lt;li&gt;每一个 Media Segment 的 duration 通过 &lt;code&gt;EXTINF&lt;/code&gt; tag 指定.&lt;/li&gt;
&lt;li&gt;每一个 Media Segment 有一个唯一的整数 Media Segment Number.&lt;/li&gt;
&lt;li&gt;有些媒体格式需要一个 format-specific sequence 来初始化一个 parser, 在 Media Segment 被 parse 之前. 这个字段叫做 Media Initialization Section, 通过 &lt;code&gt;EXT-X-MAP&lt;/code&gt; tag 来指定.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;支持的-media-segment-格式&#34;&gt;支持的 Media Segment 格式&lt;/h4&gt;
&lt;h5 id=&#34;mpeg-2-transport-streams&#34;&gt;MPEG-2 Transport Streams&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;即最常见的 TS 文件.&lt;/li&gt;
&lt;li&gt;RFC: ISO_13818.&lt;/li&gt;
&lt;li&gt;Media Initialization Section: PAT(Program Association Table) 跟 PMT(Program Map Table).&lt;/li&gt;
&lt;li&gt;每个 TS segment 必须值含一个 MPEG-2 Program.&lt;/li&gt;
&lt;li&gt;每一个 TS segment 包含一个 PAT 和 PMT, 最好在 segment 的开始处, 或者通过一个 &lt;code&gt;EXT-X-MAP&lt;/code&gt; tag 来指定.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;fragmented-mpeg-4&#34;&gt;Fragmented MPEG-4&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;即常提到的 fMP4.&lt;/li&gt;
&lt;li&gt;RFC: ISOBMFF.&lt;/li&gt;
&lt;li&gt;Media Initialization Section: &lt;code&gt;ftyp&lt;/code&gt; box(包含一个高于 &lt;code&gt;ios6&lt;/code&gt; 的 brand), &lt;code&gt;ftyp&lt;/code&gt; box 必须紧跟在 &lt;code&gt;moov&lt;/code&gt; box 之后. &lt;code&gt;moov&lt;/code&gt; box 必须包含一个 &lt;code&gt;trak&lt;/code&gt; box(对于每个 fMP4 segment 里面的 &lt;code&gt;traf&lt;/code&gt; box, 包含匹配的 &lt;code&gt;track_ID&lt;/code&gt;). 每个 &lt;code&gt;trak&lt;/code&gt; box 应该包含一个 sample table, 但是他的 sample count 必须为 0. &lt;code&gt;mvhd&lt;/code&gt; box 跟 &lt;code&gt;tkhd&lt;/code&gt; 的 duration 必须为 0. &lt;code&gt;mvex&lt;/code&gt; box 必须跟在上一个 &lt;code&gt;trak&lt;/code&gt; box 后面.&lt;/li&gt;
&lt;li&gt;不像普通的 MP4 文件包含一个 &lt;code&gt;moov&lt;/code&gt; box(包含 sample tables) 和一个 &lt;code&gt;mdat&lt;/code&gt; box(包含对应的 samples), 一个 fMP4 包含一个 &lt;code&gt;moof&lt;/code&gt; box (包含 sample table 的子集), 和一个 &lt;code&gt;mdat&lt;/code&gt; box(包含对应的 samples).&lt;/li&gt;
&lt;li&gt;在每一个 fMP4 segment 里面, 每一个 &lt;code&gt;traf&lt;/code&gt; box 必须包含一个 &lt;code&gt;tfdt&lt;/code&gt; box, fMP4 segment 必须使用 movie-fragment relative addressing. fMP4 segments 绝对不能使用外部的 data references.&lt;/li&gt;
&lt;li&gt;每一个 fMP4 segment 必须有一个 &lt;code&gt;EXT-X-MAP&lt;/code&gt; tag.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;packed-audio&#34;&gt;Packed Audio&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;一个 Packed Audio Segment 包含编码的 audio samples 和 ID3 tags. 简单的打包到一起, 包含最小的 framing, 并且没有 per-sample timestamp.&lt;/li&gt;
&lt;li&gt;支持的 Packed Audio: AAC with ADTS
framing [ISO_13818_7], MP3 [ISO_13818_3], AC-3 [AC_3], Enhanced
AC-3 [AC_3].&lt;/li&gt;
&lt;li&gt;一个 Packed Audio Segment 没有 Media Initialization Section.&lt;/li&gt;
&lt;li&gt;每一个 Packed Audio Segment 必须在他的第一个 sample 指定 timestamp 通过一个 ID3 PRIV tag.&lt;/li&gt;
&lt;li&gt;ID3 PRIV owner identifier 必须是 &lt;code&gt;com.apple.streaming.transportStreamTimestamp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;ID3 payload 必须是一个 33-bit MPEG-2 Program Elementary Stream timestamp 的大端 eight-octet number, 高 31 为设置为 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;webvtt&#34;&gt;WebVTT&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;一个 WebVTT Segment 是一个 WebVTT 文件的一个 section, WebVTT Segment 包含 subtitles.&lt;/li&gt;
&lt;li&gt;Media Initialization Section: WebVTT header.&lt;/li&gt;
&lt;li&gt;每一个 WebVTT Segment 必须有以一个 WebVTT header 开始, 或者有一个 &lt;code&gt;EXT-X-MAP&lt;/code&gt; tag 来指定.&lt;/li&gt;
&lt;li&gt;每一个 WebVTT header 应该有一个 &lt;code&gt;X-TIMESTAMP-MAP&lt;/code&gt; 来保证音视频同步.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hls-playlists&#34;&gt;HLS Playlists&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Playlist 文件的格式是起源于 M3U, 并且继承两个 tag: &lt;code&gt;EXTM3U&lt;/code&gt; 和 &lt;code&gt;EXTINF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面的 tags 通过 &lt;code&gt;BNF-style&lt;/code&gt; 语法来指定.&lt;/li&gt;
&lt;li&gt;一个 Playlist 文件必须通过 URI(.m3u8 或 m3u) 或者 HTTP Content-Type 来识别(application/vnd.apple.mpegurl 或 audio/mpegurl).&lt;/li&gt;
&lt;li&gt;换行符可以用 &lt;code&gt;\n&lt;/code&gt; 或者 &lt;code&gt;\r\n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;以 &lt;code&gt;#&lt;/code&gt; 开头的是 tag 或者注释, 以 &lt;code&gt;#EXT&lt;/code&gt; 开头的是 tag, 其余的为注释, 在解析时应该忽略.&lt;/li&gt;
&lt;li&gt;Playlist 里面的 URI 可以用绝对地址或者相对地址, 如果使用相对地址, 那么是相对于 Playlist 文件的地址.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;attribute-lists&#34;&gt;Attribute Lists&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;有的 tags 的值是 Attribute Lists.&lt;/li&gt;
&lt;li&gt;一个 Attribute List 是一个用逗号分隔的 attribute/value 对列表.&lt;/li&gt;
&lt;li&gt;格式为: &lt;code&gt;AttributeName=AttributeValue&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;basic-tags&#34;&gt;Basic Tags&lt;/h4&gt;
&lt;p&gt;Basic Tags 可以用在 Media Playlist 和 Master Playlist 里面.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXTM3U&lt;/code&gt;: 必须在文件的第一行, 标识是一个 Extended M3U Playlist 文件.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-VERSION&lt;/code&gt;: 表示 Playlist 兼容的版本.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;media-segment-tags&#34;&gt;Media Segment Tags&lt;/h4&gt;
&lt;p&gt;每一个 Media Segment 通过一系列的 Media Segment tags 跟一个 URI 来指定. 有的 Media Segment tags 只应用与下一个 segment, 有的则是应用所有下面的 segments. 一个 Media Segment tag 只能出现在 Media Playlist 里面.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXTINF&lt;/code&gt;: 用于指定 Media Segment 的 duration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-BYTERANGE&lt;/code&gt;: 用于指定 URI 的 &lt;code&gt;sub-range&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-DISCONTINUITY&lt;/code&gt;: 表示不连续.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-KEY&lt;/code&gt;: 表示 Media Segment 已加密, 该值用于解密.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-MAP&lt;/code&gt;: 用于指定 Media Initialization Section.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-PROGRAM-DATE-TIME&lt;/code&gt;: 和 Media Segment 的第一个 sample 一起来确定时间戳.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-DATERANGE&lt;/code&gt;: 将一个时间范围和一组属性键值对结合到一起.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;media-playlist-tags&#34;&gt;Media Playlist Tags&lt;/h4&gt;
&lt;p&gt;Media Playlist tags 描述 Media Playlist 的全局参数. 同样地, Media Playlist tags 只能出现在 Media Playlist 里面.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXT-X-TARGETDURATION&lt;/code&gt;: 用于指定最大的 Media Segment duration.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-MEDIA-SEQUENCE&lt;/code&gt;: 用于指定第一个 Media Segment 的 Media Sequence Number.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-DISCONTINUITY-SEQUENCE&lt;/code&gt;: 用于不同 Variant Stream 之间同步.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-ENDLIST&lt;/code&gt;: 表示结束.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-PLAYLIST-TYPE&lt;/code&gt;: 可选, 指定整个 Playlist 的类型.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-I-FRAMES-ONLY&lt;/code&gt;: 表示每个 Media Segment 描述一个单一的 I-frame.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;master-playlist-tags&#34;&gt;Master Playlist Tags&lt;/h4&gt;
&lt;p&gt;Master Playlist tags 定义 Variant Streams, Renditions 和 其他显示的全局参数. Master Playlist tags 只能出现在 Master Playlist 中.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXT-X-MEDIA&lt;/code&gt;: 用于关联同一个内容的多个 Media Playlist 的多种 renditions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-STREAM-INF&lt;/code&gt;: 用于指定一个 Variant Stream.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-I-FRAME-STREAM-INF&lt;/code&gt;: 用于指定一个 Media Playlist 包含媒体的 I-frames.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-SESSION-DATA&lt;/code&gt;: 存放一些 session 数据.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-SESSION-KEY&lt;/code&gt;: 用于解密.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;media-or-master-playlist-tags&#34;&gt;Media or Master Playlist Tags&lt;/h4&gt;
&lt;p&gt;这里的 tags 可以出现在 Media Playlist 或者 Master Playlist 中. 但是如果同时出现在同一个 Master Playlist 和 Media Playlist 中时, 必须为相同值.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EXT-X-INDEPENDENT-SEGMENTS&lt;/code&gt;: 表示每个 Media Segment 可以独立解码.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXT-X-START&lt;/code&gt;: 标识一个优选的点来播放这个 Playlist.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;服务器端与客户端逻辑&#34;&gt;服务器端与客户端逻辑&lt;/h3&gt;
&lt;p&gt;以下流程仅供参考, 其实不同的播放器客户端以及服务器端的拉取规则都有很多细节差异.&lt;/p&gt;
&lt;h4 id=&#34;服务器端逻辑&#34;&gt;服务器端逻辑&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;将媒体源切片成 Media Segment, 应该优先从可以高效解码的时间点来进行切片(如: I-frame).&lt;/li&gt;
&lt;li&gt;为每一个 Media Segment 生成 URI.&lt;/li&gt;
&lt;li&gt;Server 需要支持 &amp;ldquo;gzip&amp;rdquo; 方式压缩文本内容.&lt;/li&gt;
&lt;li&gt;创建一个 Media Playlist 索引文件, &lt;code&gt;EXT-X-VERSION&lt;/code&gt; 不要高于他需要的版本, 来提供更好的兼容性.&lt;/li&gt;
&lt;li&gt;Server 不能随便修改 Media Playlist, 除了 Append 文本到文件末尾, 按顺序移除 Media Segment URIs, 增长 &lt;code&gt;EXT-X-MEDIA-SEQUENCE&lt;/code&gt; 和 &lt;code&gt;EXT-X-DISCONTINUITY-SEQUENCE&lt;/code&gt;, 添加 &lt;code&gt;EXT-X-ENDLIST&lt;/code&gt; 到文件尾.&lt;/li&gt;
&lt;li&gt;在最后添加 &lt;code&gt;EXT-X-ENDLIST&lt;/code&gt; tag, 来减少 Client reload Playlist 的次数.&lt;/li&gt;
&lt;li&gt;注意点播与直播服务器不同的地方是, 直播的 m3u8 文件会不断更新, 而点播的 m3u8 文件是不会变的, 只需要客户端在开始时请求一次即可.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;客户端逻辑&#34;&gt;客户端逻辑&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;客户端通过 URI 获取 Playlist. 如果是 Master Playlist, 客户端可以选择一个 Variant Stream 来播放.&lt;/li&gt;
&lt;li&gt;客户端检查 &lt;code&gt;EXT-X-VERSION&lt;/code&gt; 版本是否满足.&lt;/li&gt;
&lt;li&gt;客户端应该忽略不可识别的 tags, 忽略不可识别的属性键值对.&lt;/li&gt;
&lt;li&gt;加载 Media Playlist file.&lt;/li&gt;
&lt;li&gt;播放 Media Playlist file.&lt;/li&gt;
&lt;li&gt;重加载 Media Playlist file.&lt;/li&gt;
&lt;li&gt;决定下一次要加载的 Media Segment.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;hls-的优势&#34;&gt;HLS 的优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户端支持简单, 只需要支持 HTTP 请求即可, HTTP 协议无状态, 只需要按顺序下载媒体片段即可.&lt;/li&gt;
&lt;li&gt;使用 HTTP 协议网络兼容性好, HTTP 数据包也可以方便地通过防火墙或者代理服务器, CDN 支持良好.&lt;/li&gt;
&lt;li&gt;Apple 的全系列产品支持, 由于 HLS 是苹果提出的, 所以在 Apple 的全系列产品包括 iphone, ipad, safari 都不需要安装任何插件就可以原生支持播放 HLS, 现在, Android 也加入了对 HLS 的支持.&lt;/li&gt;
&lt;li&gt;自带多码率自适应, Apple 在提出 HLS 时, 就已经考虑了码流自适应的问题.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hls-的劣势&#34;&gt;HLS 的劣势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;相比 RTMP 这类长连接协议, 延时较高, 难以用到互动直播场景.&lt;/li&gt;
&lt;li&gt;对于点播服务来说, 由于 TS 切片通常较小, 海量碎片在文件分发, 一致性缓存, 存储等方面都有较大挑战.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;改进的-hls-技术&#34;&gt;改进的 HLS 技术&lt;/h2&gt;
&lt;p&gt;由于客户端每次请求 TS 或 M3U8 有可能都是一个新的连接请求, 所以, 我们无法有效的标识客户端, 一旦出现问题, 基本无法有效的定位问题, 所以, 一般工业级的服务器都会对传统的 HLS 做一些改进.&lt;/p&gt;
&lt;p&gt;这里主要介绍网宿的 Variant HLS 与又拍云的 HLS+.&lt;/p&gt;
&lt;h3 id=&#34;网宿的-variant-hls&#34;&gt;网宿的 Variant HLS&lt;/h3&gt;
&lt;p&gt;首先, 我们可以下载一条网宿的 M3U8 文件:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget http://bililive.kksmg.com/hls/stvd6edb9a6_45b34047833af658bf4945a8/playlist.m3u8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后, 打开下载得到的 playlist 文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#EXTM3U
#EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=781000
http://bililive.kksmg.com/hls/stvd6edb9a6_45b34047833af658bf4945a8/playlist.m3u8?wsSession=0105cb4e8fe63bccab511a4a-149017212774715&amp;amp;wsIPSercert=b80d38c068c9e3634a7ebb2f2bbf9b89&amp;amp;wsMonitor=-1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出这是一个 Master Playlist, 里面嵌套了一层 M3U8, 同时可以看出网宿采用 &lt;code&gt;wsSession&lt;/code&gt; 来标识一条播放连接.&lt;/p&gt;
&lt;h3 id=&#34;又拍云的-hls&#34;&gt;又拍云的 HLS+&lt;/h3&gt;
&lt;h4 id=&#34;variant-hls&#34;&gt;Variant HLS&lt;/h4&gt;
&lt;p&gt;首先, 我们可以下载一条又拍云的 M3U8 文件:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget http://uplive.b0.upaiyun.com/live/loading.m3u8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后, 打开下载得到的 playlist 文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#EXTM3U
#EXT-X-VERSION:3
#EXT-X-ALLOW-CACHE:YES
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-TARGETDURATION:1
#EXTINF:0.998, no desc
http://183.158.35.12:8080/uplive.b0.upaiyun.com/live/loading-0.ts?shp_uuid=e4989f34fcab282e21ef1fd2980284cb&amp;amp;shp_ts=1490172420851&amp;amp;shp_cid=17906&amp;amp;shp_pid=3370578&amp;amp;shp_sip0=127.0.0.1&amp;amp;shp_sip1=183.158.35.12&amp;amp;domain=uplive.b0.upaiyun.com&amp;amp;shp_seqno=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出又拍云的 HLS+ 也支持这种 Variant HLS 方式来标识一条 HLS 连接, 可以看出, 又拍云使用 uuid 来表示一条 HLS 连接.&lt;/p&gt;
&lt;h4 id=&#34;http-302&#34;&gt;HTTP 302&lt;/h4&gt;
&lt;p&gt;首先, 以 HTTP 302 方式来请求播放地址.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ curl -v http://uplive.b0.upaiyun.com/live/loading.m3u8\?shp_identify\=302 -o playlist
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 183.158.35.59...
* TCP_NODELAY set
* Connected to uplive.b0.upaiyun.com (183.158.35.59) port 80 (#0)
&amp;gt; GET /live/loading.m3u8?shp_identify=302 HTTP/1.1
&amp;gt; Host: uplive.b0.upaiyun.com
&amp;gt; User-Agent: curl/7.51.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 302 Found
&amp;lt; Server: marco/0.26
&amp;lt; Date: Wed, 22 Mar 2017 08:54:11 GMT
&amp;lt; Content-Type: text/plain; charset=utf-8
&amp;lt; Content-Length: 259
&amp;lt; Connection: keep-alive
&amp;lt; Access-Control-Allow-Methods: GET
&amp;lt; Access-Control-Allow-Origin: *
&amp;lt; Location: http://183.158.35.19:8080/uplive.b0.upaiyun.com/live/loading.m3u8?shp_uuid=2862b1b817a74cf719b1cd8f554616cd&amp;amp;shp_ts=1490172851450&amp;amp;shp_cid=59553&amp;amp;shp_pid=1730488&amp;amp;shp_sip0=127.0.0.1&amp;amp;shp_sip1=183.158.35.19&amp;amp;domain=uplive.b0.upaiyun.com&amp;amp;shp_identify=302
&amp;lt;
{ [259 bytes data]
* Curl_http_done: called premature == 0
100   259  100   259    0     0   4813      0 --:--:-- --:--:-- --:--:--  4886
* Connection #0 to host uplive.b0.upaiyun.com left intact
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开 playlist 内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Redirect to http://183.158.35.19:8080/uplive.b0.upaiyun.com/live/loading.m3u8?shp_uuid=2862b1b817a74cf719b1cd8f554616cd&amp;amp;shp_ts=1490172851450&amp;amp;shp_cid=59553&amp;amp;shp_pid=1730488&amp;amp;shp_sip0=127.0.0.1&amp;amp;shp_sip1=183.158.35.19&amp;amp;domain=uplive.b0.upaiyun.com&amp;amp;shp_identify=302
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在跳转之后的地址存放真正的 playlist, 同时, 也能够将 uuid 加入到了连接上.&lt;/p&gt;
&lt;p&gt;总地来说, 不管通过哪种方式, 最终我们都能通过一个唯一的 id 来标识一条流, 这样在排查问题时就可以根据这个 id 来定位播放过程中的问题.&lt;/p&gt;
&lt;h2 id=&#34;hls-延时分析&#34;&gt;HLS 延时分析&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;HLS 理论延时 = 1 个切片的时长 + 0-1个 td (td 是 EXT-X-TARGETDURATION, 可简单理解为播放器取片的间隔时间) + 0-n 个启动切片(苹果官方建议是请求到 3 个片之后才开始播放) + 播放器最开始请求的片的网络延时(网络连接耗时)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了追求低延时效果, 可以将切片切的更小, 取片间隔做的更小, 播放器未取到 3 个片就启动播放. 但是, 这些优化方式都会增加 HLS 不稳定和出现错误的风险.&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://godoc.org/github.com/osrtss/rtss/m3u8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;M3U8 golang library&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/osrtss/rtss/tree/master/m3u8/example/hlsdownloader&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HLS downloader&lt;/a&gt;
: 读取一个 m3u8 URL, 下载为 TS 文件.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Live_Streaming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HLS on wikipedia&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apple Developer&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIyNDA1OTI2Nw==&amp;amp;mid=2666574360&amp;amp;idx=1&amp;amp;sn=ef1a484c04943c765f6fce5f2bddc83c&amp;amp;chksm=f310d8f4c46751e25c91a55817fac4a7f84476925c0bd88a4ca428c3e09c7f3c6357a8887f39&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0322dFKxFXIYndfVLY1Lp289&amp;amp;key=41cc67db7e0a07a6eebe2fdab4a9db5ee1696265738d17dc51bb888e61e485c5be3ccc178acd6b5b185b05e28224c1ba3caa835627757343db3e940331d6afc3316ef7a03908fb727c630026c98a0f57&amp;amp;ascene=0&amp;amp;uin=MzczODI2ODU%3D&amp;amp;devicetype=iMac&amp;#43;MacBookPro11%2C3&amp;#43;OSX&amp;#43;OSX&amp;#43;10.12.3&amp;#43;build%2816D32%29&amp;amp;version=12020010&amp;amp;nettype=WIFI&amp;amp;fontScale=100&amp;amp;pass_ticket=weWVu89q646SDwy9dCFmksdsH21wbzfJgMDMyh4p88A%3D&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;流媒体协议—HLS&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2016 总结</title>
      <link>/zh/post/2016-summary/</link>
      <pubDate>Mon, 02 Jan 2017 18:34:50 +0800</pubDate>
      <guid>/zh/post/2016-summary/</guid>
      <description>&lt;p&gt;今年是忙碌的一年, 发生了太多的事情. 完成了一些事情, 也有太多的事情没有完成. 貌似每年都是这样.&lt;/p&gt;
&lt;p&gt;这里总结一下以及明年的规划.&lt;/p&gt;
&lt;h2 id=&#34;2016-done&#34;&gt;2016 Done&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;完成写框架的心愿.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;一个 TCP 之上 Redis 服务端框架: 
&lt;a href=&#34;https://github.com/Akagi201/redface&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;redface&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;类 koajs 的轻量级 web 框架: 
&lt;a href=&#34;https://github.com/Akagi201/light&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;light&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;统一的网络层框架: 
&lt;a href=&#34;https://github.com/osrtss/engine&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RTSS/engine&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;在公司内部用 swagger 写了一个 API 服务.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;玩转了 TCP, UDP, HTTP, WebSocket 的 client 跟 server 端的实现. 写了非常多的工具跟轮子.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;个人的工具库, 现在可以随手写个 Go 的后端服务: 
&lt;a href=&#34;https://github.com/Akagi201/utilgo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;utilgo&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;不再去深入落后的 RTMP 那套玩意了, 开启 WebRTC 之旅.&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;线上分享: 
&lt;a href=&#34;https://github.com/Akagi201/akshare&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;akshare&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;在公司结识了一帮可以一起打拼的好兄弟, 没有各种 &amp;ldquo;人&amp;rdquo; 的问题.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2017-tobe-done&#34;&gt;2017 Tobe Done&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;WebRTC: 玩转 WebRTC. 深度参与一些开源项目, 认识一些牛人.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;Quant: 爬虫以及 Quant, 达到熟练以及实战的水平.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;身体: 锻炼身体, 生活更加健康一些.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;开源: 写一个开源的实时通信的平台, 包括后端, 前端, 以及移动端.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;blog: 养成定期写 blog 的习惯, ==, 少看一些动漫以及日剧.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;文档: 锻炼写出优秀文档的能力, 向阮一峰看齐.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;写书: 出一本流媒体方面的书.&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;写书: &lt;code&gt;&amp;lt;FreeRadius 新手入门&amp;gt;&lt;/code&gt; 这本书翻译完, 太多人催我了.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>HTML5 直播协议之 WebSocket 和 MSE</title>
      <link>/zh/post/websocket-mse/</link>
      <pubDate>Fri, 02 Dec 2016 10:39:50 +0800</pubDate>
      <guid>/zh/post/websocket-mse/</guid>
      <description>&lt;p&gt;当前为了满足比较火热的移动 Web 端直播需求, 一系列的 HTML5 直播技术迅速的发展了起来.&lt;/p&gt;
&lt;p&gt;常见的可用于 HTML5 的直播技术有 HLS, WebSocket 与 WebRTC. 今天我要向大家介绍一下 WebSocket 与 MSE 相关的内容, 并在最后通过一个实际的例子, 来展示其具体的用法.&lt;/p&gt;
&lt;h2 id=&#34;大纲&#34;&gt;大纲&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;WebSocket 协议介绍.&lt;/li&gt;
&lt;li&gt;WebSocket Client/Server API 介绍.&lt;/li&gt;
&lt;li&gt;MSE 介绍.&lt;/li&gt;
&lt;li&gt;fMP4 介绍.&lt;/li&gt;
&lt;li&gt;Demo 展示.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;websocket&#34;&gt;WebSocket&lt;/h2&gt;
&lt;p&gt;通常的 Web 应用都是围绕着 HTTP 的请求/响应模型而构建的. 所有的 HTTP 通信都是通过客户端来控制的, 都是由客户端向服务器发出一个请求, 服务器接收和处理完毕后再返回结果给客户端, 客户端再将数据展现出来. 这种模式不能满足实时应用的需求, 于是出现了 SSE, Comet 等 &amp;ldquo;服务器推&amp;rdquo; 的长连接技术.&lt;/p&gt;
&lt;p&gt;WebSocket 是直接基于 TCP 连接之上的通信协议, 可以在单个 TCP 连接上进行全双工的通信. WebSocket 在 2011 年被 IETF 定为标准 RFC 6455, 并被 RFC 7936 所补充规范, WebSocket API 被 W3C 定为标准.&lt;/p&gt;
&lt;p&gt;WebSocket 是独立的创建在 TCP 上的协议, HTTP 协议中的那些概念都不复存在, 和 HTTP 的唯一关联是使用 HTTP 协议的 101 状态码进行协议切换, 使用的 TCP 端口是 80, 可以用于绕过大多数防火墙的限制.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/websocket_protocol.png&#34; alt=&#34;websocket_protocol&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;websocket-握手&#34;&gt;WebSocket 握手&lt;/h3&gt;
&lt;p&gt;为了更方便地部署新协议，HTTP/1.1 引入了 Upgrade 机制, 它使得客户端和服务端之间可以借助已有的 HTTP 语法升级到其它协议. 这个机制在 RFC7230 的 
&lt;a href=&#34;http://httpwg.org/specs/rfc7230.html#header.upgrade&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;6.7 Upgrade&lt;/a&gt;
) 一节中有详细描述.&lt;/p&gt;
&lt;p&gt;要发起 HTTP/1.1 协议升级，客户端必须在请求头部中指定这两个字段:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection: Upgrade
Upgrade: protocol-name[/protocol-version]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果服务端同意升级, 那么需要这样响应:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: protocol-name[/protocol-version]

[... data defined by new protocol ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到, HTTP Upgrade 响应的状态码是 &lt;code&gt;101&lt;/code&gt;, 并且响应正文可以使用新协议定义的数据格式.&lt;/p&gt;
&lt;p&gt;WebSocket 握手就利用了这种 HTTP Upgrade 机制. 一旦握手完成，后续数据传输就直接在 TCP 上完成.&lt;/p&gt;
&lt;h3 id=&#34;websocket-javascript-api&#34;&gt;WebSocket JavaScript API&lt;/h3&gt;
&lt;p&gt;目前主流的浏览器提供了 WebSocket 的 API 接口, 可以发送消息(文本或者二进制)给服务器, 并且接收事件驱动的响应数据.&lt;/p&gt;
&lt;p&gt;Step1 检查浏览器是否支持 WebSocket.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(window.WebSocket) {
	// WebSocket代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step2 建立连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ws = new WebSocket(&#39;ws://localhost:8327&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step3 注册回调函数以及收发数据&lt;/p&gt;
&lt;p&gt;分别注册 WebSocket 对象的 onopen, onclose, onerror 以及 onmessage 回调函数.&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;ws.send()&lt;/code&gt; 来进行发送数据, 这里不仅可以发送字符串, 也可以发送 Blob 或 ArrayBuffer 类型的数据.&lt;/p&gt;
&lt;p&gt;如果接收的是二进制数据，需要将连接对象的格式设为 blob 或 arraybuffer.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ws.binaryType = &#39;arraybuffer&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;websocket-golang-api&#34;&gt;WebSocket Golang API&lt;/h3&gt;
&lt;p&gt;服务器端 WebSocket 库我推荐使用 Google 自己的 
&lt;a href=&#34;https://godoc.org/golang.org/x/net/websocket&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;golang.org/x/net/websocket&lt;/code&gt;&lt;/a&gt;
, 可以非常方便的与 &lt;code&gt;net/http&lt;/code&gt; 一起使用.&lt;/p&gt;
&lt;p&gt;可以将 websocket 的 handler function 通过 &lt;code&gt;websocket.Handler&lt;/code&gt; 转换成 &lt;code&gt;http.Handler&lt;/code&gt;, 这样就可以跟 &lt;code&gt;net/http&lt;/code&gt; 库一起使用了.&lt;/p&gt;
&lt;p&gt;然后通过 &lt;code&gt;websocket.Message.Receive&lt;/code&gt; 来接收数据, 通过 &lt;code&gt;websocket.Message.Send&lt;/code&gt; 来发送数据.&lt;/p&gt;
&lt;p&gt;具体代码可以看下面的 Demo 部分.&lt;/p&gt;
&lt;h2 id=&#34;mse&#34;&gt;MSE&lt;/h2&gt;
&lt;p&gt;在介绍 MSE 之前, 我们先看看 HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 有哪些限制.&lt;/p&gt;
&lt;h3 id=&#34;html5-audio-和-video-标签的限制&#34;&gt;HTML5 &lt;audio&gt; 和 &lt;video&gt; 标签的限制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不支持流.&lt;/li&gt;
&lt;li&gt;不支持 DRM 和加密.&lt;/li&gt;
&lt;li&gt;很难自定义控制, 以及保持跨浏览器的一致性.&lt;/li&gt;
&lt;li&gt;编解码和封装在不同浏览器支持不同.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MSE 是解决 HTML5 的流问题.&lt;/p&gt;
&lt;p&gt;Media Source Extensions (MSE) 是一个主流浏览器支持的新的 Web API. MSE 是一个 W3C 标准, 允许 JavaScript 动态的构建 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 的媒体流. 他定义了对象, 允许 JavaScript 传输媒体流片段到一个 HTMLMediaElement.&lt;/p&gt;
&lt;p&gt;通过使用 MSE, 你可以动态地修改媒体流而不需要任何的插件. 这让前端 JavaScript 可以做更多的事情, 我们可以在 JavaScript 进行转封装, 处理, 甚至转码.&lt;/p&gt;
&lt;p&gt;虽然 MSE 不能让流直接传输到 media tags 上, 但是 MSE 提供了构建跨浏览器播放器的核心技术, 让浏览器通过 JavaScript API 来推音视频到 media tags 上.&lt;/p&gt;
&lt;p&gt;现在每个客户端平台都开始逐步开放流媒体相关的 API: Flash 平台有 Netstream, Android 平台有 Media Codec API, 而 Web 上对应的就是标准的 MSE. 由此可以看出, 未来的趋势是在客户端可以做越来越多的事情.&lt;/p&gt;
&lt;h3 id=&#34;browser-support&#34;&gt;Browser Support&lt;/h3&gt;
&lt;p&gt;通过 
&lt;a href=&#34;http://caniuse.com/#feat=mediasource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;caniuse&lt;/a&gt;
 来检查是否浏览器支持情况.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/mse-support.png&#34; alt=&#34;mse-support&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过 
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/isTypeSupported&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;MediaSource.isTypeSupported()&lt;/code&gt;&lt;/a&gt;
 可以进一步地检查 codec MIME 类型是否支持.&lt;/p&gt;
&lt;p&gt;比较常用的视频封装格式有 webm 和 fMP4.&lt;/p&gt;
&lt;p&gt;WebM 和 WebP 是两个姊妹项目, 都是由 Google 赞助的. 由于 WebM 是基于 Matroska 的容器格式, 所以天生是流式的, 很适合用在流媒体领域里.&lt;/p&gt;
&lt;p&gt;下面着重介绍一些 fMP4 格式.&lt;/p&gt;
&lt;p&gt;我们都知道 MP4 是由一系列的 Boxes 组成的. 普通的 MP4 的是嵌套结构的, 客户端必须要从头加载一个 MP4 文件, 才能够完整播放, 不能从中间一段开始播放.&lt;/p&gt;
&lt;p&gt;而 fMP4 由一系列的片段组成, 如果你的服务器支持 byte-range 请求, 那么, 这些片段可以独立的进行请求到客户端进行播放, 而不需要加载整个文件.&lt;/p&gt;
&lt;p&gt;为了更加形象的说明这一点, 下面我介绍几个常用的分析 MP4 文件的工具.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://gpac.wp.mines-telecom.fr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gpac&lt;/a&gt;
 原名 mp4box, 是一个媒体开发框架, 在其源码下有大量的媒体分析工具可以使用, 
&lt;a href=&#34;https://github.com/gpac/gpac/tree/master/applications/testapps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;testapps&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://download.tsi.telecom-paristech.fr/gpac/mp4box.js/filereader.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mp4box.js&lt;/a&gt;
 是 mp4box 的 Javascript 版本.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.bento4.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bento4&lt;/a&gt;
 一个专门用于 MP4 的分析工具.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://mp4parser.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mp4parser&lt;/a&gt;
 在线 MP4 文件分析工具.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fragment-mp4-vs-non-fragment-mp4&#34;&gt;fragment mp4 vs non-fragment mp4&lt;/h3&gt;
&lt;p&gt;下面一个 fragment mp4 文件通过 
&lt;a href=&#34;http://mp4parser.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mp4parser&lt;/a&gt;
 分析后的截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/fmp4.png&#34; alt=&#34;fmp4&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面一个 non-fragment mp4 文件通过 
&lt;a href=&#34;http://mp4parser.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mp4parser&lt;/a&gt;
 分析后的截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nfmp4.png&#34; alt=&#34;nfmp4&#34;&gt;&lt;/p&gt;
&lt;p&gt;Apple 在今年的 WWDC 大会上宣布会在 iOS 10, tvOS, macOS 的 HLS 中支持 fMP4.&lt;/p&gt;
&lt;p&gt;值得一提的是, fMP4, CMAF, ISOBMFF 其实都是类似的东西.&lt;/p&gt;
&lt;h3 id=&#34;mse-javascript-api&#34;&gt;MSE JavaScript API&lt;/h3&gt;
&lt;p&gt;从高层次上看, MSE 提供了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一套 JavaScript API 来构建 media streams.&lt;/li&gt;
&lt;li&gt;一个拼接和缓存模型.&lt;/li&gt;
&lt;li&gt;识别一些 byte 流类型:
&lt;ul&gt;
&lt;li&gt;WebM&lt;/li&gt;
&lt;li&gt;ISO Base Media File Format&lt;/li&gt;
&lt;li&gt;MPEG-2 Transport Streams&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mse-内部结构&#34;&gt;MSE 内部结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/mse_arch.png&#34; alt=&#34;mse_arch&#34;&gt;&lt;/p&gt;
&lt;p&gt;MSE 本身的设计是不依赖任务特定的编解码和容器格式的, 但是不同的浏览器支持程度是不一样的. 可以通过传递一个 MIME 类型的字符串到静态方法: MediaSource.isTypeSupported 来检查.&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MediaSource.isTypeSupported(&#39;audio/mp3&#39;); // false
MediaSource.isTypeSupported(&#39;video/mp4&#39;); // true
MediaSource.isTypeSupported(&#39;video/mp4; codecs=&amp;quot;avc1.4D4028, mp4a.40.2&amp;quot;&#39;); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取 Codec MIME string 的方法可以通过在线的 
&lt;a href=&#34;http://nickdesaulniers.github.io/mp4info/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mp4info&lt;/a&gt;
 或者使用命令行 &lt;code&gt;mp4info test.mp4 | grep Codecs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以得到类似如下结果:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ mp4info fmp4.mp4| grep Codec
    Codecs String: mp4a.40.2
    Codecs String: avc1.42E01E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当前, H.264 + AAC 的 MP4 容器在所有的浏览器都支持.&lt;/p&gt;
&lt;p&gt;普通的 MP4 文件是不能和 MSE 一起使用的, 需要将 MP4 进行 fragment 化.&lt;/p&gt;
&lt;p&gt;检查一个 MP4 是否已经 fragment 的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mp4dump test.mp4 | grep &amp;quot;\[m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是 non-fragment 会显示类似信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ mp4dump nfmp4.mp4 | grep &amp;quot;\[m&amp;quot;
[mdat] size=8+50873
[moov] size=8+7804
  [mvhd] size=12+96
    [mdia] size=8+3335
      [mdhd] size=12+20
      [minf] size=8+3250
    [mdia] size=8+3975
      [mdhd] size=12+20
      [minf] size=8+3890
            [mp4a] size=8+82
    [meta] size=12+78
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果已经 fragment, 会显示如下类似信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ mp4dump fmp4.mp4 | grep &amp;quot;\[m&amp;quot; | head -n 30
[moov] size=8+1871
  [mvhd] size=12+96
    [mdia] size=8+312
      [mdhd] size=12+20
      [minf] size=8+219
            [mp4a] size=8+67
    [mdia] size=8+371
      [mdhd] size=12+20
      [minf] size=8+278
    [mdia] size=8+248
      [mdhd] size=12+20
      [minf] size=8+156
    [mdia] size=8+248
      [mdhd] size=12+20
      [minf] size=8+156
  [mvex] size=8+144
    [mehd] size=12+4
[moof] size=8+600
  [mfhd] size=12+4
[mdat] size=8+138679
[moof] size=8+536
  [mfhd] size=12+4
[mdat] size=8+24490
[moof] size=8+592
  [mfhd] size=12+4
[mdat] size=8+14444
[moof] size=8+312
  [mfhd] size=12+4
[mdat] size=8+1840
[moof] size=8+600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把一个 non-fragment MP4 转换成 fragment MP4.&lt;/p&gt;
&lt;p&gt;可以使用 FFmpeg 的 &lt;code&gt;-movflags&lt;/code&gt; 来转换&lt;/p&gt;
&lt;p&gt;对于原始文件为非 MP4 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -i trailer_1080p.mov -c:v copy -c:a copy -movflags frag_keyframe+empty_moov bunny_fragmented.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于原始文件已经是 MP4 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -i non_fragmented.mp4 -movflags frag_keyframe+empty_moov fragmented.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用 mp4fragment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mp4fragment input.mp4 output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;demo&#34;&gt;demo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/Akagi201/learning-webrtc/tree/master/mse/vod&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSE Vod Demo&lt;/a&gt;
 展示利用 MSE 和 WebSocket 实现一个点播服务.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/Akagi201/learning-webrtc/tree/master/mse/live&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSE Live Demo&lt;/a&gt;
 展示利用 MSE 和 WebSocket 实现一个直播服务.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mse-vod-demo&#34;&gt;MSE VOD Demo&lt;/h2&gt;
&lt;video src=&#34;http://akagi201.qiniudn.com/mse_vod_demo.mp4&#34; width=&#34;480&#34; height=&#34;320&#34; controls=&#34;controls&#34;&gt;
Your browser does not support the video tag.
&lt;/video&gt;
&lt;h2 id=&#34;mse-live-demo&#34;&gt;MSE Live Demo&lt;/h2&gt;
&lt;video src=&#34;http://akagi201.qiniudn.com/mse_live_demo.mp4&#34; width=&#34;480&#34; height=&#34;320&#34; controls=&#34;controls&#34;&gt;
Your browser does not support the video tag.
&lt;/video&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;h3 id=&#34;websocket-1&#34;&gt;WebSocket&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://tools.ietf.org/html/rfc6455&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rfc6455&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://imququ.com/post/protocol-negotiation-in-http2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP Upgrade&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://javascript.ruanyifeng.com/htmlapi/websocket.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebSocket API&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MDN WebSocket&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/winlinvip/videojs-flow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;videojs-flow&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mse-1&#34;&gt;MSE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.w3.org/TR/media-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;W3C&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/MediaSource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MDN MSE&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.leanbackplayer.com/test/h5mt.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTML5 Codec MIME&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>直播协议 HTTP-FLV 详解</title>
      <link>/zh/post/http-flv-explained/</link>
      <pubDate>Mon, 31 Oct 2016 16:21:50 +0800</pubDate>
      <guid>/zh/post/http-flv-explained/</guid>
      <description>&lt;p&gt;传统的直播协议要么使用 Adobe 的基于 TCP 的 RTMP 协议, 要么使用 Apple 的基于 HTTP 的 HLS 协议.&lt;/p&gt;
&lt;p&gt;今天我要向大家介绍另外一种结合了 RTMP 的低延时, 以及可以复用现有 HTTP 分发资源的流式协议 HTTP-FLV.&lt;/p&gt;
&lt;h2 id=&#34;flv&#34;&gt;FLV&lt;/h2&gt;
&lt;p&gt;首先, 一定要先介绍一下 FLV 文件格式的细节.&lt;/p&gt;
&lt;h3 id=&#34;flv-adobe-官方标准&#34;&gt;FLV adobe 官方标准&lt;/h3&gt;
&lt;p&gt;FLV 文件格式标准是写在 
&lt;a href=&#34;http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;F4V/FLV file format spec v10.1&lt;/a&gt;
 的附录 E 里面的 FLV File Format.&lt;/p&gt;
&lt;h3 id=&#34;单位说明&#34;&gt;单位说明&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Unit data types&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SI8&lt;/td&gt;
&lt;td&gt;Signed 8-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SI16&lt;/td&gt;
&lt;td&gt;Signed 16-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SI24&lt;/td&gt;
&lt;td&gt;Signed 24-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SI32&lt;/td&gt;
&lt;td&gt;Signed 32-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SI64&lt;/td&gt;
&lt;td&gt;Signed 32-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;Unsigned 8-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UI16&lt;/td&gt;
&lt;td&gt;Unsigned 16-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UI24&lt;/td&gt;
&lt;td&gt;Unsigned 24-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UI32&lt;/td&gt;
&lt;td&gt;Unsigned 32-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UI64&lt;/td&gt;
&lt;td&gt;Unsigned 64-bit integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xxx[]&lt;/td&gt;
&lt;td&gt;Slice of type xxx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xxx[n]&lt;/td&gt;
&lt;td&gt;Array of type xxx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;Sequence of Unicode 8-bit characters (UTF-8), terminated with 0x00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;flv-文件头和文件体-e2-e3&#34;&gt;FLV 文件头和文件体 (E.2, E.3)&lt;/h3&gt;
&lt;p&gt;从整个文件上看, FLV = FLV File Header + FLV File Body&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FLV File Header&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Signature&lt;/td&gt;
&lt;td&gt;UI8[3]&lt;/td&gt;
&lt;td&gt;签名, 总是 &amp;lsquo;FLV&amp;rsquo; (0x464C56)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Version&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;版本, 总是 0x01, 表示 FLV version 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeFlagsReserved&lt;/td&gt;
&lt;td&gt;UB [5]&lt;/td&gt;
&lt;td&gt;全 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeFlagsAudio&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;1 = 有音频&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeFlagsReserved&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;全 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeFlagsVideo&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;1 = 有视频&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataOffset&lt;/td&gt;
&lt;td&gt;UI32&lt;/td&gt;
&lt;td&gt;整个文件头长度, 对于FLV v1, 总是 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FLV File Body&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PreviousTagSize0&lt;/td&gt;
&lt;td&gt;UI32&lt;/td&gt;
&lt;td&gt;总是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tag1&lt;/td&gt;
&lt;td&gt;FLVTAG&lt;/td&gt;
&lt;td&gt;第一个 tag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PreviousTagSize1&lt;/td&gt;
&lt;td&gt;UI32&lt;/td&gt;
&lt;td&gt;前一个 tag 的大小, 包括他的 header, 即: 11 + 前一个 tag 的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tag2&lt;/td&gt;
&lt;td&gt;FLVTAG&lt;/td&gt;
&lt;td&gt;第二个 tag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PreviousTagSizeN-1&lt;/td&gt;
&lt;td&gt;UI32&lt;/td&gt;
&lt;td&gt;前一个 tag 大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TagN&lt;/td&gt;
&lt;td&gt;FLVTAG&lt;/td&gt;
&lt;td&gt;最后一个 tag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PreviousTagSizeN&lt;/td&gt;
&lt;td&gt;UI32&lt;/td&gt;
&lt;td&gt;最后一个 tag 大小, 包括他的 header&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常, FLV 的前 13 个字节(flv header + PreviousTagSize0)完全相同, 所以, 程序中会单独定义一个常量来指定.&lt;/p&gt;
&lt;h3 id=&#34;flv-tag-e4&#34;&gt;FLV Tag (E.4)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FLV Tag&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reserved&lt;/td&gt;
&lt;td&gt;UB[2]&lt;/td&gt;
&lt;td&gt;保留给FMS, 应为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Filter&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;0 = unencrypted tags, 1 = encrypted tags&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TagType&lt;/td&gt;
&lt;td&gt;UB [5]&lt;/td&gt;
&lt;td&gt;类型, 0x08 = audio, 0x09 = video, 0x12 = script data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataSize&lt;/td&gt;
&lt;td&gt;UI24&lt;/td&gt;
&lt;td&gt;message 长度, 从 StreamID 到 tag 结束(len(tag) - 11)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Timestamp&lt;/td&gt;
&lt;td&gt;UI24&lt;/td&gt;
&lt;td&gt;相对于第一个 tag 的时间戳(unit: ms), 第一个 tag 总是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TimestampExtended&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;Timestamp 的高 8 位. 扩展 Timestamp 为 SI32 类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StreamID&lt;/td&gt;
&lt;td&gt;UI24&lt;/td&gt;
&lt;td&gt;总是 0, 至此为 11 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AudioTagHeader&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;IF TagType == 0x08&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VideoTagHeader&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;IF TagType == 0x09&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EncryptionHeader&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;IF Filter == 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FilterParams&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;IF Filter == 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AUDIODATA 或者 VIDEODATA 或者 SCRIPTDATA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Timestamp 和 TimestampExtended 组成了这个 TAG 包数据的 PTS 信息, PTS = Timestamp | TimestampExtended &amp;laquo; 24.&lt;/p&gt;
&lt;h3 id=&#34;audiotag-e42&#34;&gt;AudioTag (E.4.2)&lt;/h3&gt;
&lt;p&gt;由于 AAC 编码的特殊性, 这里着重说明了 AAC 编码的 Tag 格式.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Audio Tag&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AudioTagHeader&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SoundFormat&lt;/td&gt;
&lt;td&gt;UB[4]&lt;/td&gt;
&lt;td&gt;音频编码格式. 2 = MP3, 10 = AAC, 11 = Speex&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SoundRate&lt;/td&gt;
&lt;td&gt;UB[2]&lt;/td&gt;
&lt;td&gt;采样率. 0 = 5.5 kHz, 1 = 11 kHz, 2 = 22 kHz, 3 = 44 kHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SoundSize&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;采样大小. 0 = 8-bit, 1 = 16-bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SoundType&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;音频声道数. 0 = Mono, 1 = Stereo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AACPacketType&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;只有当 SoundFormat 为 10 时, 才有该字段. 0 = AAC sequence header, 1 = AAC raw&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AACAUDIODATA&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;AudioSpecificConfig&lt;/td&gt;
&lt;td&gt;IF AACPacketType == 0, 包含着一些更加详细音频的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;Raw AAC frame data in UI8 [n]&lt;/td&gt;
&lt;td&gt;IF AACPacketType == 1, audio payload, n = [AAC Raw data length] - ([has CRC] ? 9 : 7)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;AudioTagHeader 的第一个字节, 也就是接跟着 StreamID 的 1 个字节包含了音频类型, 采样率等的基本信息.&lt;/p&gt;
&lt;p&gt;AudioTagHeader 之后跟着的就是 AUDIODATA 部分了. 但是, 这里有个特例, 如果音频格式(SoundFormat)是 AAC, AudioTagHeader 中会多出 1 个字节的数据 AACPacketType, 这个字段来表示 AACAUDIODATA 的类型: 0 = AAC sequence header, 1 = AAC raw.&lt;/p&gt;
&lt;p&gt;AudioSpecificConfig 结构描述非常复杂, 在标准文档中是用伪代码描述的, 这里先假定要编码的音频格式, 做一下简化.&lt;/p&gt;
&lt;p&gt;音频编码为: &lt;code&gt;AAC-LC&lt;/code&gt;, 音频采样率为 44100.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AudioSpecificConfig&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audioObjectType&lt;/td&gt;
&lt;td&gt;UB[5]&lt;/td&gt;
&lt;td&gt;编码结构类型, AAC-LC 为 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;samplingFrequencyIndex&lt;/td&gt;
&lt;td&gt;UB[4]&lt;/td&gt;
&lt;td&gt;音频采样率索引值, 44100 对应值 4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;channelConfiguration&lt;/td&gt;
&lt;td&gt;UB[4]&lt;/td&gt;
&lt;td&gt;音频输出声道, 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GASpecificConfig&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;frameLengthFlag&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;标志位, 用于表明 IMDCT 窗口长度, 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dependsOnCoreCoder&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;标志位, 表明是否依赖于 corecoder, 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;extensionFlag&lt;/td&gt;
&lt;td&gt;UB[1]&lt;/td&gt;
&lt;td&gt;选择了 AAC-LC, 这里必须为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 FLV 的文件中, 一般情况下 AAC sequence header 这种包只出现1次, 而且是第一个 audio tag, 为什么需要这种 tag, 因为在做 FLV demux 的时候, 如果是 AAC 的音频, 需要在每帧 AAC ES 流前边添加 7 个字节 ADST 头, ADST 是解码器通用的格式, 也就是说 AAC 的纯 ES 流要打包成 ADST 格式的 AAC 文件, 解码器才能正常播放. 就是在打包 ADST 的时候, 需要 samplingFrequencyIndex 这个信息, samplingFrequencyIndex 最准确的信息是在 AudioSpecificConfig 中, 这样, 你就完全可以把 FLV 文件中的音频信息及数据提取出来, 送给音频解码器正常播放了.&lt;/p&gt;
&lt;h3 id=&#34;videotag-e43&#34;&gt;VideoTag (E.4.3)&lt;/h3&gt;
&lt;p&gt;由于 AVC(H.264) 编码的特殊性, 这里着重说明了 AVC(H.264) 编码的 Tag 格式.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Video Tag&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VideoTagHeader&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FrameType&lt;/td&gt;
&lt;td&gt;UB[4]&lt;/td&gt;
&lt;td&gt;1 = key frame, 2 = inter frame&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CodecID&lt;/td&gt;
&lt;td&gt;UB[4]&lt;/td&gt;
&lt;td&gt;7 = AVC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AVCPacketType&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;IF CodecID == 7, 0 = AVC sequence header(AVCDecoderConfigurationRecord), 1 = One or more AVC NALUs (Full frames are required), 2 = AVC end of sequence&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CompositionTime&lt;/td&gt;
&lt;td&gt;SI24&lt;/td&gt;
&lt;td&gt;IF AVCPacketType == 1 Composition time offset ELSE 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;VideoTagHeader 的第一个字节, 也就是接跟着 StreamID 的 1 个字节包含着视频帧类型及视频 CodecID 等最基本信息.&lt;/p&gt;
&lt;p&gt;VideoTagHeader 之后跟着的就是 VIDEODATA 部分了. 但是, 这里有个特例, 如果视频格式(CodecID)是 AVC, VideoTagHeader 会多出 4 个字节的信息.&lt;/p&gt;
&lt;p&gt;AVCDecoderConfigurationRecord 包含着是 H.264 解码相关比较重要的 SPS 和 PPS 信息, 在给 AVC 解码器送数据流之前一定要把 SPS 和 PPS 信息送出,否则的话, 解码器不能正常解码. 而且在解码器 stop 之后再次 start 之前, 如 seek, 快进快退状态切换等, 都需要重新送一遍 SPS 和 PPS 的信息. AVCDecoderConfigurationRecord 在 FLV 文件中一般情况也只出现 1 次, 也就是第一个 video tag.&lt;/p&gt;
&lt;p&gt;AVCDecoderConfigurationRecord 长度为 sizeof(UI8) * (11 + sps_size + pps_size)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AVCDecoderConfigurationRecord&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;configurationVersion&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;版本号, 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AVCProfileIndication&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;SPS[1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;profileCompatibility&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;SPS[2]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AVCLevelIndication&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;SPS[3]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reserved&lt;/td&gt;
&lt;td&gt;UB[6]&lt;/td&gt;
&lt;td&gt;111111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lengthSizeMinusOne&lt;/td&gt;
&lt;td&gt;UB[2]&lt;/td&gt;
&lt;td&gt;NALUnitLength - 1, 一般为 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reserved&lt;/td&gt;
&lt;td&gt;UB[3]&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;numberOfSequenceParameterSets&lt;/td&gt;
&lt;td&gt;UB[5]&lt;/td&gt;
&lt;td&gt;SPS 个数, 一般为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequenceParameterSetNALUnits&lt;/td&gt;
&lt;td&gt;UI8[sps_size + 2]&lt;/td&gt;
&lt;td&gt;sps_size(16bits) + sps(UI8[sps_size])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;numberOfPictureParameterSets&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;PPS 个数, 一般为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pictureParameterSetNALUnits&lt;/td&gt;
&lt;td&gt;UI8[pps_size + 2]&lt;/td&gt;
&lt;td&gt;pps_size(16bits) + pps(UI8[pps_size])&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;scriptdata-e44&#34;&gt;SCRIPTDATA (E.4.4)&lt;/h3&gt;
&lt;p&gt;ScriptTagBody 内容用 AMF 编码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SCRIPTDATA&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ScriptTagBody&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;SCRIPTDATAVALUE&lt;/td&gt;
&lt;td&gt;Method or object name. SCRIPTDATAVALUE.Type = 2 (String)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vale&lt;/td&gt;
&lt;td&gt;SCRIPTDATAVALUE&lt;/td&gt;
&lt;td&gt;AMF arguments or object properties.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCRIPTDATAVALUE&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;UI8&lt;/td&gt;
&lt;td&gt;ScriptDataValue 的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ScriptDataValue&lt;/td&gt;
&lt;td&gt;各种类型&lt;/td&gt;
&lt;td&gt;Script data 值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个 SCRIPTDATAVALUE 记录包含一个有类型的 ActionScript 值.&lt;/p&gt;
&lt;h3 id=&#34;onmetadata-e5&#34;&gt;onMetadata (E.5)&lt;/h3&gt;
&lt;p&gt;FLV metadata object 保存在 SCRIPTDATA 中, 叫 onMetaData. 不同的软件生成的 FLV 的 properties 不同.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;onMetaData&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audiocodecid&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Audio codec ID used in the file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audiodatarate&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Audio bit rate in kilobits per second&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audiodelay&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Delay introduced by the audio codec in seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audiosamplerate&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Frequency at which the audio stream is replayed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audiosamplesize&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Resolution of a single audio sample&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;canSeekToEnd&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;Indicating the last video frame is a key frame&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;creationdate&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;Creation date and time&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;duration&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Total duration of the file in seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filesize&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Total size of the file in bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;framerate&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Number of frames per second&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Height of the video in pixels&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stereo&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;Indicating stereo audio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;videocodecid&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Video codec ID used in the file (see E.4.3.1 for available CodecID values)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;videodatarate&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Video bit rate in kilobits per second&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;Width of the video in pixels&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;keyframes-索引信息&#34;&gt;keyframes 索引信息&lt;/h3&gt;
&lt;p&gt;官方的文档中并没有对 keyframes index 做描述, 但是, flv 的这种结构每个 tag 又不像 TS 有同步头, 如果没有 keyframes index 的话, seek 及快进快退的效果会非常差, 因为需要一个 tag 一个 tag 的顺序读取. 后来在做 flv 文件合成的时候, 发现网上有的 flv 文件将 keyframes 信息隐藏在 Script Tag 中. keyframes 几乎是一个非官方的标准, 也就是民间标准.&lt;/p&gt;
&lt;p&gt;两个常用的操作 metadata 的工具是 flvtool2 和 FLVMDI, 都是把 keyframes 作为一个默认的元信息项目. 在 FLVMDI 的
&lt;a href=&#34;http://www.buraks.com/flvmdi/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;主页&lt;/a&gt;
上有描述:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  keyframes: (Object) This object is added only if you specify the /k switch. &#39;keyframes&#39; is known to FLVMDI and if /k switch is not specified, &#39;keyframes&#39; object will be deleted.

  &#39;keyframes&#39; object has 2 arrays: &#39;filepositions&#39; and &#39;times&#39;. Both arrays have the same number of elements, which is equal to the number of key frames in the FLV. Values in times array are in &#39;seconds&#39;. Each correspond to the timestamp of the n&#39;th key frame. Values in filepositions array are in &#39;bytes&#39;. Each correspond to the fileposition of the nth key frame video tag (which starts with byte tag type 9).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说 keyframes 中包含着 2 个内容 &amp;lsquo;filepositions&amp;rsquo; 和 &amp;lsquo;times&amp;rsquo; 分别指的是关键帧的文件位置和关键帧的 PTS. 通过 keyframes 可以建立起自己的 Index, 然后在 seek 和快进快退的操作中, 快速有效地跳转到你想要找的关键帧位置进行处理.&lt;/p&gt;
&lt;h2 id=&#34;flv-分析工具&#34;&gt;FLV 分析工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.flvmeta.com/&#34;&gt;http://www.flvmeta.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;yamdi: 将flv转成带索引的flv, &lt;code&gt;yamdi -i i.flv -o o.flv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;flvlib: &lt;code&gt;pip install flvlib&lt;/code&gt;, 查看索引信息: &lt;code&gt;debug-flv --metadata file.flv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;flvcheck: &lt;a href=&#34;http://www.adobe.com/products/adobe-media-server-family/tool-downloads.html&#34;&gt;http://www.adobe.com/products/adobe-media-server-family/tool-downloads.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http-flv&#34;&gt;HTTP-FLV&lt;/h2&gt;
&lt;p&gt;HTTP-FLV, 即将音视频数据封装成 FLV, 然后通过 HTTP 协议传输给客户端.&lt;/p&gt;
&lt;p&gt;这里首先要说一下, HLS 其实是一个 &amp;ldquo;文本协议&amp;rdquo;, 而并不是一个流媒体协议. 那么, 什么样的协议才能称之为流媒体协议呢?&lt;/p&gt;
&lt;p&gt;流(stream): 数据在网络上按时间先后次序传输和播放的连续音/视频数据流. 之所以可以按照顺序传输和播放连续是因为在类似  RTMP, FLV 协议中, 每一个音视频数据都被封装成了包含时间戳信息头的数据包. 而当播放器拿到这些数据包解包的时候能够根据时间戳信息把这些音视频数据和之前到达的音视频数据连续起来播放. MP4, MKV 等等类似这种封装, 必须拿到完整的音视频文件才能播放, 因为里面的单个音视频数据块不带有时间戳信息, 播放器不能将这些没有时间戳信息数据块连续起来, 所以就不能实时的解码播放.&lt;/p&gt;
&lt;h3 id=&#34;延迟分析&#34;&gt;延迟分析&lt;/h3&gt;
&lt;p&gt;理论上(除去网络延迟外), FLV 可以做到仅仅一个音视频 tag 的延迟.&lt;/p&gt;
&lt;h3 id=&#34;相比-rtmp-的优点&#34;&gt;相比 RTMP 的优点:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以在一定程度上避免防火墙的干扰 (例如, 有的机房只允许 80 端口通过).&lt;/li&gt;
&lt;li&gt;可以很好的兼容 HTTP 302 跳转, 做到灵活调度.&lt;/li&gt;
&lt;li&gt;可以使用 HTTPS 做加密通道.&lt;/li&gt;
&lt;li&gt;很好的支持移动端(Android, IOS).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抓包分析&#34;&gt;抓包分析&lt;/h3&gt;
&lt;p&gt;打开网宿的 HTTP-FLV 流:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://175.25.168.16/pl3.live.panda.tv/live_panda/d4e0a83a7e0b0c6e4c5d03774169fa3e.flv?wshc_tag=0&amp;amp;wsts_tag=57e233b1&amp;amp;wsid_tag=6a27c14e&amp;amp;wsiphost=ipdbm&#34;&gt;http://175.25.168.16/pl3.live.panda.tv/live_panda/d4e0a83a7e0b0c6e4c5d03774169fa3e.flv?wshc_tag=0&amp;amp;wsts_tag=57e233b1&amp;amp;wsid_tag=6a27c14e&amp;amp;wsiphost=ipdbm&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Expires: Wed, 21 Sep 2016 07:16:02 GMT
Cache-Control: no-cache
Content-Type: video/x-flv
Pragma: no-cache
Via: 1.1 yc16:3 (Cdn Cache Server V2.0)
Connection: close
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现响应头中出现 &lt;code&gt;Connection: close&lt;/code&gt; 的字段, 表示网宿采用的是短连接, 则直接可以通过服务器关闭连接来确定消息的传输长度.&lt;/p&gt;
&lt;p&gt;如果 HTTP Header 中有 Content-Length, 那么这个 Content-Length 既表示实体长度, 又表示传输长度. 而 HTTP-FLV 这种流, 服务器是不可能预先知道内容大小的, 这时就可以使用 &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; 模式来传输数据了.&lt;/p&gt;
&lt;p&gt;如下的响应就是采用的Chunked的方式进行的传输的响应头:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Server: openresty
Date: Wed, 21 Sep 2016 07:38:01 GMT
Content-Type: video/x-flv
Transfer-Encoding: chunked
Connection: close
Expires: Wed, 21 Sep 2016 07:38:00 GMT
Cache-Control: no-cache
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mqkv 一个通用的基于分布式消息队列的分布式存储</title>
      <link>/zh/post/mqkv-a-general-distributed-storage-based-on-distributed-message-queue/</link>
      <pubDate>Wed, 21 Sep 2016 17:50:00 +0800</pubDate>
      <guid>/zh/post/mqkv-a-general-distributed-storage-based-on-distributed-message-queue/</guid>
      <description>&lt;p&gt;公司直播系统的源站集群需要一个中心存储服务来提供流的元数据信息的存储和查询功能。由于源站集群是部署在全国各地的多个机房, 多个节点上的。所以, 这里是一个典型的分布式存储的应用场景。这个服务的稳定性非常重要, 也直接影响到直播系统整个服务整体的可用性。&lt;/p&gt;
&lt;p&gt;下面, 我来与大家分享交流一下, 我们源站集群共享存储方案经历了哪些变化, 最后, 介绍下我们的下一代共享存储方案 mqkv, 也欢迎熟悉分布式与存储的小伙伴提提建议。&lt;/p&gt;
&lt;p&gt;由于, 我们公司的 CDN 系统是使用 Redis 的主从同步机制来进行配置元数据的同步和分发到全国各个 CDN 节点的, 我们对 Redis 的各种特性比较熟。所以, 这里, 我们最先考虑的也是 Redis 的方案。&lt;/p&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;分布式存储也是一个很宽泛的概念, 可以选择的技术很多。首先, 要分析好我们的应用场景是怎样的, 哪些是我们 care 的, 哪些是我们不太 care 的。&lt;/p&gt;
&lt;p&gt;推流源站会对流的元数据信息进行写操作, 而拉流源站会进行流的元数据的读操作。而直播是个典型的一对多提供服务的场景, 所以, 相应的, 我们的共享存储方案也是写少读多。同时, 我们可以允许少量的数据丢失, 我们更看重的是服务无SPOF, 稳定性与读写性能。&lt;/p&gt;
&lt;h2 id=&#34;方案一-redis-cluster&#34;&gt;方案一: Redis Cluster&lt;/h2&gt;
&lt;p&gt;Redis 3.0 之后推出了自己的 Redis Cluster 集群方案, 所以, 在最开始, 我们还是优先去尝试官方的集群方案。但是, 我们发现 Redis Cluster 仍然不能实现跨机房容灾, 跨机房高可用的功能还是需要自己来实现。所以, 我们源站集群共享存储的最初版本是每台源站的读写都是去操作部署在一个 BGP 机房的 Redis Cluster。但这个方案会导致读写性能都不理想, 所以, 后面我们考虑了在程序中引入缓存, 来减少读压力。&lt;/p&gt;
&lt;h2 id=&#34;方案二-redis-cluster--ttl-memorycache&#34;&gt;方案二: Redis Cluster + TTL MemoryCache&lt;/h2&gt;
&lt;p&gt;为了优化读性能, 我们首先考虑在程序中加入缓存, 结合我们的业务场景, 我们开发引入了基于 
&lt;a href=&#34;https://github.com/golang/groupcache&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;groupcache&lt;/a&gt;
 的超时缓存方案。我们比较专注最新的数据, 过期的数据没有意义, 反而会影响我们的业务逻辑, 所以, 元数据的每个 key 都可以配置一个 TTL 过期时间, 当时间到达时, 这个 key 就会 expire 掉。在一个 key expire 的同时有大量访问这个 key 的请求这个临界点时, 
&lt;a href=&#34;https://github.com/golang/groupcache&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;groupcache&lt;/a&gt;
 的内部有锁机制保障, 不会出现大量的回源请求, 给中心存储造成压力, 这个方案在我们的测试环境中, 测试结果跟我们预期基本一致。&lt;/p&gt;
&lt;h2 id=&#34;方案三-redis-masterslave-读写分离&#34;&gt;方案三: Redis Master/Slave 读写分离&lt;/h2&gt;
&lt;p&gt;而其实我们上面的方案并没有上线, 就有人提出了 Redis 读写分离的方案。写到一个中心 Redis Master 节点, 然后每台源站只去读本机的 Redis Slave 节点, 通过 Redis 的主从同步机制来确保数据一致性。最开始没有用这套方案是因为 Redis 的主从同步机制与 Redis Cluster/Sentinel 有冲突, 不能共存。后来, 运维提供了通过 keepalived 来保证 redis 的高可用, 所以, 我们线上采用了这套方案, 通过运行实际效果来看, 比较理想。&lt;/p&gt;
&lt;h2 id=&#34;方案四-etcd&#34;&gt;方案四: etcd&lt;/h2&gt;
&lt;p&gt;我们也在调研一些其他的分布式 kv 存储的方案, 下面是 etcd 的 benchmark 结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/etcd_test.png&#34; alt=&#34;etcd_test&#34;&gt;&lt;/p&gt;
&lt;p&gt;etcd 并发量10, 100, 1000 分别测试 PUT, GET, DELETE 连续三个操作。结果平均响应时间也跟着上去了。这个结果我们是无法接受的, 所以, 这个方案没有再继续深入研究了。&lt;/p&gt;
&lt;h2 id=&#34;方案五-mqkv&#34;&gt;方案五: mqkv&lt;/h2&gt;
&lt;p&gt;在对现有的一些分布式存储以及集群方案测试结果非常失望后, 我们开始考虑自研适用于我们这种业务场景的分布式存储方案。&lt;/p&gt;
&lt;p&gt;我们预期要达到的效果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每台源站读写操作都在本地, 要有较好的读写性能。写操作可以异步化, 尽快返回。&lt;/li&gt;
&lt;li&gt;无中心节点, 无 SPOF。(写在一个中心的方案, 写的这个主 Redis 还是一个单节点, 一旦机房断网或者断电, 那么, 整个直播服务就不可用了)&lt;/li&gt;
&lt;li&gt;允许出现少量的写数据失败的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上几点我设计了 mqkv:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持跨机房部署, 避免的单点问题。&lt;/li&gt;
&lt;li&gt;读写操作都在同一个源站的本机, 读写性能均达到最佳。&lt;/li&gt;
&lt;li&gt;mqkv 提供给应用的接口使用的协议是 Redis 协议, 兼容大量的 redis client driver。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mqkv-架构图&#34;&gt;mqkv 架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/mqkv_arch.png&#34; alt=&#34;mqkv_arch&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;实现过程&#34;&gt;实现过程&lt;/h2&gt;
&lt;p&gt;首先, 我实现了一个 Go 语言版的 redis server 的 api 框架 
&lt;a href=&#34;https://github.com/Akagi201/redface&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RedFace&lt;/a&gt;
。设计主要参考了 &lt;code&gt;net/http&lt;/code&gt; 的接口, 由于, 目前的业务逻辑还比较简单, 所以, 太复杂的代码并不多。&lt;/p&gt;
&lt;p&gt;比较巧的是, 在我实现了这个包的那个周末, 我看到了 hacker news 上有个跟我的项目功能非常类似的一个项目上了头条, 叫 
&lt;a href=&#34;https://github.com/tidwall/redcon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;redcon&lt;/a&gt;
。不过从接口可以明显的看出, 我实现的版本接口更加简洁, 友好。具体地, 可以对比下 redcon 的 
&lt;a href=&#34;https://github.com/tidwall/redcon/blob/master/example/clone.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example&lt;/a&gt;
 和 redface 的 
&lt;a href=&#34;https://github.com/Akagi201/redface/blob/master/example/clone/main.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;不过, redcon 的 benchmark 性能确实比我实现的要好, 这里, 我暂时还没有找到具体的原因, 哈哈, 欢迎高手帮忙分析下。&lt;/p&gt;
&lt;p&gt;接下来, 就是 mqkv 的实现了, 其实在架构与逻辑确定好了, 轮子也造好了之后, 写代码就变成很简单的事情了。简单的说, 我就是将应用的 write 操作都异步化, 通过分布式消息队列将消息发送出去, read 操作直接 proxy 本地的 kv 存储。其中利用了 nsq 的 PUB/SUB 模型, 所有 write 操作都 produce 到 &lt;code&gt;mqkv_topic&lt;/code&gt; 这个 topic 下, 同时, 每个 mqkv 也作为消费者注册消费 topic 为 &lt;code&gt;mqkv_topic&lt;/code&gt;, channel 为本机 hostname 的消息。这样, 就实现一写多读的消息分发模型了。每个 mqkv 在本地的 redis 进行全量的 kv 存储, 这里的 Redis 连接, 我也是用了 
&lt;a href=&#34;https://godoc.org/github.com/upyun/utilgo/radixutil&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redis 中间件&lt;/a&gt;
 来兼容 normal redis/redis sentinel/redis cluster 各种集群与高可用 redis 方案。&lt;/p&gt;
&lt;p&gt;这样, mqkv 就完成了, 是不是很简单。&lt;/p&gt;
&lt;h2 id=&#34;benchmark&#34;&gt;benchmark&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当 mqkv 启动后, 其实, 对于应用来说, 他本身就化身成为了一个 normal redis, 所以, 可用 &lt;code&gt;redis-benchmark&lt;/code&gt; 进行压测。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;❯ redis-benchmark -p 6389 -t set,get -n 1000000 -q -P 512 -c 512

SET: 28659.04 requests per second

GET: 23171.21 requests per second

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上是在我的 macbook pro 上性能测试结果。&lt;/p&gt;
&lt;h2 id=&#34;监控&#34;&gt;监控&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持 pprof 性能监控: &lt;code&gt;GET /debug/pprof/profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持 stats channel 信息 api: &lt;code&gt;GET /api/v1/consumer_stats&lt;/code&gt; 可以参看当前 mqkv 自己所连 channel 的消息消费情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他的一些还需解决的问题&#34;&gt;其他的一些还需解决的问题&lt;/h2&gt;
&lt;p&gt;当然 mqkv 还存在很多不完美的地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nsq 部署依赖 dns, 需要将 机器的 hostname 与 ip 关系写到 &lt;code&gt;/etc/hosts&lt;/code&gt; 里面。不知道有没有更简单的方法。&lt;/li&gt;
&lt;li&gt;机器扩容, 源站宕机一段时间后恢复, 元数据如果恢复, 如何保证数据一致性。&lt;/li&gt;
&lt;li&gt;也在考虑开发一个 kafka 版本进行对照, 看是否能保证更好的数据一致性。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>设计优先的 Restful API 服务开发与服务解耦实践</title>
      <link>/zh/post/design-first-restapi-and-service-decoupling-in-action/</link>
      <pubDate>Tue, 20 Sep 2016 16:35:00 +0800</pubDate>
      <guid>/zh/post/design-first-restapi-and-service-decoupling-in-action/</guid>
      <description>&lt;p&gt;最近公司需要一个 API 服务提供给用户用来查询直播系统的一些流相关数据接口。正好我们公司应用组的同事 
&lt;a href=&#34;https://github.com/CatTail&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CatTail&lt;/a&gt;
 分享了他们在这个季度将他们的 API 服务进行了重构, 使用了 swagger 这套 OpenAPI 标准工具。正好借此机会, 学来用用。&lt;/p&gt;
&lt;h2 id=&#34;swagger-框架的选择&#34;&gt;Swagger 框架的选择&lt;/h2&gt;
&lt;p&gt;应用组这边用的是 Node.js 开发的 API 服务, 我这边涉及到数据的上报与高并发处理, 使用 Go 开发。所以, 需要选择一个 Go 语言版的 Swagger API 框架&lt;/p&gt;
&lt;p&gt;经过简单的调研比较后, 我选择了 
&lt;a href=&#34;https://github.com/go-swagger/go-swagger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-swagger&lt;/a&gt;
 这个框架。这个开源项目是由 VMware 赞助并维护的, 支持最新的 Swagger 2.0 标准。
&lt;a href=&#34;https://goswagger.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;项目的文档&lt;/a&gt;
还不算太详细, 有的地方需要自己来摸索下。&lt;/p&gt;
&lt;p&gt;我选择这个框架基于如下几点考虑:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持标准的 http middleware, 方便集成 
&lt;a href=&#34;https://github.com/justinas/alice&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Alice&lt;/a&gt;
 插件管理工具, 可以直接使用大量与 &lt;code&gt;net/http&lt;/code&gt; 兼容的各种 http middleware。&lt;/li&gt;
&lt;li&gt;代码侵入性不大, 如果后期想改用其他框架, 迁移起来也不太麻烦。&lt;/li&gt;
&lt;li&gt;自带 validator 功能, API spec 设计好后, 无需在代码中自己去写繁琐的边界校验功能。&lt;/li&gt;
&lt;li&gt;可以通过代码生成 API 文档, 这样能 100% 的保证代码与文档保持一致。&lt;/li&gt;
&lt;li&gt;由于使用 Swagger 的标准, 方便使用兼容这一标准的一整套工具链, 保证 API 监控, spec render 等, 也能复用应用组那边的资源, 哈哈。&lt;/li&gt;
&lt;li&gt;项目也在发展中, 目前支持的 scheme 有 http 和 https, 后续会支持 ws 和 wss。我将来计划开发的 WebRTC 信令服务也可以考虑用这个框架来做。&lt;/li&gt;
&lt;li&gt;go-swagger 提供很多基础的 helper function 库实现: &lt;a href=&#34;https://github.com/go-openapi&#34;&gt;https://github.com/go-openapi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个框架不太好的地方, 或者对于 Go 这种强类型语言不太好的地方, 就是 Swagger 基于 spec 定义的 definitions 生成的 model 与 数据库的 model 不能使用一套 struct, 因为涉及到一些 struct tag 的添加没法添加, 区分开后, 就涉及到两种结构之间的数据拷贝的问题, 代码显得有点冗长。暂时我还没想到更好的办法。&lt;/p&gt;
&lt;h2 id=&#34;直播-api-服务架构设计&#34;&gt;直播 API 服务架构设计&lt;/h2&gt;
&lt;p&gt;首先是整理需求, 和抽象需求的模型, 我这边收到几个类似的业务需求有 禁播/踢流 服务, 触发/定时截图, 触发/定时录制, 流事件回调与查询。都涉及到配置变更和推流与断流事件触发相应的业务逻辑。所以, 我抽象出了如下服务架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/origin_admin.png&#34; alt=&#34;origin_admin&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个架构同时解决了两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与应用解耦, 在过去应用配置数据是通过 redis 数据结构与底层服务进行对接的, 当数据结构变更与扩展时, 都会发生各种各样繁琐的数据兼容与繁琐的流程。现在底层服务直接提供 Restful API 风格的 CRUD 操作, 底层服务自身来进行数据的持久化, 当需要存储结构调优和变更时, 就可以自己内部来调整, 而不用去动对外的接口。这在互联网环境, 需求与架构不断变化, 快速迭代开发的情况相匹配。&lt;/li&gt;
&lt;li&gt;由于 CRUD 接口都在我的服务内部, 配置变更触发事件, 这个逻辑变得更加容易实现和控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;统一的异步消息处理机制与事件回调机制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置变更 与 流事件触发, 可以用类似的异步逻辑来处理, 这里目前是通过 NSQ 消息队列, 来异步处理消费这些事件。&lt;/li&gt;
&lt;li&gt;推流断流事件与配置变更事件可以联动触发其他服务的业务逻辑。这里我设计了统一的事件回调机制, 可以回调到录制服务, 截图服务, 踢流服务甚至客户自己的服务等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;说说技术选型&#34;&gt;说说技术选型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;swagger: OpenAPI 标准, 可以利用 swagger 一整套工具, 方便后续做 API 统计与监控。&lt;/li&gt;
&lt;li&gt;mq: NSQ, 简单, 够用, 稳定。&lt;/li&gt;
&lt;li&gt;db: mongodb, 文档存储, 支持大数据, 支持单个 field 的 CRUD 操作, 方便 scale, 够用的读写性能, 够用的查询功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通过-swagger-spec-来设计-api&#34;&gt;通过 Swagger spec 来设计 API&lt;/h2&gt;
&lt;p&gt;这里截取一小部分来说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;swagger: &amp;quot;2.0&amp;quot;
info:
  contact:
    email: akagi201@gmail.com
    name: Akagi201
    url: http://akagi201.org
  description: UPYUN live streaming API service based on go-swagger
  title: UPYUN live streaming API service
  version: 0.1.0
# during dev, should point to your local machine
host: localhost:2201
# basePath will be prefixed to all paths
basePath: /api/v1
produces:
  - application/json
consumes:
  - application/json
schemes:
  - http
  - https
tags:
  - name: system
    description: 系统信息
  - name: stream
    description: 流信息
  - name: event
    description: 对内 事件 接口
  - name: config
    description: 对内 应用配置 接口
paths:
  /system/version:
    get:
      tags:
        - system
      summary: 获取版本信息
      operationId: getVersion
      responses:
        200:
          description: get versions
          schema:
            $ref: &amp;quot;#/definitions/version&amp;quot;
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error_response&amp;quot;
definitions:
  version:
    type: object
    title: version_info
    required:
      - version
      - signature
    properties:
      version:
        type: string
        minLength: 1
      signature:
        type: string
        minLength: 1
  error_response:
    type: object
    title: error_response
    required:
      - code
      - data
    properties:
      code:
        type: integer
        format: int32
        description: 所有错误码统一定义
        example: 201
      data:
        type: string
        minLength: 1
        description: 详细错误信息
        example: Operator already exists
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;限制条件与文档说明, 例子都可以写到 spec 里面。完整的 spec 文档, 请参考 &lt;a href=&#34;http://swagger.io/specification/&#34;&gt;http://swagger.io/specification/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以使用开源的 
&lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;swagger-ui&lt;/a&gt;
 来 render 这份文档, 当然如果你觉得他太丑了, 可以自己写个 render。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/uplive_api.png&#34; alt=&#34;uplive_api&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用-go-swagger-框架&#34;&gt;使用 go-swagger 框架&lt;/h2&gt;
&lt;p&gt;目录结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ tree -L 3
.
├── README.md
├── client // client SDK
│   ├── config
│   │   ├── config_client.go
│   │   ├── del_stream_config_parameters.go
│   │   ├── del_stream_config_responses.go
│   │   ├── get_stream_config_parameters.go
│   │   ├── get_stream_config_responses.go
│   │   ├── set_stream_config_parameters.go
│   │   └── set_stream_config_responses.go
│   ├── event
│   │   ├── event_client.go
│   │   ├── get_stream_events_parameters.go
│   │   ├── get_stream_events_responses.go
│   │   ├── stream_event_collector_parameters.go
│   │   └── stream_event_collector_responses.go
│   ├── origin_admin_client.go
│   ├── stream
│   │   ├── get_stream_status_parameters.go
│   │   ├── get_stream_status_responses.go
│   │   └── stream_client.go
│   └── system
│       ├── get_version_parameters.go
│       ├── get_version_responses.go
│       └── system_client.go
├── cmd // 最终生成的二进制
│   └── origin-admin-server
│       └── main.go
├── models // 根据 spec definition 生成的 model
│   ├── error_response.go
│   ├── result_response.go
│   ├── stream_action.go
│   ├── stream_event.go
│   ├── stream_events.go
│   ├── stream_info.go
│   ├── stream_status.go
│   └── version.go
├── restapi // api 处理逻辑
│   ├── configure_origin_admin.go // 自定义 API 逻辑入口文件
│   ├── controller.go // 我添加的针对每个 API 的具体处理 Handler 逻辑实现, 后期可以拆分成目录和多个文件的结构
│   ├── doc.go
│   ├── embedded_spec.go
│   ├── operations
│   │   ├── config
│   │   ├── event
│   │   ├── origin_admin_api.go
│   │   ├── stream
│   │   └── system
│   └── server.go
├── store // 与 mgo 交互的 model 定义
│   └── mongo
│       ├── event.go
│       └── stream_config.go
└── swagger.yml // spec 定义的地方
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结与体会&#34;&gt;总结与体会&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于新人来说, 会有一定的学习成本, 包括开发理念的传递。不过 design first 这个理念是非常好的。&lt;/li&gt;
&lt;li&gt;整体来说使用这套框架还是比较顺利, 没有遇到什么无法解决的问题, 也希望 
&lt;a href=&#34;https://github.com/go-swagger/go-swagger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-swagger&lt;/a&gt;
 能够不断完善起来, 另外, 大家用的多了, 自然功能也就完善了, 所以, 在此, 还是向大家隆重推荐一下。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Reading WebRTCBook</title>
      <link>/zh/post/reading-webrtcbook/</link>
      <pubDate>Mon, 13 Jun 2016 20:51:19 +0800</pubDate>
      <guid>/zh/post/reading-webrtcbook/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/webrtcbook_cover.jpg&#34; alt=&#34;webrtcbook-cover&#34;&gt;&lt;/p&gt;
&lt;p&gt;5 月 29 号在美国亚马逊上买了 &amp;lt;WebRTC权威指南&amp;gt; 这本书. 邮件上预计是 7 月 5 日到. 结果今天( 6 月 13 日)就到了, 真是开心. BTW, 这算是我买过的最贵的书了. 
&lt;a href=&#34;https://www.amazon.com/WebRTC-RTCWEB-Protocols-Real-Time-Chinese/dp/1518889255?ie=UTF8&amp;amp;keywords=webrtc%20chinese&amp;amp;qid=1448412556&amp;amp;ref_=sr_1_1&amp;amp;sr=8-1&amp;amp;tag=dailydeal0c6-20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;购买地址&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/webrtcbook-order.png&#34; alt=&#34;webrtcbook-order&#34;&gt;&lt;/p&gt;
&lt;p&gt;书里面的图片都是彩印的. 不算太厚, 才 295 页.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reading ng-book 2</title>
      <link>/zh/post/reading-ng-book2/</link>
      <pubDate>Wed, 17 Feb 2016 19:09:19 +0800</pubDate>
      <guid>/zh/post/reading-ng-book2/</guid>
      <description>&lt;p&gt;哈哈, 最近在同时学两个东西, 都是 &lt;code&gt;ngxxx&lt;/code&gt; 一个是 &lt;code&gt;nginx&lt;/code&gt;, 另一个就是 &lt;code&gt;angular&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;同样地, 这是一篇无聊的文章, 只是给我个人用来记录进度的.(不记录, 坚持不下来啊)&lt;/p&gt;
&lt;h2 id=&#34;学习动机&#34;&gt;学习动机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目前工作一个项目用的 angular 1.x&lt;/li&gt;
&lt;li&gt;data 驱动 view&lt;/li&gt;
&lt;li&gt;前端太 tmd 的乱, 框架一大堆, 看别人分析, 都希望出现一个统一的框架. 我希望是 angular.&lt;/li&gt;
&lt;li&gt;想摆脱手写html, 手写js, 手写 css 的低端模式, 学个框架, 以后可以装逼说自己会前端了.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文档地址&#34;&gt;文档地址&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ng-book.com/2/&#34;&gt;https://www.ng-book.com/2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载的pdf: &lt;code&gt;ng-book2-r32.pdf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进度&#34;&gt;进度&lt;/h2&gt;
&lt;h3 id=&#34;2016-02-17&#34;&gt;2016-02-17&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当前的 angular 2 状态是 beta.&lt;/li&gt;
&lt;li&gt;angular: &lt;a href=&#34;https://angular.io/&#34;&gt;https://angular.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;typescript: &lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;http://www.typescriptlang.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简单的看了下网上各路人马的评价, 在typescript跟es6中选择了typescript.&lt;/li&gt;
&lt;li&gt;TypeScript is a superset of JavaScript ES6 that adds types.&lt;/li&gt;
&lt;li&gt;ES5 == normal JavaScript&lt;/li&gt;
&lt;li&gt;ES6 == ES2015&lt;/li&gt;
&lt;li&gt;Angular 2 is written in TypeScript and generally that’s what everyone is using.&lt;/li&gt;
&lt;li&gt;Angular 2 itself is a javascript file.&lt;/li&gt;
&lt;li&gt;Shim. A shim is a library that brings a new API to an older environment, using only the means of that environment.&lt;/li&gt;
&lt;li&gt;Polyfill. A polyfill is a piece of code (or plugin) that provides the technology that you, the developer, expect the browser to provide natively. Flattening the API landscape if you will.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-05-18&#34;&gt;2016-05-18&lt;/h3&gt;
&lt;h4 id=&#34;angular-2-项目基础&#34;&gt;Angular 2 项目基础&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;package.json&lt;/li&gt;
&lt;li&gt;tsconfig.json&lt;/li&gt;
&lt;li&gt;tslint.json&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;angular-2-依赖&#34;&gt;Angular 2 依赖&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ES6 Shim&lt;/li&gt;
&lt;li&gt;Zones&lt;/li&gt;
&lt;li&gt;Reflect Metadata&lt;/li&gt;
&lt;li&gt;SystemJS&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;notes&#34;&gt;notes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CSS 使用 Semantic-UI.&lt;/li&gt;
&lt;li&gt;reference(in .d.ts) 语句指定 typing 文件的路径.&lt;/li&gt;
&lt;li&gt;import 语句是来自 ES6, 叫做 destructuring.&lt;/li&gt;
&lt;li&gt;Component 是 Angular 1里的 directives 的新版本.&lt;/li&gt;
&lt;li&gt;一个基础的 Component 包含两个部分: Component annotation 和 component definition class.&lt;/li&gt;
&lt;li&gt;把 annotation 看做 metadata added to your code. (? 跟 python 的 docorator 类似吧)&lt;/li&gt;
&lt;li&gt;selector: angular自己的selector mix, 类似 CSS selector, XPath, JQuery selector.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm run tsc&lt;/code&gt; 编译.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm run tsc:w&lt;/code&gt; 编译并监听.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tsc --watch&lt;/code&gt; 每次修改都编译.&lt;/li&gt;
&lt;li&gt;读到 Page 16&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-05-19&#34;&gt;2016-05-19&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm run go&lt;/code&gt; 监听修改并serve, 注意 8080 端口不能被占用.&lt;/li&gt;
&lt;li&gt;array: Angular1 的 &lt;code&gt;ng-repeat&lt;/code&gt; 在 Angular2 中类似的指令是 &lt;code&gt;NgFor&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#newtitle&lt;/code&gt; 语法叫做一个 &lt;code&gt;resolve&lt;/code&gt;. 效果是让这个变量在这个 view 范围的的表达式有效.&lt;/li&gt;
&lt;li&gt;绑定 input 到 value, newtitle 是一个 object, 代表这个 input DOM 元素, 类型是 HTMLInputElement. 可以访问 &lt;code&gt;newtitle.value&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;绑定 actions 到 events, 组件类的一个函数赋值给 (click) 属性.&lt;/li&gt;
&lt;li&gt;反引号: ES6 语法, 反引号的字符串将会展开模板变量.&lt;/li&gt;
&lt;li&gt;可以在 attribute values 里面使用模板.&lt;/li&gt;
&lt;li&gt;在 Angular 1, directives 全局 match, 在 Angular 2, 你需要显式指定你用哪个组件(因此, 哪个 selector).&lt;/li&gt;
&lt;li&gt;在 js 里, 默认传播 click 事件给所有的父组件.&lt;/li&gt;
&lt;li&gt;一个好的实践是当写 Angular 代码时, 尽量将你使用的数据结构与组件代码隔离.&lt;/li&gt;
&lt;li&gt;封装的原则: LoD, &lt;a href=&#34;https://en.wikipedia.org/wiki/Law_of_Demeter&#34;&gt;https://en.wikipedia.org/wiki/Law_of_Demeter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;train-wreck: 小心 long-method chaining &lt;code&gt;foo.bar.baz.bam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;读到 Page 42&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-05-20&#34;&gt;2016-05-20&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MVC guideline: 
&lt;a href=&#34;http://weblog.jamisbuck.org/2006/10/18/skinny-controller-fat-model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Skinny Controller, Fat Model&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;核心理念是: 将大多数我们的 domain logic 移动到我们的 models, 因此我们的 components 尽可能做最少的工作.&lt;/li&gt;
&lt;li&gt;数组的两种表示: 1. 普通: Article[]; 2. generics: Array&lt;Article&gt;.&lt;/li&gt;
&lt;li&gt;Component 的 attribute: inputs&lt;/li&gt;
&lt;li&gt;创建 coimponent 的核心不仅仅是封装, 而且是为了重用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;总结编写-angular-2-应用步骤&#34;&gt;总结编写 Angular 2 应用步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;将你的应用分解成 components.&lt;/li&gt;
&lt;li&gt;创建 view.&lt;/li&gt;
&lt;li&gt;定义你的 model.&lt;/li&gt;
&lt;li&gt;显示你的 model.&lt;/li&gt;
&lt;li&gt;添加互动.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;typescript&#34;&gt;typescript&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ES6 = ES5 + classes + modules&lt;/li&gt;
&lt;li&gt;TypeScript = ES6 + types + annotations&lt;/li&gt;
&lt;li&gt;transpiler / transcompiler : TypeScript -&amp;gt; ES5.&lt;/li&gt;
&lt;li&gt;TypeScript to ES5 有一个单一的 transpiler, 由核心 TypeScript team 开发.&lt;/li&gt;
&lt;li&gt;ES6 to ES5 有两个 transpiler: [traceur](&lt;a href=&#34;https://github.com/google/traceur-&#34;&gt;https://github.com/google/traceur-&lt;/a&gt; compiler) (by google), 
&lt;a href=&#34;https://babeljs.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;babel&lt;/a&gt;
 (by js community).&lt;/li&gt;
&lt;li&gt;REPL: ts-node, tsun&lt;/li&gt;
&lt;li&gt;number: 在TS中, 所有的number都是浮点数.&lt;/li&gt;
&lt;li&gt;any: any 是默认类型, 如果我们忽略给一个变量指定类型,&lt;/li&gt;
&lt;li&gt;classes: 在 ES5 中, OO是通过 prototype-based objects 实现的.&lt;/li&gt;
&lt;li&gt;最佳实践, 关于补充js中没有class: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;oo in js: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;class 有 properties, methods, constructors.&lt;/li&gt;
&lt;li&gt;A void value is also a valid any value.&lt;/li&gt;
&lt;li&gt;constructor: 必须被命名为: constructor. 每个 class 只能有一个 constructor.&lt;/li&gt;
&lt;li&gt;inheritance in ES5: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;inheritance: 使用 extends 关键字.&lt;/li&gt;
&lt;li&gt;Utilities(语法糖): ES6 提供一些语法糖: 1. fat arrow function syntax; 2. template strings;&lt;/li&gt;
&lt;li&gt;Fat Arrow Function (=&amp;gt;): 是一个缩写来写函数.&lt;/li&gt;
&lt;li&gt;在 ES5 中, 如果我们想要使用一个函数作为参数, 我们需要使用 function 关键字和 {}.&lt;/li&gt;
&lt;li&gt;=&amp;gt; 语法的一个重要特性是, 他和包围他的代码使用相同的 this. 这与你在 JS 中创建一个普通函数不同.&lt;/li&gt;
&lt;li&gt;通常当你在 JS 中写一个函数时, 这个函数被分配他自己的 this.&lt;/li&gt;
&lt;li&gt;=&amp;gt; 函数是一个很好的方法来清理你的 inline 函数. 他使在JS中使用高阶函数更简单.&lt;/li&gt;
&lt;li&gt;Template Strings: 在 ES6 中, 新的 template strings 被引入. 两个好的特性: 1. Varaibles within strings. 2. Multi-line strings.&lt;/li&gt;
&lt;li&gt;Variables in strings: 也叫 string interpolation. 要使用反引号, 不能使用单引号或者双引号.&lt;/li&gt;
&lt;li&gt;Angualr 2应用由 Component 组成(a tree of components), 一种理解 Component 的方式是教会浏览器新 tag.&lt;/li&gt;
&lt;li&gt;Angular 2 的 Component 和 Angular 1 的 directive 类似. 同时, Angular 2 也有 directive.&lt;/li&gt;
&lt;li&gt;component 是 composable.&lt;/li&gt;
&lt;li&gt;Angular 2 没有指定一个 model library.&lt;/li&gt;
&lt;li&gt;读到 Page 76.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;typescript-比-es5-多的特性&#34;&gt;TypeScript 比 ES5 多的特性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;types&lt;/li&gt;
&lt;li&gt;classes&lt;/li&gt;
&lt;li&gt;annotations&lt;/li&gt;
&lt;li&gt;imports&lt;/li&gt;
&lt;li&gt;language utilities (e.g. desctructuring)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-05-26&#34;&gt;2016-05-26&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;componet decorator: 包含一个 selector, 一个 template.&lt;/li&gt;
&lt;li&gt;component controller: 由一个 class 定义.&lt;/li&gt;
&lt;li&gt;component selector: 两种写法.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;inventory-app&amp;gt;&amp;lt;/inventory-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div inventory-app&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;添加实例到组件里来显示子组件.&lt;/li&gt;
&lt;li&gt;template binding: &lt;code&gt;{{...}}&lt;/code&gt;, 里面不仅仅是一个变量, 是一个表达式.&lt;/li&gt;
&lt;li&gt;Inputs 和 Outputs: &lt;code&gt;[squareBrackets]&lt;/code&gt; 传入 inputs, &lt;code&gt;(parenthesis)&lt;/code&gt; 处理 outputs.&lt;/li&gt;
&lt;li&gt;数据流入你的组件, 通过 input binding, 事件流出你的组件, 通过 output binding.&lt;/li&gt;
&lt;li&gt;可以把 input + output bindings 看做你的组件的 public API.&lt;/li&gt;
&lt;li&gt;component inputs:&lt;/li&gt;
&lt;li&gt;Observer pattern: &lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;https://en.wikipedia.org/wiki/Observer_pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Reading Nginx tutorial</title>
      <link>/zh/post/reading-nginx-tutorial/</link>
      <pubDate>Tue, 16 Feb 2016 08:26:44 +0800</pubDate>
      <guid>/zh/post/reading-nginx-tutorial/</guid>
      <description>&lt;p&gt;这是一篇无聊的文章, 用于记录自己的阅读进度而已.&lt;/p&gt;
&lt;h2 id=&#34;文档地址&#34;&gt;文档地址&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html&#34;&gt;https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进度&#34;&gt;进度&lt;/h2&gt;
&lt;h3 id=&#34;2016-02-16&#34;&gt;2016-02-16&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指令 = 语句, 每行语句后有一个分号.&lt;/li&gt;
&lt;li&gt;只有一种变量类型, 字符串.&lt;/li&gt;
&lt;li&gt;ngx_http_rewrite_module: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;nginx第三方模块: &lt;a href=&#34;https://www.nginx.com/resources/wiki/modules/&#34;&gt;https://www.nginx.com/resources/wiki/modules/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;HTTP Echo Module: &lt;a href=&#34;https://www.nginx.com/resources/wiki/modules/echo/&#34;&gt;https://www.nginx.com/resources/wiki/modules/echo/&lt;/a&gt; &lt;a href=&#34;https://github.com/openresty/echo-nginx-module&#34;&gt;https://github.com/openresty/echo-nginx-module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;疑问: 为什么叫第三方模块, 不过还是包含在nginx的官方发现版里了? 第三方模块融入nginx upstream的流程?&lt;/li&gt;
&lt;li&gt;变量插值: variable interpolation (从Perl语法引入)&lt;/li&gt;
&lt;li&gt;变量名前一律加$&lt;/li&gt;
&lt;li&gt;Nginx的语法是可扩展的? 通过添加一个第三方模块, 就可以增加指令, 增加语法?&lt;/li&gt;
&lt;li&gt;ngx_http_geo_module: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_geo_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_geo_module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx 变量的创建和赋值操作发生在全然不同的时间阶段。Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候；而赋值操作则只会发生在请求实际处理的时候。这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。&lt;/li&gt;
&lt;li&gt;读完 Nginx 变量漫谈（一）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-02-17&#34;&gt;2016-02-17&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;echo_exec 内部跳转: &lt;a href=&#34;https://github.com/openresty/echo-nginx-module#echo_exec&#34;&gt;https://github.com/openresty/echo-nginx-module#echo_exec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx 变量值容器的生命期是与当前正在处理的请求绑定的，而与 location 无关。&lt;/li&gt;
&lt;li&gt;ngx_http_rewrite_module: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ngx_http_core_module: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_core_module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Set Misc: &lt;a href=&#34;https://github.com/openresty/set-misc-nginx-module#set_unescape_uri&#34;&gt;https://github.com/openresty/set-misc-nginx-module#set_unescape_uri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;读完 Nginx 变量漫谈（二）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-02-19&#34;&gt;2016-02-19&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_proxy_module: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不是所有的 Nginx 变量都拥有存放值的容器。拥有值容器的变量在 Nginx 核心中被称为“被索引的”（indexed）；反之，则被称为“未索引的”（non-indexed）。&lt;/li&gt;
&lt;li&gt;读完 Nginx 变量漫谈（三）&lt;/li&gt;
&lt;li&gt;读完 Nginx 变量漫谈 (四)&lt;/li&gt;
&lt;li&gt;Nginx 变量值容器的生命期是与当前请求相关联的。每个请求都有所有变量值容器的独立副本，只不过当前请求既可以是“主请求”，也可以是“子请求”。即便是父子请求之间，同名变量一般也不会相互干扰。&lt;/li&gt;
&lt;li&gt;Module ngx_http_auth_request_module: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_auth_request_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_auth_request_module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx 变量漫谈（五）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2016-02-22&#34;&gt;2016-02-22&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何在 Go 语言中使用 Redis 连接池</title>
      <link>/zh/post/how-to-use-redis-pool-in-go/</link>
      <pubDate>Thu, 28 Jan 2016 20:00:00 +0800</pubDate>
      <guid>/zh/post/how-to-use-redis-pool-in-go/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/redis_go.png&#34; alt=&#34;redis_go&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于连接池&#34;&gt;关于连接池&lt;/h2&gt;
&lt;p&gt;一个数据库服务器只拥有有限的资源，并且如果你没有充分使用这些资源，你可以通过使用更多的连接来提高吞吐量。一旦所有的资源都在使用，那么你就不能通过增加更多的连接来提高吞吐量。事实上，吞吐量在连接负载较大时就开始下降了。通常可以通过限制与可用的资源相匹配的数据库连接的数量来提高延迟和吞吐量。&lt;/p&gt;
&lt;p&gt;如果不使用连接池，那么，每次传输数据，我们都需要进行创建连接，收发数据，关闭连接。在并发量不高的场景，基本上不会有什么问题，一旦并发量上去了，那么，一般就会遇到下面几个常见问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能普遍上不去&lt;/li&gt;
&lt;li&gt;CPU 大量资源被系统消耗&lt;/li&gt;
&lt;li&gt;网络一旦抖动，会有大量 &lt;code&gt;TIME_WAIT&lt;/code&gt; 产生，不得不定期重启服务或定期重启机器&lt;/li&gt;
&lt;li&gt;服务器工作不稳定，QPS 忽高忽低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想解决这些问题，我们就要用到连接池了。连接池的思路很简单，在初始化时，创建一定数量的连接，先把所有长连接存起来，然后，谁需要使用，从这里取走，干完活立马放回来。 如果请求数超出连接池容量，那么就排队等待、退化成短连接或者直接丢弃掉。&lt;/p&gt;
&lt;h2 id=&#34;使用连接池遇到的坑&#34;&gt;使用连接池遇到的坑&lt;/h2&gt;
&lt;p&gt;最近在一个项目中，需要实现一个简单的 Web Server 提供 Redis 的 HTTP interface，提供 JSON 形式的返回结果。考虑用 Go 来实现。&lt;/p&gt;
&lt;p&gt;首先，去看一下 Redis 官方推荐的 
&lt;a href=&#34;http://redis.io/clients#go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go Redis driver&lt;/a&gt;
。官方 Star 的项目有两个：Radix.v2 和 Redigo。经过简单的比较后，选择了更加轻量级和实现更加优雅的 
&lt;a href=&#34;https://github.com/mediocregopher/radix.v2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Radix.v2&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;Radix.v2 包是根据功能划分成一个个的 sub package，每一个 sub package 在一个独立的子目录中，结构非常清晰。我的项目中会用到的 sub package 有 redis 和 pool。&lt;/p&gt;
&lt;p&gt;由于我想让这种被 fork 的进程最好简单点，做的事情单一一些，所以，在没有深入去看 Radix.v2 的 pool 的实现之前，我选择了自己实现一个 Redis pool。(这里，就不贴代码了。后来发现自己实现的 Redis pool 与 Radix.v2 实现的 Redis pool 的原理是一样的，都是基于 channel 实现的, 遇到的问题也是一样的。)&lt;/p&gt;
&lt;p&gt;不过在测试过程中，发现了一个诡异的问题。在请求过程中经常会报 EOF 错误。而且是概率性出现，一会有问题，一会又好了。通过反复的测试，发现 bug 是有规律的，当程序空闲一会后，再进行连续请求，会发生3次失败，然后之后的请求都能成功，而我的连接池大小设置的是3。再进一步分析，程序空闲300秒后，再请求就会失败，发现我的 Redis server 配置了 &lt;code&gt;timeout 300&lt;/code&gt;，至此，问题就清楚了。是连接超时 Redis server 主动断开了连接。客户端这边从一个超时的连接请求就会得到 EOF 错误。&lt;/p&gt;
&lt;p&gt;然后我看了一下 Radix.v2 的 pool 包的源码，发现这个库本身并没有检测坏的连接，并替换为新的连接的机制。也就是说我每次从连接池里面 Get 的连接有可能是坏的连接。所以，我当时临时的解决方案是通过增加失败后自动重试来解决了。不过，这样的处理方案，连接池的作用好像就没有了。技术债能早点还的还是早点还上。&lt;/p&gt;
&lt;h2 id=&#34;使用连接池的正确姿势&#34;&gt;使用连接池的正确姿势&lt;/h2&gt;
&lt;p&gt;想到我们的 &lt;code&gt;ngx_lua&lt;/code&gt; 项目里面也大量使用 redis 连接池，他们怎么没有遇到这个问题呢。只能去看看源码了。&lt;/p&gt;
&lt;p&gt;经过抽象分离， &lt;code&gt;ngx_lua&lt;/code&gt; 里面使用 redis 连接池部分的代码大致是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    location /pool {
        content_by_lua_block {
            local redis = require &amp;quot;resty.redis&amp;quot;
            local red = redis:new()

            local ok, err = red:connect(&amp;quot;127.0.0.1&amp;quot;, 6379)
            if not ok then
                ngx.say(&amp;quot;failed to connect: &amp;quot;, err)
                return
            end

            ok, err = red:set(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
            if not ok then
                return
            end

            red:set_keepalive(10000, 100)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现有个 &lt;code&gt;set_keepalive&lt;/code&gt; 的方法，查了一下
&lt;a href=&#34;https://github.com/openresty/lua-resty-redis#set_keepalive&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;
，方法的原型是 &lt;code&gt;syntax: ok, err = red:set_keepalive(max_idle_timeout, pool_size)&lt;/code&gt; 貌似 &lt;code&gt;max_idle_timeout&lt;/code&gt; 这个参数，就是我们所缺少的东西，然后进一步跟踪源码，看看里面是怎么保证连接有效的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _M.set_keepalive(self, ...)
    local sock = self.sock
    if not sock then
        return nil, &amp;quot;not initialized&amp;quot;
    end

    if self.subscribed then
        return nil, &amp;quot;subscribed state&amp;quot;
    end

    return sock:setkeepalive(...)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，已经清楚了，使用了 tcp 的 keepalive 心跳机制。&lt;/p&gt;
&lt;p&gt;于是，通过与 Radix.v2 的作者一些
&lt;a href=&#34;https://github.com/mediocregopher/radix.v2/issues/21&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;讨论&lt;/a&gt;
，选择自己在 redis 这层使用心跳机制，来解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;最后的解决方案&#34;&gt;最后的解决方案&lt;/h2&gt;
&lt;p&gt;在创建连接池之后，起一个 goroutine，每隔一段 &lt;code&gt;idleTime&lt;/code&gt; 发送一个 &lt;code&gt;PING&lt;/code&gt; 到 Redis server。其中，&lt;code&gt;idleTime&lt;/code&gt; 略小于 Redis server 的 &lt;code&gt;timeout&lt;/code&gt; 配置。&lt;/p&gt;
&lt;p&gt;连接池初始化部分代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p, err := pool.New(&amp;quot;tcp&amp;quot;, u.Host, concurrency)
errHndlr(err)
go func() {
    for {
        p.Cmd(&amp;quot;PING&amp;quot;)
        time.Sleep(idelTime * time.Second)
    }
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 redis 传输数据部分代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func redisDo(p *pool.Pool, cmd string, args ...interface{}) (reply *redis.Resp, err error) {
	reply = p.Cmd(cmd, args...)
	if err = reply.Err; err != nil {
		if err != io.EOF {
			Fatal.Println(&amp;quot;redis&amp;quot;, cmd, args, &amp;quot;err is&amp;quot;, err)
		}
	}

	return
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，Radix.v2 连接池内部进行了连接池内连接的获取和放回，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Cmd automatically gets one client from the pool, executes the given command
// (returning its result), and puts the client back in the pool
func (p *Pool) Cmd(cmd string, args ...interface{}) *redis.Resp {
	c, err := p.Get()
	if err != nil {
		return redis.NewResp(err)
	}
	defer p.Put(c)

	return c.Cmd(cmd, args...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，我们就有了 keepalive 的机制，不会出现 timeout 的连接了，从 redis 连接池里面取出的连接都是可用的连接了。看似简单的代码，却完美的解决了连接池里面超时连接的问题。同时，就算 Redis server 重启等情况，也能保证连接自动重连。&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Connection_pool&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connection pool&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Database_connection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Database connection&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.jikexueyuan.com/project/openresty/web/conn_pool.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenResty 连接池&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning LuaDist</title>
      <link>/zh/post/learning-luadist/</link>
      <pubDate>Sat, 28 Nov 2015 22:35:03 +0800</pubDate>
      <guid>/zh/post/learning-luadist/</guid>
      <description>&lt;h2 id=&#34;官网&#34;&gt;官网&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://luadist.org/&#34;&gt;http://luadist.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wiki&#34;&gt;wiki&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/LuaDist/Repository/wiki&#34;&gt;https://github.com/LuaDist/Repository/wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何提交Package到PyPI</title>
      <link>/zh/post/how-to-submit-package-to-pypi/</link>
      <pubDate>Mon, 02 Nov 2015 09:59:54 +0800</pubDate>
      <guid>/zh/post/how-to-submit-package-to-pypi/</guid>
      <description>&lt;h2 id=&#34;pypi官方文档&#34;&gt;PyPI官方文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.python.org/pypi&#34;&gt;https://pypi.python.org/pypi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.python.org/moin/CheeseShopTutorial#Submitting_Packages_to_the_Package_Index&#34;&gt;https://wiki.python.org/moin/CheeseShopTutorial#Submitting_Packages_to_the_Package_Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;
&lt;h3 id=&#34;注册账号&#34;&gt;注册账号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PyPI Live &lt;a href=&#34;https://pypi.python.org/pypi?%3Aaction=register_form&#34;&gt;https://pypi.python.org/pypi?%3Aaction=register_form&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PyPI Test &lt;a href=&#34;https://testpypi.python.org/pypi?%3Aaction=register_form&#34;&gt;https://testpypi.python.org/pypi?%3Aaction=register_form&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;填写配置文件pypirc&#34;&gt;填写配置文件&lt;code&gt;~/.pypirc&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[distutils]
index-servers=
    pypi
    pypitest

[pypitest]
repository = https://testpypi.python.org/pypi
username = &amp;lt;your user name goes here&amp;gt;
password = &amp;lt;your password goes here&amp;gt;

[pypi]
repository = https://pypi.python.org/pypi
username = &amp;lt;your user name goes here&amp;gt;
password = &amp;lt;your password goes here&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;准备你的package&#34;&gt;准备你的package&lt;/h3&gt;
&lt;p&gt;PyPI上的每个package需要一个&lt;code&gt;setup.py&lt;/code&gt;文件在项目的根目录, 如果你在一个一个markdown格式的README文件, 你还需要一个&lt;code&gt;setup.cfg&lt;/code&gt;文件. 一个&lt;code&gt;LICENSE.txt&lt;/code&gt;文件. 假设包名为:&lt;code&gt;mypackage&lt;/code&gt;, 目录结构如下.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── LICENSE.txt
├── README.md
├── mypackage
│   ├── __init__.py
│   ├── bar.py
│   ├── baz.py
│   └── foo.py
├── setup.cfg
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;setuppy&#34;&gt;&lt;code&gt;setup.py&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;from distutils.core import setup

setup(
    name=&#39;mypackage&#39;,
    packages=[&#39;mypackage&#39;],  # this must be the same as the name above
    version=&#39;0.1&#39;,
    description=&#39;A random test lib&#39;,
    author=&#39;Akagi201&#39;,
    author_email=&#39;akagi201@gmail.com&#39;,
    url=&#39;https://github.com/Akagi201/mypackage&#39;,  # use the URL to the github repo
    download_url=&#39;https://github.com/Akagi201/mypackage/tarball/0.1&#39;,  # I&#39;ll explain this in a second
    keywords=[&#39;testing&#39;, &#39;logging&#39;, &#39;example&#39;],  # arbitrary keywords
    classifiers=[],
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;download_url&lt;/code&gt;: repo源码的下载链接, 使用&lt;code&gt;git tag&lt;/code&gt;后, github会为你host. 使用命令: &lt;code&gt;git tag 0.1 -m &amp;quot;Adds a tag so that we can put this on PyPI.&amp;quot;&lt;/code&gt;, 使用 &lt;code&gt;git push --tags origin master&lt;/code&gt; 提交到github&lt;/p&gt;
&lt;h4 id=&#34;setupcfg&#34;&gt;&lt;code&gt;setup.cfg&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;告诉PyPI你的README文件的位置.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[metadata]
description-file = README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提交package到pypi-test&#34;&gt;提交package到PyPI Test&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注册: &lt;code&gt;python setup.py register -r pypitest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上传: &lt;code&gt;python setup.py sdist upload -r pypitest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装: &lt;code&gt;pip install -i https://testpypi.python.org/pypi &amp;lt;package name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;提交package到pypi-live&#34;&gt;提交package到PyPI Live&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注册: &lt;code&gt;python setup.py register -r pypi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上传: &lt;code&gt;python setup.py sdist upload -r pypi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;web form提交: &lt;code&gt;https://pypi.python.org/pypi?:action=submit_form&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;不使用setuptools-使用更安全的twine上传&#34;&gt;不使用&lt;code&gt;setuptools&lt;/code&gt;, 使用更安全的&lt;code&gt;twine&lt;/code&gt;上传&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;twine upload dist/*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://peterdowns.com/posts/first-time-with-pypi.html&#34;&gt;http://peterdowns.com/posts/first-time-with-pypi.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packaging.python.org/en/latest/distributing/#uploading-your-project-to-pypi&#34;&gt;https://packaging.python.org/en/latest/distributing/#uploading-your-project-to-pypi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pythonhosted.org/an_example_pypi_project/&#34;&gt;http://pythonhosted.org/an_example_pypi_project/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.python.org/moin/TestPyPI&#34;&gt;https://wiki.python.org/moin/TestPyPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;较新: &lt;a href=&#34;https://packaging.python.org/en/latest/current/&#34;&gt;https://packaging.python.org/en/latest/current/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.python.org/pypi?%3Aaction=list_classifiers&#34;&gt;https://pypi.python.org/pypi?%3Aaction=list_classifiers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coderwall.com/p/qawuyq/use-markdown-readme-s-in-python-modules&#34;&gt;https://coderwall.com/p/qawuyq/use-markdown-readme-s-in-python-modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python-packaging-user-guide.readthedocs.org/en/latest/single_source_version/&#34;&gt;http://python-packaging-user-guide.readthedocs.org/en/latest/single_source_version/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>专业投机原理书评</title>
      <link>/zh/post/trader-vic/</link>
      <pubDate>Sat, 17 Oct 2015 16:47:36 +0800</pubDate>
      <guid>/zh/post/trader-vic/</guid>
      <description>&lt;p&gt;读这本书的文字就能体会到, 作者那种自信而坚定的行事风格, 很喜欢这种略带装逼的文风. 作者的经历我也很喜欢, 学历不高, 小时候就精通打牌(阅读了所有相关书籍, 并勤于练习), 16-20岁之间就收入颇丰, 主要来自扑克赌局与牌技表演. 为了练习玩牌, 他随身带着一副牌. 有一句话蛮逗的, 哈哈. &amp;ldquo;我与女朋友在看电影时, 我的左手会练习单手切牌, 而右手就放在每一个16岁男孩与女朋友看电影时所应游走的位置.&amp;rdquo; 当发现赌博不适合作为一生的职业后, 走上了证劵交易员的道路.&lt;/p&gt;
&lt;h2 id=&#34;摘录&#34;&gt;摘录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;他年少时精于玩牌, 并从中认识到“胜算”和“自律”的重要性.&lt;/li&gt;
&lt;li&gt;要了解市场, 更要了解自己.&lt;/li&gt;
&lt;li&gt;在阅读任何领域的书时, 我总是要求该书的作者或讨论的对象拥有工人的成就.&lt;/li&gt;
&lt;li&gt;知识本身绝对不是成功的保证. 除了知识, 你还需要一套执行知识的管理计划以及严格遵守计划的心理素质, 这样才可以免除情绪的干扰.&lt;/li&gt;
&lt;li&gt;如果你希望获胜, 你就必须了解规则; 另外, 你还必须愿意坐上赌桌, 这样你才有获胜的机会.&lt;/li&gt;
&lt;li&gt;赌博必须承担不利胜算的风险, 投机是掌握有利胜算的情况下才承担风险.&lt;/li&gt;
&lt;li&gt;赌博从来都不是一种高风险的行为, 输赢的关键是如何管理胜算. 我记住每一种牌型的胜算几率, 并依此决定对策. 这便是风险管理方法的要点所在.&lt;/li&gt;
&lt;li&gt;不可基于帮助朋友的立场, 免费提供任何有关市场的建议.&lt;/li&gt;
&lt;li&gt;结合技术分析, 统计方法以及经济基本面等因素, 评估任何投机头寸的风险. 唯有这三个因素相互配合时, 我才会在市场中建立重要头寸.&lt;/li&gt;
&lt;li&gt;作为交易者, 我的目标始终是: 在经济独立的情况下保有自由, 换句话说, 我的目标是: 经年累月地稳定赚钱.&lt;/li&gt;
&lt;li&gt;我的哲学基于三个原则, 按重要性排列如下: 保障资本, 一致性的获利能力以及追求卓越的回报. 这三者是我的基本原则, 因为他们是所有市场决策的最高指导原则.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一些原则&#34;&gt;一些原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;鳄鱼原则: 万一鳄鱼咬住你的脚, 务必记住: 你唯一的机会便是牺牲一只脚.&lt;/li&gt;
&lt;li&gt;道氏理论: 长期趋势最为重要, 也最容易被辨认, 归类与了解. 中期趋势对投资者来说较为次要, 但却是投机者的主要考虑因素. 短期趋势最难预测, 唯有交易者才会随时考虑他.&lt;/li&gt;
&lt;li&gt;交易准则: 1. 根据计划进行交易, 并严格遵守计划. 2. 顺势交易, &amp;ldquo;趋势是你的朋友&amp;rdquo;. 3. 在许可的范围内, 尽可能采用止损单. 4. 一旦心存怀疑, 立即出场. 5. 务必要有耐心, 不可过度扩张交易. 6. 迅速认赔, 让获利头寸持续发展. 7. 不可让获利头寸演变为亏损(或者, 尽可能持有必然). 8. 在弱势中买进, 在强势中卖出. 应该以买进的意愿来同等对待卖出. 9. 在多头市场的初期阶段, 应该扮演投资者的角色. 在多头市场的后期与空头市场中, 应该扮演投机的角色. 10. 不可摊平亏损&amp;ndash;亏损头寸不可加码. 11. 不可仅因价格偏低而买进, 不可仅因价格偏高而卖出. 12. 只在流动性高的市场中交易. 13. 在价格变动迅速时, 不可建立头寸.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>取代netcat的瑞士军刀socat</title>
      <link>/zh/post/socat-extended-netcat/</link>
      <pubDate>Fri, 11 Sep 2015 20:03:26 +0800</pubDate>
      <guid>/zh/post/socat-extended-netcat/</guid>
      <description>&lt;h2 id=&#34;desc&#34;&gt;desc&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;netcat++&lt;/li&gt;
&lt;li&gt;Multipurpose relay (SOcket CAT)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dest-unreach.org/socat/&#34;&gt;http://www.dest-unreach.org/socat/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;曾经一直纠结netcat这么好用的测试用具怎么就好久不更新了呢, 原来是有更好的取代者.&lt;/li&gt;
&lt;li&gt;socat相比netcat功能更加强大, 同时也相对复杂了一些.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;包含的工具&#34;&gt;包含的工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;socat&lt;/code&gt;: establishes two bidirectional byte streams and transfers data between them.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filan&lt;/code&gt;: prints information about its active file descriptors to stdout.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;procan&lt;/code&gt;: prints information about process parameters to stdout&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工作原理---life-cycle-of-a-socat-instance-4-phases&#34;&gt;工作原理 - life cycle of a &lt;code&gt;socat&lt;/code&gt; instance (4 phases)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;init phase(初始化阶段), the command line options are parsed and logging is initialized. (解析命令行以及初始化日志系统.)&lt;/li&gt;
&lt;li&gt;open phase(打开连接阶段), opens the first address and afterwards the second address. These steps are usually blocking; thus, especially for complex address types like socks, connection requests or authentication dialogs must be completed before the next step is started. (先打开第一个连接, 再打开第二个连接. 这个单步执行的. 如果第一个连接失败, 则会直接退出.)&lt;/li&gt;
&lt;li&gt;transfer phase(数据转发阶段), socat watches both streams&amp;rsquo; read and write file descriptors via select() , and, when data is available on one side and can be written to the other side, socat reads it, performs newline character conversions if required, and writes the data to the write file descriptor of the other stream, then continues waiting for more data in both directions. (谁有数据就转发到另外一个连接上, read/write互换.)&lt;/li&gt;
&lt;li&gt;closing phase(关闭阶段), one of the streams effectively reaches EOF. Socat transfers the EOF condition to the other stream, i.e. tries to shutdown only its write stream, giving it a chance to terminate gracefully. For a defined time socat continues to transfer data in the other direction, but then closes all remaining channels and terminates. (其中一个连接断开, 执行处理另外一个连接.)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;options&#34;&gt;Options&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;命令行参数用来修改程序的行为. 他们与所谓的作为address specifications的一部分的address options无关.&lt;/li&gt;
&lt;li&gt;详见: &lt;code&gt;socat -h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;address-specifications&#34;&gt;Address specifications&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个address specification通常包含一个address type关键字, 0或者更多必要的address parameters与keyword用&amp;rsquo;:&amp;lsquo;分隔以及他们相互之间, 和0或者更多address options用&amp;rsquo;,&amp;lsquo;分隔.&lt;/li&gt;
&lt;li&gt;keyword指定address type(如: TCP4, OPEN, EXEC). 对于有些keywords有同义词(&#39;-&amp;lsquo;与STDIO, TCP与TCP4). 关键字是大小写敏感的. 对于一些特殊的address type, keyword可以被忽略: Address specifications以数字开头的被认为是FD address(raw file descriptor). 如果一个&amp;rsquo;/&amp;lsquo;被发现, 在第一个&amp;rsquo;:&amp;lsquo;或者&amp;rsquo;,&amp;lsquo;前, GOPEN(generic file open)被认定.&lt;/li&gt;
&lt;li&gt;0或者更多address options可以被给到每一个地址上. 他们在一些方式上影响地址. Options由一个option keyword组成或者一个&lt;code&gt;option keyword=value&lt;/code&gt;组成. Option keywords是大小写不敏感的.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;address-types&#34;&gt;Address Types&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;socat -h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;address-options&#34;&gt;Address Options&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;socat -h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;data-values&#34;&gt;Data Values&lt;/h2&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dest-unreach.org/socat/doc/socat.html&#34;&gt;http://www.dest-unreach.org/socat/doc/socat.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dest-unreach.org/socat/doc/README&#34;&gt;http://www.dest-unreach.org/socat/doc/README&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Build OpenCV With Python Support</title>
      <link>/zh/post/buid-opencv-with-python-support/</link>
      <pubDate>Fri, 21 Aug 2015 06:43:26 +0800</pubDate>
      <guid>/zh/post/buid-opencv-with-python-support/</guid>
      <description>&lt;h2 id=&#34;steps&#34;&gt;steps&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Download &lt;code&gt;opencv-2.4.11.zip&lt;/code&gt; from &lt;a href=&#34;http://opencv.org/downloads.html&#34;&gt;http://opencv.org/downloads.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unzip opencv-2.4.11.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd opencv-2.4.11&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir release&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd release&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export PYTHONPATH=&amp;quot;/path_to_python/lib/python2.6/site-packages/:$PYTHONPATH&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_PYTHON_SUPPORT=ON ..&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果上一步找不到python相关路径, &lt;code&gt;ccmake ..&lt;/code&gt;, 然后手动指定 PYTHON_PACKAGES_PATH, PYTHON_EXECUTABLE, PYTHON_INCLUDE_DIR, PYTHON_LIBRARY, PYTHON_PACKAGES_PATH 这几个变量的位置.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;PYTHON_EXECUTABLE=&amp;quot;/path_to_python/bin/python&amp;quot;
PYTHON_INCLUDE_DIR=&amp;quot;/path_to_python/include/python2.6&amp;quot;
PYTHON_LIBRARY=&amp;quot;/path_to_python/lib/python2.6/config/libpython2.6.a&amp;quot;
PYTHON_PACKAGES_PATH=&amp;quot;/path_to_python/lib/python2.6/site-package&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo make install&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;python&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import cv2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html&#34;&gt;http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Make A Live USB For MacBook</title>
      <link>/zh/post/make-a-live-usb-for-macbook/</link>
      <pubDate>Mon, 18 May 2015 06:09:26 +0800</pubDate>
      <guid>/zh/post/make-a-live-usb-for-macbook/</guid>
      <description>&lt;h2 id=&#34;live-usblive-cd-发行版的选择&#34;&gt;live usb/live cd 发行版的选择&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://livecdlist.com/&#34;&gt;http://livecdlist.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最开始使用的live usb是ubuntu, 因为是我的入门linux发行版. 不过后来越来越不喜欢这个不稳定的发行版了. 接触的有Knoppix(默认桌面有3d特性, 基于debian), kali linux(backtrack的新版本, 基于debian, 还不错哦, 玩的人还蛮多的), System Rescue CD(基于Gentoo是他唯一的优点了吧, 官方太多文档与实际不对应的问题了)&lt;/li&gt;
&lt;li&gt;本次的选择, 先试用下System Rescue CD(因为我的项目就是用gentoo来做的, 另外, 我个人所有的linux环境都是gentoo啊), 如果发现使用起来非常不方便, 就转kali linux.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;system-rescue-cd&#34;&gt;System Rescue CD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;官方只支持x86(32bit与64bit合二为一了, 应该是gentoo的multilib版本), 不支持ARM, 在树莓派上让我怎么愉快的玩耍! 不过想想, 对于树莓派的live usb, 应该叫做live sd才对, 只要有个可用的sd卡即可了. 我毕竟只有一个U盘(SLC, 16G), ARM版的live usb属实用的地方不多.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mac Linux USB Loader: &lt;a href=&#34;http://sevenbits.github.io/Mac-Linux-USB-Loader/&#34;&gt;http://sevenbits.github.io/Mac-Linux-USB-Loader/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Enterprise: &lt;a href=&#34;https://sevenbits.github.io/Enterprise/&#34;&gt;https://sevenbits.github.io/Enterprise/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mac上boot分析&#34;&gt;mac上boot分析&lt;/h2&gt;
&lt;p&gt;不了解boot过程就搞的话, 很容易把系统搞坏的.&lt;/p&gt;
&lt;h3 id=&#34;uefi&#34;&gt;uefi&lt;/h3&gt;
&lt;h3 id=&#34;boot-camp&#34;&gt;boot camp&lt;/h3&gt;
&lt;h2 id=&#34;ref&#34;&gt;Ref&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.kali.org/installation/kali-linux-dual-boot-on-mac-hardware&#34;&gt;http://docs.kali.org/installation/kali-linux-dual-boot-on-mac-hardware&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.makeuseof.com/tag/how-to-boot-a-linux-live-usb-stick-on-your-mac/&#34;&gt;http://www.makeuseof.com/tag/how-to-boot-a-linux-live-usb-stick-on-your-mac/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mithun.co/tips/usb-live-boot-kali-linux-on-mac/&#34;&gt;http://mithun.co/tips/usb-live-boot-kali-linux-on-mac/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>break GxFxW</title>
      <link>/zh/post/break-firewall/</link>
      <pubDate>Thu, 19 Mar 2015 11:32:26 +0800</pubDate>
      <guid>/zh/post/break-firewall/</guid>
      <description>&lt;h2 id=&#34;gxfxw工作方式&#34;&gt;GxFxW工作方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GxFxW本身是一个人人都知道他的存在, 却从来不会被官方承认的机构.&lt;/li&gt;
&lt;li&gt;GxFxW封锁重点: 新闻, 社交, 政治, 色情, 文件共享类网站.&lt;/li&gt;
&lt;li&gt;DNS劫持和污染: DNS缓存投毒, 虚假IP劫持, 空包劫持, 轻松的扩展污染.&lt;/li&gt;
&lt;li&gt;敏感词过滤.&lt;/li&gt;
&lt;li&gt;IP阻断.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络工具&#34;&gt;网络工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ping, tcping(可测tcp端口) 测试网络是否连通&lt;/li&gt;
&lt;li&gt;traceroute 显示路由跳跃情况&lt;/li&gt;
&lt;li&gt;route (netstat -nr) 打印和修改本地路由表&lt;/li&gt;
&lt;li&gt;dig/nslookup 解析域名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;openwrt组件&#34;&gt;OpenWrt组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ipset&lt;/li&gt;
&lt;li&gt;iptables-mod-ipopt, kmod-ipt-ipopt&lt;/li&gt;
&lt;li&gt;ip&lt;/li&gt;
&lt;li&gt;iptables-mod-filter, kmod-ipt-filter&lt;/li&gt;
&lt;li&gt;iptables-mod-u32, kmod-ipt-u32&lt;/li&gt;
&lt;li&gt;ppp-mod-pptp&lt;/li&gt;
&lt;li&gt;openvpn-ssl&lt;/li&gt;
&lt;li&gt;dnsmasq-full&lt;/li&gt;
&lt;li&gt;bind-dig, bind-libs&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;技术原理&#34;&gt;技术原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IP命令, &lt;code&gt;opkg install ip&lt;/code&gt; table概念, 把数据添加到table, 让table数据走VPN接口.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;freerouter_v2 &lt;a href=&#34;http://www.lifetyper.com/&#34;&gt;http://www.lifetyper.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chinagfw.org/&#34;&gt;http://www.chinagfw.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.greatfire.org/&#34;&gt;https://zh.greatfire.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>移植linux内核的list.h到用户态</title>
      <link>/zh/post/port-list_h-in-kernel-to-userspace/</link>
      <pubDate>Wed, 18 Mar 2015 08:32:26 +0800</pubDate>
      <guid>/zh/post/port-list_h-in-kernel-to-userspace/</guid>
      <description>&lt;p&gt;以前工作的时候在项目里使用过的, 随着离职, 代码已经无法找到了. :(&lt;/p&gt;
&lt;p&gt;没关系这次放到github上面就不会丢失了.&lt;/p&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Type Oblivious&lt;/li&gt;
&lt;li&gt;Portable&lt;/li&gt;
&lt;li&gt;Easy to Use&lt;/li&gt;
&lt;li&gt;Readable&lt;/li&gt;
&lt;li&gt;Saves Time&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;usages&#34;&gt;Usages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;List is inside the data item you want to link together.&lt;/li&gt;
&lt;li&gt;You can put &lt;code&gt;struct list_head&lt;/code&gt; anywhere in your structure.&lt;/li&gt;
&lt;li&gt;You can name &lt;code&gt;struct list_head&lt;/code&gt; variable anything you wish.&lt;/li&gt;
&lt;li&gt;You can have multiple lists!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;repo&#34;&gt;Repo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/list&#34;&gt;https://github.com/Akagi201/list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://isis.poly.edu/kulesh/stuff/src/klist/&#34;&gt;http://isis.poly.edu/kulesh/stuff/src/klist/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>A File-oriented C/C&#43;&#43; Dependency Manager Biicode</title>
      <link>/zh/post/a-file-oriented-c-cpp-dependency-manager-biicode/</link>
      <pubDate>Mon, 16 Mar 2015 04:45:08 +0800</pubDate>
      <guid>/zh/post/a-file-oriented-c-cpp-dependency-manager-biicode/</guid>
      <description>&lt;p&gt;Biicode is a file-oriented Dependencies Manager for C and C++ developers.&lt;/p&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在C++中实现Go语言的modularity, 类似低是通过写合适的&lt;code&gt;#include&lt;/code&gt;语句实现.&lt;/li&gt;
&lt;li&gt;文件级别的依赖管理, 重用已有项目的任何独立文件.&lt;/li&gt;
&lt;li&gt;使用一条命令分享和发布到biicode&lt;/li&gt;
&lt;li&gt;不用打包, 直接使用源码进行模块管理.&lt;/li&gt;
&lt;li&gt;基于CMake编译&lt;/li&gt;
&lt;li&gt;支持依赖包的版本控制.&lt;/li&gt;
&lt;li&gt;biicode保存meta-data在文本文件中.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docs&#34;&gt;docs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.biicode.com/c++.html&#34;&gt;http://docs.biicode.com/c++.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础命令&#34;&gt;基础命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;版本: &lt;code&gt;bii version&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检查并安装编译工具: &lt;code&gt;bii setup:cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;搜索依赖: &lt;code&gt;bii find&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译: &lt;code&gt;bii cpp:build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建项目: &lt;code&gt;bii init myproject&lt;/code&gt;, 生成&lt;code&gt;bii&lt;/code&gt;目录&lt;/li&gt;
&lt;li&gt;创建hello world项目: &lt;code&gt;bii new myuser/myblock --hello=cpp&lt;/code&gt;, 生成&lt;code&gt;blocks&lt;/code&gt;目录.&lt;/li&gt;
&lt;li&gt;发布到biicode: &lt;code&gt;bii publish&lt;/code&gt; 默认发布到&lt;code&gt;DEV&lt;/code&gt;, 每次默认覆盖上次的&lt;code&gt;DEV&lt;/code&gt;代码.&lt;/li&gt;
&lt;li&gt;Release life-cycle tags: DEV, ALPHA, BETA, STABLE. &lt;code&gt;bii publish --tag=STABLE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;清理编译生成的结果: &lt;code&gt;bii clean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载一个block到本地项目block中: &lt;code&gt;bii open owner/block_name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;吐槽&#34;&gt;吐槽&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持nodejs是什么鬼啊! 就算技术上能实现, 可不可以完善好C/C++再搞其他的.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>简单的内核态时间片轮转程序</title>
      <link>/zh/post/simple-time-round-in-kernel/</link>
      <pubDate>Sun, 15 Mar 2015 10:45:08 +0800</pubDate>
      <guid>/zh/post/simple-time-round-in-kernel/</guid>
      <description>&lt;h2 id=&#34;实验环境&#34;&gt;实验环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;硬件: qemu(i386)(TODO: 由于我的gentoo没有装图形界面, 暂时在实验楼上做的)&lt;/li&gt;
&lt;li&gt;OS: linux-3.94 + 
&lt;a href=&#34;https://raw.github.com/mengning/mykernel/master/mykernel_for_linux3.9.4sc.patch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;patch&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;程序: &lt;a href=&#34;https://github.com/mengning/mykernel/tree/master/mykernel-1.1&#34;&gt;https://github.com/mengning/mykernel/tree/master/mykernel-1.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;repo: &lt;a href=&#34;https://github.com/Akagi201/learning-kernel/tree/master/kernel-inside/week2/mykernel&#34;&gt;https://github.com/Akagi201/learning-kernel/tree/master/kernel-inside/week2/mykernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lab&#34;&gt;lab&lt;/h2&gt;
&lt;h3 id=&#34;test1-环境测试&#34;&gt;test1 环境测试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;测试下环境, 仅仅是模拟了时钟中断, 一直都是一个进程在运行.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd LinuxKernel/linux-3.9.4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qemu -kernel arch/x86/boot/bzImage&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/mykernel-start.png&#34; alt=&#34;mykernel-start&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;test2-运行时间片轮转程序&#34;&gt;test2 运行时间片轮转程序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;更新&lt;code&gt;mykernel&lt;/code&gt;下的&lt;code&gt;myinterrupt.c&lt;/code&gt;, &lt;code&gt;mymain.c&lt;/code&gt;, &lt;code&gt;mypcb.h&lt;/code&gt; 为: &lt;a href=&#34;https://github.com/Akagi201/learning-kernel/tree/master/kernel-inside/week2/mykernel/1.0&#34;&gt;https://github.com/Akagi201/learning-kernel/tree/master/kernel-inside/week2/mykernel/1.0&lt;/a&gt; (复制不方便的话, 实验楼提供的ssh的方式连接系统)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make allnoconfig&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qemu -kernel arch/x86/boot/bzImage&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;h3 id=&#34;进程的启动&#34;&gt;进程的启动&lt;/h3&gt;
&lt;p&gt;进程从&lt;code&gt;void __init my_start_kernel(void)&lt;/code&gt;开始启动&lt;/p&gt;
&lt;p&gt;嵌入式汇编代码, 初始化第0号进程&lt;/p&gt;
&lt;h3 id=&#34;进程的切换&#34;&gt;进程的切换&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;schedule()&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;未完待续.&lt;/p&gt;
&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本文为刘博原创作品转载请注明出处.&lt;/li&gt;
&lt;li&gt;《Linux内核分析》MOOC课程 &lt;a href=&#34;http://mooc.study.163.com/course/USTC-1000029000&#34;&gt;http://mooc.study.163.com/course/USTC-1000029000&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Simple RTMP Server分析</title>
      <link>/zh/post/simple-rtmp-server-analysis/</link>
      <pubDate>Fri, 13 Mar 2015 08:24:08 +0800</pubDate>
      <guid>/zh/post/simple-rtmp-server-analysis/</guid>
      <description>&lt;h2 id=&#34;源码目录分析&#34;&gt;源码目录分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;整体目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;.
├── 3rdparty/ # 第三方库源码跟补丁
├── Makefile  # 通过configure生成的Makefile
├── auto/     # configure读取执行特定功能的脚本
├── conf/     # srs启动的配置文件*.conf
├── configure # 编译脚本用于根据用户参数生成Makefile跟.h文件
├── doc/      # 协议RFC
├── etc/      # linux启动脚本
├── ide/      # IDE工程文件
├── modules/  # 目前为空
├── objs/     # 编译结果
├── research/ # 预研项目
├── scripts/  # 辅助脚本
└── src/      # 源码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;源码目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;.
├── app
│   ├── srs_app_bandwidth.cpp
│   ├── srs_app_bandwidth.hpp
│   ├── srs_app_config.cpp
│   ├── srs_app_config.hpp
│   ├── srs_app_conn.cpp
│   ├── srs_app_conn.hpp
│   ├── srs_app_dvr.cpp
│   ├── srs_app_dvr.hpp
│   ├── srs_app_edge.cpp
│   ├── srs_app_edge.hpp
│   ├── srs_app_empty.cpp
│   ├── srs_app_empty.hpp
│   ├── srs_app_encoder.cpp
│   ├── srs_app_encoder.hpp
│   ├── srs_app_ffmpeg.cpp
│   ├── srs_app_ffmpeg.hpp
│   ├── srs_app_forward.cpp
│   ├── srs_app_forward.hpp
│   ├── srs_app_hds.cpp
│   ├── srs_app_hds.hpp
│   ├── srs_app_heartbeat.cpp
│   ├── srs_app_heartbeat.hpp
│   ├── srs_app_hls.cpp
│   ├── srs_app_hls.hpp
│   ├── srs_app_http.cpp
│   ├── srs_app_http.hpp
│   ├── srs_app_http_api.cpp
│   ├── srs_app_http_api.hpp
│   ├── srs_app_http_client.cpp
│   ├── srs_app_http_client.hpp
│   ├── srs_app_http_conn.cpp
│   ├── srs_app_http_conn.hpp
│   ├── srs_app_http_hooks.cpp
│   ├── srs_app_http_hooks.hpp
│   ├── srs_app_ingest.cpp
│   ├── srs_app_ingest.hpp
│   ├── srs_app_json.cpp
│   ├── srs_app_json.hpp
│   ├── srs_app_kbps.cpp
│   ├── srs_app_kbps.hpp
│   ├── srs_app_listener.cpp
│   ├── srs_app_listener.hpp
│   ├── srs_app_log.cpp
│   ├── srs_app_log.hpp
│   ├── srs_app_mpegts_udp.cpp
│   ├── srs_app_mpegts_udp.hpp
│   ├── srs_app_pithy_print.cpp
│   ├── srs_app_pithy_print.hpp
│   ├── srs_app_recv_thread.cpp
│   ├── srs_app_recv_thread.hpp
│   ├── srs_app_refer.cpp
│   ├── srs_app_refer.hpp
│   ├── srs_app_reload.cpp
│   ├── srs_app_reload.hpp
│   ├── srs_app_rtmp_conn.cpp
│   ├── srs_app_rtmp_conn.hpp
│   ├── srs_app_rtsp.cpp
│   ├── srs_app_rtsp.hpp
│   ├── srs_app_security.cpp
│   ├── srs_app_security.hpp
│   ├── srs_app_server.cpp
│   ├── srs_app_server.hpp
│   ├── srs_app_source.cpp
│   ├── srs_app_source.hpp
│   ├── srs_app_st.cpp
│   ├── srs_app_st.hpp
│   ├── srs_app_st_socket.cpp
│   ├── srs_app_st_socket.hpp
│   ├── srs_app_statistic.cpp
│   ├── srs_app_statistic.hpp
│   ├── srs_app_thread.cpp
│   ├── srs_app_thread.hpp
│   ├── srs_app_utility.cpp
│   └── srs_app_utility.hpp
├── core
│   ├── srs_core.cpp
│   ├── srs_core.hpp
│   ├── srs_core_autofree.cpp
│   ├── srs_core_autofree.hpp
│   ├── srs_core_performance.cpp
│   └── srs_core_performance.hpp
├── kernel
│   ├── srs_kernel_aac.cpp
│   ├── srs_kernel_aac.hpp
│   ├── srs_kernel_buffer.cpp
│   ├── srs_kernel_buffer.hpp
│   ├── srs_kernel_codec.cpp
│   ├── srs_kernel_codec.hpp
│   ├── srs_kernel_consts.cpp
│   ├── srs_kernel_consts.hpp
│   ├── srs_kernel_error.cpp
│   ├── srs_kernel_error.hpp
│   ├── srs_kernel_file.cpp
│   ├── srs_kernel_file.hpp
│   ├── srs_kernel_flv.cpp
│   ├── srs_kernel_flv.hpp
│   ├── srs_kernel_log.cpp
│   ├── srs_kernel_log.hpp
│   ├── srs_kernel_mp3.cpp
│   ├── srs_kernel_mp3.hpp
│   ├── srs_kernel_stream.cpp
│   ├── srs_kernel_stream.hpp
│   ├── srs_kernel_ts.cpp
│   ├── srs_kernel_ts.hpp
│   ├── srs_kernel_utility.cpp
│   └── srs_kernel_utility.hpp
├── libs
│   ├── srs_lib_bandwidth.cpp
│   ├── srs_lib_bandwidth.hpp
│   ├── srs_lib_simple_socket.cpp
│   ├── srs_lib_simple_socket.hpp
│   ├── srs_librtmp.cpp
│   └── srs_librtmp.hpp
├── main
│   └── srs_main_server.cpp
├── protocol
│   ├── srs_raw_avc.cpp
│   ├── srs_raw_avc.hpp
│   ├── srs_rtmp_amf0.cpp
│   ├── srs_rtmp_amf0.hpp
│   ├── srs_rtmp_buffer.cpp
│   ├── srs_rtmp_buffer.hpp
│   ├── srs_rtmp_handshake.cpp
│   ├── srs_rtmp_handshake.hpp
│   ├── srs_rtmp_io.cpp
│   ├── srs_rtmp_io.hpp
│   ├── srs_rtmp_msg_array.cpp
│   ├── srs_rtmp_msg_array.hpp
│   ├── srs_rtmp_sdk.cpp
│   ├── srs_rtmp_sdk.hpp
│   ├── srs_rtmp_stack.cpp
│   ├── srs_rtmp_stack.hpp
│   ├── srs_rtmp_utility.cpp
│   ├── srs_rtmp_utility.hpp
│   ├── srs_rtsp_stack.cpp
│   └── srs_rtsp_stack.hpp
└── utest
    ├── srs_utest.cpp
    ├── srs_utest.hpp
    ├── srs_utest_amf0.cpp
    ├── srs_utest_amf0.hpp
    ├── srs_utest_config.cpp
    ├── srs_utest_config.hpp
    ├── srs_utest_core.cpp
    ├── srs_utest_core.hpp
    ├── srs_utest_kernel.cpp
    ├── srs_utest_kernel.hpp
    ├── srs_utest_protocol.cpp
    ├── srs_utest_protocol.hpp
    ├── srs_utest_reload.cpp
    └── srs_utest_reload.hpp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编译脚本分析&#34;&gt;编译脚本分析&lt;/h2&gt;
&lt;h3 id=&#34;trunkconfigure&#34;&gt;&lt;code&gt;/trunk/configure&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;configure&lt;/code&gt;是个&lt;code&gt;Bash&lt;/code&gt;脚本, 根据配置来生成&lt;code&gt;Makefile&lt;/code&gt;跟&lt;code&gt;.h&lt;/code&gt;文件.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果存在&lt;code&gt;Makefile&lt;/code&gt;文件, 则执行&lt;code&gt;make clean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;Makefile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;objs&lt;/code&gt;目录&lt;/li&gt;
&lt;li&gt;导入并执行&lt;code&gt;auto/options.sh&lt;/code&gt;用于解析用户的编译参数, 对相应的SRS_XXX的变量进行赋值.&lt;/li&gt;
&lt;li&gt;导入&lt;code&gt;auto/generate-srs-librtmp-project.sh&lt;/code&gt;用于生成srs-librtmp项目, 创建项目目录, 拷贝一些文件到对应目录. &lt;code&gt;research/librtmp/*.c research/librtmp/Makefile auto/generate_header.sh auto/generate-srs-librtmp-single.sh src/core/* src/kernel/* src/protocol/* src/libs/*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导入并执行&lt;code&gt;auto/depends.sh&lt;/code&gt;, 检查缺少的依赖工具并安装&lt;/li&gt;
&lt;li&gt;导入并执行&lt;code&gt;auto/auto_headers.sh&lt;/code&gt;, 生成&lt;code&gt;srs_auto_headers.hpp&lt;/code&gt;, 声明配置的宏.&lt;/li&gt;
&lt;li&gt;srs modules相关&lt;/li&gt;
&lt;li&gt;编译工具跟编译参数赋值.&lt;/li&gt;
&lt;li&gt;指定第三方库路径&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;auto/modules.sh&lt;/code&gt;将不同模块写入Makefile中.&lt;/li&gt;
&lt;li&gt;生成srs app的编译目标的相关的Makefile代码. &lt;code&gt;auto/apps.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成utest的编译目标的相关的Makefile代码. &lt;code&gt;auto/utest.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;颜色化输出&lt;code&gt;auto/summary.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成&lt;code&gt;Makefile&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;导出srs-librtmp项目源码与编译&#34;&gt;导出&lt;code&gt;srs-librtmp&lt;/code&gt;项目源码与编译&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./configure --export-librtmp-project=srs-librtmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd srs-librtmp &amp;amp;&amp;amp; make&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;成果物: &lt;code&gt;objs/include/srs_librtmp.h&lt;/code&gt; &lt;code&gt;objs/lib/srs_librtmp.a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;examples: &lt;code&gt;research/librtmp&lt;/code&gt; &lt;a href=&#34;https://github.com/winlinvip/simple-rtmp-server/wiki/v2_CN_SrsLibrtmp#srs-librtmp-examples&#34;&gt;https://github.com/winlinvip/simple-rtmp-server/wiki/v2_CN_SrsLibrtmp#srs-librtmp-examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源码: &lt;code&gt;src&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>学习State Threads</title>
      <link>/zh/post/learning-state-threads/</link>
      <pubDate>Tue, 10 Mar 2015 12:35:08 +0800</pubDate>
      <guid>/zh/post/learning-state-threads/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_state_threads/index.html&#34; width=&#34;600&#34; height=&#34;300&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;State Threads(简称ST)是一个C语言轻量级用户层的线程库, 总共4631行C代码. 这个线程库有助于开发者实现一个具有高性能和可扩展性的网络应用程序. 是Apache项目里面的一个子项目.(?Apache以前听说是用的select啊, 可能apache最后没用st, 懒得去考证了)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~/Documents/state-threads (master) $ cloc .
      41 text files.
      38 unique files.
      11 files ignored.

http://cloc.sourceforge.net v 1.62  T=0.22 s (139.8 files/s, 61376.1 lines/s)
---------------------------------------------------------------------------------------
Language                             files          blank        comment           code
---------------------------------------------------------------------------------------
C                                       16           1046           1174           4631
HTML                                     3            236              0           3822
C/C++ Header                             6            270            288            939
make                                     3            106            205            364
Assembly                                 1             31            161            239
Windows Module Definition                1              0              0             51
Bourne Shell                             1             10              9             26
---------------------------------------------------------------------------------------
SUM:                                    31           1699           1837          10072
---------------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;docs&#34;&gt;Docs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;项目官方只有4页文档. &lt;a href=&#34;http://state-threads.sourceforge.net/docs/index.html&#34;&gt;http://state-threads.sourceforge.net/docs/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;其中introductory已经被好多国人翻译过了.(见下面Refs)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://coolshell.cn/articles/12012.html&#34;&gt;http://coolshell.cn/articles/12012.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zfengzhen/Blog/blob/master/article/%E4%B8%BA%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%80%8C%E7%94%9F%E7%9A%84State%20Threads%5B%E5%B8%B8%E8%A7%81%E5%90%8E%E5%8F%B0%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90%5D.md&#34;&gt;https://github.com/zfengzhen/Blog/blob/master/article/%E4%B8%BA%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%80%8C%E7%94%9F%E7%9A%84State%20Threads%5B%E5%B8%B8%E8%A7%81%E5%90%8E%E5%8F%B0%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90%5D.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/win_lin/article/details/8242653&#34;&gt;http://blog.csdn.net/win_lin/article/details/8242653&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wuyu201321060203/wuyu201321060203.github.io/blob/master/_posts/2014-10-15-ST.md&#34;&gt;https://github.com/wuyu201321060203/wuyu201321060203.github.io/blob/master/_posts/2014-10-15-ST.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一个简单的汇编程序分析</title>
      <link>/zh/post/a-simple-assembly-program-analysis/</link>
      <pubDate>Sun, 01 Mar 2015 12:38:08 +0800</pubDate>
      <guid>/zh/post/a-simple-assembly-program-analysis/</guid>
      <description>&lt;p&gt;最近打算跟一下&amp;lt;linux内核分析&amp;gt;这门mooc课程. 刚完成了第一周的内容. mindmup内容开源如下:&lt;/p&gt;
&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_kernel/index.html&#34; width=&#34;600&#34; height=&#34;800&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;这里使用跟linux内核一样的AT&amp;amp;T汇编语法.&lt;/p&gt;
&lt;h2 id=&#34;att-汇编语法注意事项&#34;&gt;AT&amp;amp;T 汇编语法注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大小写: 指令语句使用小写字母.&lt;/li&gt;
&lt;li&gt;操作符赋值方向: 第一个为源操作数, 第二个为目的操作数, 方向从左到右, 合乎自然(与C库相反)&lt;/li&gt;
&lt;li&gt;前缀: 寄存器需要加前缀&amp;rdquo;%&amp;quot;, 立即数需要加前缀&amp;quot;$&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;间接寻址语法: 使用 &amp;ldquo;(&amp;quot;, &amp;ldquo;)&amp;rdquo;&lt;/li&gt;
&lt;li&gt;后缀: 大部分指令操作码的最后一个字母表示操作数大小, &amp;ldquo;b&amp;quot;表示byte, &amp;ldquo;w&amp;quot;表示word(2个字节), &amp;ldquo;l&amp;quot;表示long(4个字节).&lt;/li&gt;
&lt;li&gt;注释: @用于一行代码后面添加注释内容, #是整行注释.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简单的c源程序&#34;&gt;简单的C源程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/*
 * @file main.c
 * @author Akagi201
 * @date 2015/03/01
 *
 * A simple code to learn how assembly code works.
 * build on linux x64: gcc -S -o main.s main.c -m32
 */

int g(int x) {
  return x + 3;
}

int f(int x) {
  return g(x);
}

int main (void) {
  return f(8) + 1;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;linux-x64平台汇编命令&#34;&gt;Linux x64平台汇编命令&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/assembly.png&#34; alt=&#34;asm&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的编译环境是: 物理机是rmbp, 运行的virtualbox, guest OS是gentoo x64.&lt;/li&gt;
&lt;li&gt;汇编命令: &lt;code&gt;gcc –S –o main.s main.c -m32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将得到的main.s文件中以.开头的行删掉(用于辅助链接的).&lt;/li&gt;
&lt;li&gt;生成的汇编代码中增加了部分注释说明了程序执行的过程.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;g:
	pushl	%ebp
	movl	%esp, %ebp
	movl	8(%ebp), %eax # eax = 8
	addl	$3, %eax # eax = 8 + 3 = 11
	popl	%ebp
	ret

f:
	pushl	%ebp
	movl	%esp, %ebp # 每个函数前两句都是这个, 用于保存上一个堆栈的栈顶, 跟清空出一个新的堆栈
	subl	$4, %esp
	movl	8(%ebp), %eax # eax = 8
	movl	%eax, (%esp) # 把8放到栈顶
	call	g # 跳到g标号
	leave
	ret

main:
	pushl	%ebp # 将当前ebp的值压栈, 同时esp的值被修改(即减4)
	movl	%esp, %ebp # 将ebp指向esp
	subl	$4, %esp # 将esp向下移动一个位置
	movl	$8, (%esp) # 将立即数8赋值给esp指向的位置(即当前的栈顶)
	call	f # 等价于两条语句 pushl eip; movl f eip =&amp;gt; 当前eip实际指向addl $1, %eax这条指令, 跳转到f标号处执行
	addl	$1, %eax # eax = 11 + 1 = 12
	leave
	ret # 最终ebp, esp回到main函数最初的栈的位置.

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本文为刘博原创作品转载请注明出处.&lt;/li&gt;
&lt;li&gt;《Linux内核分析》MOOC课程&lt;a href=&#34;http://mooc.study.163.com/course/USTC-1000029000&#34;&gt;http://mooc.study.163.com/course/USTC-1000029000&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>教不懂电脑的父母上网</title>
      <link>/zh/post/parents-network/</link>
      <pubDate>Thu, 19 Feb 2015 13:30:08 +0800</pubDate>
      <guid>/zh/post/parents-network/</guid>
      <description>&lt;p&gt;估计跟我一样80后的人都会涉及这个头大的问题, &amp;ldquo;教父母上网&amp;rdquo;. 下面整理些要点.&lt;/p&gt;
&lt;h2 id=&#34;父母知识背景&#34;&gt;父母知识背景&lt;/h2&gt;
&lt;p&gt;父母虽然年轻时候也算接受过一些中等教育, 不过工作不是从事脑力方面, 学习能力几乎为零. 电脑跟智能手机方面知识几乎为零. 不手把手教, 一点不肯学, 不学习借口一堆.&lt;/p&gt;
&lt;h2 id=&#34;想要教的东西&#34;&gt;想要教的东西&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本的硬件组成跟连接&lt;/li&gt;
&lt;li&gt;拼音打字, 基本快捷键&lt;/li&gt;
&lt;li&gt;帮助注册邮箱跟必备的账号&lt;/li&gt;
&lt;li&gt;QQ, 包含语音跟视频&lt;/li&gt;
&lt;li&gt;淘宝等网上购物&lt;/li&gt;
&lt;li&gt;推荐一些应该上的网站&lt;/li&gt;
&lt;li&gt;打免费电话&lt;/li&gt;
&lt;li&gt;手机上好用的app&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;email-qq&#34;&gt;email, qq&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要求不需要翻墙, 中文界面&lt;/li&gt;
&lt;li&gt;选择qq邮箱(需要手机号才行)&lt;/li&gt;
&lt;li&gt;备用邮箱用我的, 密码, 密保跟账号我都保留记录好.&lt;/li&gt;
&lt;li&gt;加我的账号为好友&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;电脑上软件&#34;&gt;电脑上软件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;装了腾讯系列的浏览器, 电脑管家等, 先观察看看, 不行就换360吧.&lt;/li&gt;
&lt;li&gt;qq, 千牛, 迅雷, 360wifi, winrar, 酷盘, 百度云, 搜狗输入法, 爱奇艺PPS(看综艺节目)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;电脑硬件配件&#34;&gt;电脑硬件配件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;耳机插孔的双音响(不需要配件, 连接不无线的简单)&lt;/li&gt;
&lt;li&gt;耳麦, 摄像头(用于远程视频通话)&lt;/li&gt;
&lt;li&gt;360随身wifi(家里这边移动宽带限制, 路由器上拨号失败, 只能电脑上拨号, 用于分享网络给手机)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;引导使用的网站&#34;&gt;引导使用的网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我的博客, 我公司的网站, 淘宝, 支付宝, 知乎, 优酷, 爱奇艺PPS, 百度地图, 携程, V2EX, 百度云.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;手机app&#34;&gt;手机app&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;红米+酷派大神+小米充电宝 两台&lt;/li&gt;
&lt;li&gt;微信, 微博, qq, 支付宝, 淘宝, 千牛, 百度地图, qq邮箱, 爱奇艺, 优酷, 携程, 虾米音乐, 易信, 叮叮, 滴滴打车, 手机营业厅&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Missing C Package Manager Clib</title>
      <link>/zh/post/the-missing-c-package-manager-clib/</link>
      <pubDate>Thu, 12 Feb 2015 07:44:08 +0800</pubDate>
      <guid>/zh/post/the-missing-c-package-manager-clib/</guid>
      <description>&lt;p&gt;web与移动开发领域每种语言都有自己的包管理器. &lt;code&gt;nodejs&lt;/code&gt;的&lt;code&gt;npm&lt;/code&gt;, &lt;code&gt;golang&lt;/code&gt;的&lt;code&gt;go get&lt;/code&gt;, &lt;code&gt;lua&lt;/code&gt;的&lt;code&gt;luarocks&lt;/code&gt;, ios&amp;amp;macosx平台的&lt;code&gt;cocoapods&lt;/code&gt;, &lt;code&gt;Python&lt;/code&gt;的&lt;code&gt;Pip&lt;/code&gt;&amp;amp;&lt;code&gt;Eggs&lt;/code&gt;, &lt;code&gt;TeX&lt;/code&gt;的&lt;code&gt;CTAN&lt;/code&gt;, &lt;code&gt;Perl&lt;/code&gt;的&lt;code&gt;CPAN&lt;/code&gt;, &lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;Maven&lt;/code&gt;, &lt;code&gt;Haskell&lt;/code&gt;的&lt;code&gt;cabal&lt;/code&gt;, &lt;code&gt;Ruby&lt;/code&gt;的&lt;code&gt;Gems&lt;/code&gt;, &lt;code&gt;.Net&lt;/code&gt;的&lt;code&gt;NuGet&lt;/code&gt;. 如果有兴趣, 可以看下这个播客&lt;a href=&#34;https://ipn.li/kernelpanic/7/&#34;&gt;https://ipn.li/kernelpanic/7/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过C语言确一直没有一个这样的工具. 导致的问题就是, 当你需要用功C语言实现一个很通用的功能的时候, 你没有一个合适的地方去找, 只能google, stackoverflow, github去搜, 然后你有发现你要的这个功能在一个很大的项目里面的一个小模块, 然后很难独立提取出来, 然后只好重复造轮子.&lt;/p&gt;
&lt;p&gt;还好, nodejs社区的几个人创造了Clib. C语言终于有自己的包管理器啦: Clib. TJ Holowaychuk先用node.js写了Clib, 然后Stephen Mathieson把他port成了C.&lt;/p&gt;
&lt;h2 id=&#34;clib-developers-blog&#34;&gt;Clib developer&#39;s blog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://medium.com/code-adventures/introducing-clib-b32e6e769cb3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing Clib&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.ashworth.in/the-advent-of-clib-the-c-package-manager/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Advent of Clib: the C Package Manager&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang on OpenWrt</title>
      <link>/zh/post/golang-on-openwrt/</link>
      <pubDate>Fri, 06 Feb 2015 01:51:08 +0800</pubDate>
      <guid>/zh/post/golang-on-openwrt/</guid>
      <description>&lt;h2 id=&#34;repo&#34;&gt;Repo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GeertJohan/openwrt-go&#34;&gt;https://github.com/GeertJohan/openwrt-go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone https://github.com/GeertJohan/openwrt-go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout add-gccgo-and-libgo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make menuconfig&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;-&amp;gt; Advanced configuration options
-&amp;gt; Toolchain options
....
-&amp;gt; Select Build/Install gccgo
....
-&amp;gt; C library implementation
-&amp;gt; Use eglibc
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make V=s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;result&#34;&gt;result&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;firmware with eglibc: &lt;code&gt;bin/ar71xx-eglibc/openwrt-ar71xx-generic-carambola2-squashfs-sysupgrade.bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add toolchain to PATH: &lt;code&gt;export PATH=/home/akagi201/openwrt-go/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_eglibc-2.19/bin:$PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add toolchain alias: &lt;code&gt;alias mips_gccgo=&#39;mips-openwrt-linux-gccgo -Wl,-R,/home/akagi201/openwrt-go/staging_dir/toolchain-mips_34kc_gcc-4.8.0_eglibc-2.19/lib/gcc/mips-openwrt-linux-gnu/4.8.3 -L /home/akagi201/openwrt-go/staging_dir/toolchain-mips_34kc_gcc-4.8.0_eglibc-2.19/lib&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;use libgo non-static.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;fmt&amp;quot;
func main() {
    fmt.Println(&amp;quot;hello world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mips_gccgo -Wall -o hello_static_libgo hello.go -static-libgo&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Before stripped&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akgentoo ~/openwrt-go (add-gccgo-and-libgo*) $ file hello_static_libgo
hello_static_libgo: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1, dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped

akagi201@akgentoo ~/openwrt-go (add-gccgo-and-libgo*) $ ll hello_static_libgo
-rwxr-xr-x 1 akagi201 akagi201 2.6M Feb  6 01:47 hello_static_libgo
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;After stripped&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akgentoo ~/openwrt-go (add-gccgo-and-libgo*) $ file hello_static_libgo
hello_static_libgo: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.16, stripped
akagi201@akgentoo ~/openwrt-go (add-gccgo-and-libgo*) $ ll hello_static_libgo
-rwxr-xr-x 1 akagi201 akagi201 1.2M Feb  6 02:02 hello_static_libgo
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GeertJohan/openwrt-go/issues/2&#34;&gt;https://github.com/GeertJohan/openwrt-go/issues/2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Stream Encoder</title>
      <link>/zh/post/stream-encoder/</link>
      <pubDate>Wed, 14 Jan 2015 16:02:08 +0800</pubDate>
      <guid>/zh/post/stream-encoder/</guid>
      <description>&lt;h2 id=&#34;obs&#34;&gt;OBS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jp9000/obs-studio&#34;&gt;https://github.com/jp9000/obs-studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开发前说明: &lt;a href=&#34;https://obsproject.com/forum/threads/getting-started-with-obs-development.21326/&#34;&gt;https://obsproject.com/forum/threads/getting-started-with-obs-development.21326/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文档: &lt;a href=&#34;http://jp9000.github.io/OBS/&#34;&gt;http://jp9000.github.io/OBS/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OBS core: libobs, OBS UI: obs, core跟ui是独立的.&lt;/li&gt;
&lt;li&gt;OBS core plugins: plugins&lt;/li&gt;
&lt;li&gt;IRC: #obsproject on Freenode, #obs-dev on Quakenet&lt;/li&gt;
&lt;li&gt;settings estimator: &lt;a href=&#34;https://obsproject.com/estimator&#34;&gt;https://obsproject.com/estimator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ble&#34;&gt;BLE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wenjiegit/Bull-Live-Encoder&#34;&gt;https://github.com/wenjiegit/Bull-Live-Encoder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning RTP</title>
      <link>/zh/post/learning-rtp/</link>
      <pubDate>Mon, 15 Dec 2014 21:50:26 +0800</pubDate>
      <guid>/zh/post/learning-rtp/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_rtp/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;code&gt;RTP&lt;/code&gt;(Real-time Transport Protocol)是用于Internet上针对多媒体数据流的一种传输协议. &lt;code&gt;RTP&lt;/code&gt;被定义为在一对一或一对多的传输情况下工作, 其目的是提供时间信息和实现流同步. &lt;code&gt;RTP&lt;/code&gt;通常使用&lt;code&gt;UDP&lt;/code&gt;来传送数据, 但&lt;code&gt;RTP&lt;/code&gt;也可以在&lt;code&gt;TCP&lt;/code&gt;或&lt;code&gt;ATM&lt;/code&gt;等其他协议之上工作.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RTP&lt;/code&gt;本身并没有提供按时发送机制或其他服务质量(QoS)保证, 它依赖于底层服务去实现这一过程. &lt;code&gt;RTP&lt;/code&gt;并不保证传送或防止无序传送, 也不确定底层网络的可靠性.&lt;/p&gt;
&lt;h2 id=&#34;book&#34;&gt;book&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.safaribooksonline.com/library/view/rtp-audio-and/0672322498/&#34;&gt;https://www.safaribooksonline.com/library/view/rtp-audio-and/0672322498/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/RTP-Audio-Video-Internet-paperback/dp/0321833627&#34;&gt;http://www.amazon.com/RTP-Audio-Video-Internet-paperback/dp/0321833627&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning cURL</title>
      <link>/zh/post/learning-curl/</link>
      <pubDate>Tue, 09 Dec 2014 03:55:26 +0800</pubDate>
      <guid>/zh/post/learning-curl/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_curl/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;cURL全称是&amp;quot;Client for URLs&amp;rdquo;, 即URL客户端.&lt;/p&gt;
&lt;p&gt;是
&lt;a href=&#34;https://github.com/bagder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Daniel Stenberg&lt;/a&gt;
的一个个人项目, 就放在个人的一个二级域名&lt;a href=&#34;http://curl.haxx.se/&#34;&gt;http://curl.haxx.se/&lt;/a&gt;下, 所以有的地方略显粗糙也可以理解了.&lt;/p&gt;
&lt;p&gt;项目历史应该比较久远了, 文档全是用的&lt;code&gt;manpage&lt;/code&gt;写的, 不用到处找了, 直接&lt;code&gt;man&lt;/code&gt;就可以了.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;的&lt;code&gt;repo&lt;/code&gt;由两部分组成, &lt;code&gt;curl&lt;/code&gt;命令行跟&lt;code&gt;libcurl&lt;/code&gt;, 其中复杂的东西都在&lt;code&gt;libcurl&lt;/code&gt;中了.&lt;/p&gt;
&lt;h2 id=&#34;源码结构&#34;&gt;源码结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;curl&lt;/code&gt;命令行的源码在&lt;code&gt;src/&lt;/code&gt;, 入口在&lt;code&gt;tool_main.c&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libcurl&lt;/code&gt;的源码在&lt;code&gt;lib/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API example&lt;/code&gt;的源码在&lt;code&gt;docs/examples&lt;/code&gt;下.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning Google C&#43;&#43; Testing Framework</title>
      <link>/zh/post/learning-gtest/</link>
      <pubDate>Thu, 04 Dec 2014 21:35:26 +0800</pubDate>
      <guid>/zh/post/learning-gtest/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_gtest/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;最近接触不少有趣的小项目, 让我重拾C语言的乐趣了. 现在移动和web发展非常块, web领域技术的发展, 也推进了底层技术的发展. &lt;code&gt;clib&lt;/code&gt;就让我对&lt;code&gt;js&lt;/code&gt;跟&lt;code&gt;node&lt;/code&gt;这帮人的印象大大改观.&lt;/p&gt;
&lt;p&gt;跟着牛人的脚本慢慢前进是不会错的. 选择了&lt;code&gt;CLion&lt;/code&gt;, 导致选择了&lt;code&gt;CMake&lt;/code&gt;, 又由&lt;code&gt;CMake&lt;/code&gt;跟&lt;code&gt;CLion&lt;/code&gt;选择了&lt;code&gt;GTest&lt;/code&gt;. 学习下来发现都是好东西.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Google C++ Testing Framework&lt;/code&gt;简称&lt;code&gt;GTest&lt;/code&gt;, 跟&lt;code&gt;CMake&lt;/code&gt;集成的非常好, 而且他本身就是用&lt;code&gt;CMake&lt;/code&gt;编译的, 作为一个转向&lt;code&gt;CMake&lt;/code&gt;开发者来说, 这是极赞的.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GTest&lt;/code&gt;文档相应比较少, 对于新手来说可能有点曲线, 我写了几个集成&lt;code&gt;Makefile&lt;/code&gt;跟&lt;code&gt;CMake&lt;/code&gt;的例子, 可以看看: &lt;a href=&#34;https://github.com/Akagi201/learning-gtest&#34;&gt;https://github.com/Akagi201/learning-gtest&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Libuv</title>
      <link>/zh/post/learning-libuv/</link>
      <pubDate>Thu, 13 Nov 2014 01:50:26 +0800</pubDate>
      <guid>/zh/post/learning-libuv/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_libuv/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;想研究libuv很久了, 一直没有用他的机会, 这次项目中有个多进程管理的地方, 正纠结怎么操作麻烦的信号量时, 想起libuv也可以完成这件事, 所以, 赶紧用起来. 不用白不用.&lt;/p&gt;
&lt;p&gt;Lua在嵌入式领域大有可以, 可以编译成一个liblua.a的库静态连接到C程序, 还有很多丰富的工具, 本身语言有非常小巧, 以后还是多用lua写写, 方便移植啊. 多平台各种差异, 搞死人啊.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning uC/OS</title>
      <link>/zh/post/learning-ucos/</link>
      <pubDate>Thu, 13 Nov 2014 01:28:26 +0800</pubDate>
      <guid>/zh/post/learning-ucos/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_ucos/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34; &gt;&lt;/iframe&gt;
&lt;p&gt;最近比较粗略的学习了一下uC/OS-II的系统, 感觉设计上中规中矩吧, 很多类似的结构, 应该可以设计得更精简些的, 不过, 在单片机系统上用的还是蛮多的. 其中任务就绪表跟内存管理部分, 还需要有空再详细看看.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Blog</title>
      <link>/zh/post/about-blog/</link>
      <pubDate>Tue, 21 Oct 2014 02:53:26 +0800</pubDate>
      <guid>/zh/post/about-blog/</guid>
      <description>&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在slide部分上方显示我的头像.&lt;/li&gt;
&lt;li&gt;在手机跟PC上显示slide部分更优雅一点.&lt;/li&gt;
&lt;li&gt;中英文两个版本切换.&lt;/li&gt;
&lt;li&gt;不同分类用不同的样式.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;categories&#34;&gt;Categories&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;blog, tool, book, talk, project&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tags&#34;&gt;Tags&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;openwrt, kernel, wifi, hardware, macosx, golang, algorithm, git, protocol, security&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;markdown-contents&#34;&gt;Markdown Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/akblog&#34;&gt;https://github.com/Akagi201/akblog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;static-pages&#34;&gt;Static Pages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/akagi201.github.io&#34;&gt;https://github.com/Akagi201/akagi201.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning CMake</title>
      <link>/zh/post/learning-cmake/</link>
      <pubDate>Sun, 19 Oct 2014 00:35:26 +0800</pubDate>
      <guid>/zh/post/learning-cmake/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_cmake/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;为了更好的掌握CLion, 最近把CMake Practice看完, 并练习了一下. 完成之后发现内容很少. 老的autotools也是要掌握的, openwrt上编译很多项目还是要用到他.&lt;/p&gt;
&lt;h2 id=&#34;github-repo&#34;&gt;Github Repo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/learning-cmake&#34;&gt;https://github.com/Akagi201/learning-cmake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning FFmpeg</title>
      <link>/zh/post/learning-ffmpeg/</link>
      <pubDate>Fri, 10 Oct 2014 10:31:26 +0800</pubDate>
      <guid>/zh/post/learning-ffmpeg/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_ffmpeg/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;我自己购买了mindmup gold的账号, 有钱淫欢迎投资我啊!!&lt;/p&gt;
&lt;p&gt;发现个ffmpeg领域的大牛, 他已经在读博士了, 天朝这样做学术的人还是值得赞赏的, ffmpeg中文资料必看: &lt;a href=&#34;http://blog.csdn.net/leixiaohua1020&#34;&gt;http://blog.csdn.net/leixiaohua1020&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Network</title>
      <link>/zh/post/learning-network/</link>
      <pubDate>Wed, 17 Sep 2014 15:28:26 +0800</pubDate>
      <guid>/zh/post/learning-network/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/introduction_to_computer_networks/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;h2 id=&#34;google-drive&#34;&gt;Google Drive&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;mindmup 免费的在线分享放不下了, 只能放到google drive上了.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://drive.google.com/file/d/0BzJcP7mynkO5aVIyRlg4X0xxYlU/view?usp=sharing&#34;&gt;https://drive.google.com/file/d/0BzJcP7mynkO5aVIyRlg4X0xxYlU/view?usp=sharing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Streaming Protocols</title>
      <link>/zh/post/streaming-protocols/</link>
      <pubDate>Tue, 09 Sep 2014 15:28:26 +0800</pubDate>
      <guid>/zh/post/streaming-protocols/</guid>
      <description>&lt;p&gt;整理了一下流媒体相关的协议, 可能部分划分的不科学, 展开的不够细致. 先分享出来好了.&lt;/p&gt;
&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/streaming_protocols/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>Learning OpenWrt - Outline</title>
      <link>/zh/post/learning-openwrt/</link>
      <pubDate>Mon, 25 Aug 2014 03:02:26 +0800</pubDate>
      <guid>/zh/post/learning-openwrt/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_openwrt/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>FreeRADIUS新手入门 - 我翻译的开源书</title>
      <link>/zh/post/freeradius-beginners-guide/</link>
      <pubDate>Fri, 22 Aug 2014 13:35:26 +0800</pubDate>
      <guid>/zh/post/freeradius-beginners-guide/</guid>
      <description>&lt;p&gt;最近在搭建CoovaChilli + FreeRadius的认证系统. 顺便把一本英文书翻译一下. 由于时间比较匆忙, 所以还不保证质量, 想尽快翻译完, 然后在慢慢斟酌个别语句. 这个项目本身也是试水作品, 为以后写自己的书做些&lt;strong&gt;技术储备&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在写书的过程中发现几个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gitbook中文支持有写问题, 有时候文本最左边字会叠在一起.&lt;/li&gt;
&lt;li&gt;有时候gitbook会崩溃, 有时候搜狗输入法会比较卡, 不知道是否是兼容性问题, 要及时保存.&lt;/li&gt;
&lt;li&gt;原文章节层次结构太乱了, 只有一级跟二级标题, 三级标题, 四级标题跟二级标题字体样式完全一样, 没法区分, 抽空要整理下.&lt;/li&gt;
&lt;li&gt;markdown感觉层次太多的时候会记不住自己在哪层了.&lt;/li&gt;
&lt;li&gt;github还没同步过来, 国内用gitbook写书的还不多, 问了一圈没得到答复.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在线阅读地址&#34;&gt;在线阅读地址&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://freeradius.akagi201.org&#34;&gt;http://freeradius.akagi201.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;github地址还没同步过来-求助&#34;&gt;github地址(还没同步过来, 求助)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/freeradius-beginners-guide&#34;&gt;https://github.com/Akagi201/freeradius-beginners-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>将OpenWrt变成完美的BSP</title>
      <link>/zh/post/turn-openwrt-into-the-perfect-bsp/</link>
      <pubDate>Thu, 03 Jul 2014 12:26:26 +0800</pubDate>
      <guid>/zh/post/turn-openwrt-into-the-perfect-bsp/</guid>
      <description>&lt;p&gt;BSP(Board Support Package)对于嵌入式开发者一定不陌生, 就是针对一种板子适配指定的操作系统(常见的是linux)所需要的bootloader, 板上外设的所有驱动, 还有内核, 通常还包括一个根文件系统(里面包含能确保板子能跑起来的基本的一些配置)和toolchain.&lt;/p&gt;
&lt;p&gt;随着软件系统的发展, 越来越多的统一化环境配置的工具出现, 像vagrant, docker等, 这样, 将运行环境一起打包就不会出现过去那种, 在我的机器上能运行, 在你的机器上运行不了的情况了.&lt;/p&gt;
&lt;p&gt;嵌入式开发也是一样, 每次面对一种新的SOC, 多要进行一些重复工作, 像裁剪系统, 裁剪busybox, 移植各种应用, 各种库等. 对于开发而言, 对于每种平台开发时, 都要有一些细小的差异. 而这些差异是可以统一起来的. 解决方案就是OpenWrt.&lt;/p&gt;
&lt;p&gt;用OpenWrt作为BSP, 这使得用户和开发者可以快速熟悉不同的/新的硬件产品. 关于OpenWrt的详细内容, 在OpenWrt的官方文档有非常详细的介绍. &lt;a href=&#34;http://wiki.openwrt.org/doc/start&#34;&gt;http://wiki.openwrt.org/doc/start&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么公司如何用OpenWrt做自己的产品呢? 根据开源项目的特点需要进行一些修改.&lt;/p&gt;
&lt;h2 id=&#34;openwrt-buildroot的makefile-wrapper&#34;&gt;OpenWrt Buildroot的Makefile wrapper&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;download tool: 下载指定版本的OpenWrt&lt;/li&gt;
&lt;li&gt;patchset: 对指定版本的OpenWrt进行打补丁, 确保稳定&lt;/li&gt;
&lt;li&gt;package feed: 自己软件包的 package feed.&lt;/li&gt;
&lt;li&gt;dl link directory: 将~/dl链接到openwrt/dl.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用openwrt-buildroot过程的技巧&#34;&gt;使用OpenWrt buildroot过程的技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenWrt的buildroot编译系统, 包含fetching, patching, compiling, packaging的过程. 在fetching阶段会联网下载源码到dl目录, 所以, 一个好的方法是, 将dl目录保存在自己本地机器的一个固定位置, 然后软链接到openwrt/dl目录, 这样就不用每次下载重复的包了, 另外, 有时由于网络原因, 可以手动下载包放到这个目录.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>地理围栏(Geo-fencing)</title>
      <link>/zh/post/geo-fencing/</link>
      <pubDate>Thu, 26 Jun 2014 02:21:26 +0800</pubDate>
      <guid>/zh/post/geo-fencing/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/geofencing.png&#34; alt=&#34;geofencing&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;geo-fencing&#34;&gt;Geo-fencing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A geo-fence is a virtual perimeter for a real-world geographic area.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Geo-fence&#34;&gt;http://en.wikipedia.org/wiki/Geo-fence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;地理围栏(Geo-fencing)是LBS的一种新应用, 就是用一个虚拟的栅栏围出一个虚拟地理边界. 当手机进入, 离开某个特定地理区域, 或在该区域内活动时, 手机可以接收自动通知和警告.&lt;/li&gt;
&lt;li&gt;有了地理围栏技术, 位置社交网站就可以帮助用户在进入某一地区时自动登记, 可应用智能购物, 个人助理, 家庭成员/朋友的发现, 智能家居等领域.&lt;/li&gt;
&lt;li&gt;地理围栏可通过蓝牙, WIFI, GPS等定位技术完成, 移动设备进入围栏后会自动选择最低功耗方式进行定位, 地理围栏技术为开发者提供全新想象空间.&lt;/li&gt;
&lt;li&gt;地理围栏技术均是: 预先划定一些多边形的区域, 一个中心化的设备或者云端知道定位源进入该区域; 定位源知道自己进入该区域; 触发一些响应, 例如消息的push. 在智能硬件时代, 这种能够更加精准地定位, 更加节省功耗, 更加有效率低成本的互联互通方式, 迎来爆发机会.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;geo-fencing-vs-lbs&#34;&gt;Geo-fencing vs LBS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;地理围栏的地理区域是被网格化的. 网格化的标准是根据一个地理区域内的业务和商业聚类的, 而不是纯粹的经纬度和城市地图的匹配.&lt;/li&gt;
&lt;li&gt;实际上地理围栏的各个围栏的区隔是一个个的应用需求群地图. 主要的商业需求聚集在特定区域, 形成的一个聚合信息服务区域.&lt;/li&gt;
&lt;li&gt;终端自己或者在网络帮助下能够识别所处的围栏.&lt;/li&gt;
&lt;li&gt;用户的围栏信息彼此之间能够共享, 也能够与应用开发商分享.&lt;/li&gt;
&lt;li&gt;双向, 互动是关键.&lt;/li&gt;
&lt;li&gt;商业群落是地理围栏的核心, 类似城市的商圈.&lt;/li&gt;
&lt;li&gt;价值整合, 场景整合, 信息流资金流整合是关键.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;geo-fencing-vs-beacons&#34;&gt;Geo-fencing vs Beacons&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mashable.com/2014/02/24/beacons-geofencing-location/&#34;&gt;http://mashable.com/2014/02/24/beacons-geofencing-location/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mobizou.com/geolocation-privacy-gaining-steam/&#34;&gt;http://www.mobizou.com/geolocation-privacy-gaining-steam/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;geo-fencing-applications&#34;&gt;Geo-fencing Applications&lt;/h2&gt;
&lt;h3 id=&#34;百度的地理围栏技术&#34;&gt;百度的地理围栏技术&lt;/h3&gt;
&lt;p&gt;百度地理围栏技术是国内首家提供离线+在线地理围栏服务的产品, 基于位置的提醒和离在线结合的方式, 实现了功耗的大幅降低. 用户离关键位置点较远的时候, 会进行距离判断, 在用户到达围栏周围的时候, 再请求在线定位, 询问用户是否触发围栏.由于用户不需要一直打开GPS, 所以在使用该功能时达到了省流量, 省电的目的.&lt;/p&gt;
&lt;p&gt;百度地理围栏技术&amp;quot;离线+在线&amp;quot;的技术策略, 能够让在用户体验上更为顺畅, 摆脱网络状况的限制, 避免智能手机普遍待机时间短的缺点, 极大提升了地理围栏的工作效率, 因此使用百度定位SDK提供的地理围栏服务的开发者能够设计开发更适合用户需求的产品. 目前, 已经有大量开发者利用百度地理围栏SDK开发相关应用, 精彩创意层出不穷.&lt;/p&gt;
&lt;h3 id=&#34;intel的地理围栏技术&#34;&gt;Intel的地理围栏技术&lt;/h3&gt;
&lt;p&gt;Intel的地理围栏技术采用了有效地将地理信息整合到移动平台的应用中去, 极大提高应用的易用性, 同时权衡系统待机时间与响应时间是Intel地理围栏的关键亮点, 实现了低功耗, 快速响应和高精度三者的完美结合, 其围栏技术的创新点:&lt;/p&gt;
&lt;p&gt;1）使用MCU完成连续监测功能.&lt;/p&gt;
&lt;p&gt;2）基于情境自动甑选合理的位置提供模块.&lt;/p&gt;
&lt;p&gt;3）通过传感器轨迹推算实现实时定位和矫正.&lt;/p&gt;
&lt;p&gt;Intel地理围栏技术亮点包括:&lt;/p&gt;
&lt;p&gt;1）多定位源GNSS/Modem/WiFi.&lt;/p&gt;
&lt;p&gt;2）传感器轨迹推算.&lt;/p&gt;
&lt;p&gt;3）多地理围栏.&lt;/p&gt;
&lt;p&gt;4）情境感知.&lt;/p&gt;
&lt;p&gt;5）自适应.&lt;/p&gt;
&lt;h3 id=&#34;apple的地理围栏---ibeacons技术&#34;&gt;Apple的地理围栏 - iBeacons技术&lt;/h3&gt;
&lt;p&gt;iBeacon的出现让地理定位能够更加精确——从几百米的精度提高到了一米甚至半米. 这个精细度非常高的地理围栏, 终于可以让很多的实际物体都有条件具有了定义自己地理位置标识的能力, 例如一张桌子, 一把椅子, 都可以有自己的地理坐标.&lt;/p&gt;
&lt;p&gt;苹果在iOS 7中推出的iBeacon协议包含两个部分:&lt;/p&gt;
&lt;p&gt;1）按照苹果对iBeacon发射设备的数据流格式, 定制蓝牙设备广播, 那么这台低功耗蓝牙设备就可以被识别为iBeacon协议发射装置.&lt;/p&gt;
&lt;p&gt;2）利用iOS设备对蓝牙的广播发出设备进行判断, 如果其发出的广播数据符合iBeacon的协议, 那么就认为这台低功耗蓝牙的发射装置是一台iBeacon基站.&lt;/p&gt;
&lt;p&gt;由于iBeacon建立在蓝牙协议的基础上, 所以这个技术天然拥有了两个优势:&lt;/p&gt;
&lt;p&gt;1）硬件的无缝过渡, 不需要硬件厂商投入成本进行完全不同的硬件开发.&lt;/p&gt;
&lt;p&gt;2）现有数据传输协议对于用户来说没有太大迁移成本, 完全有能力像智能路由(Wi-Fi协议)一样成为物联网的数据中心节点.&lt;/p&gt;
&lt;h3 id=&#34;其他的地理围栏技术&#34;&gt;其他的地理围栏技术&lt;/h3&gt;
&lt;p&gt;地理围栏技术在10年前便已出现. 在去年的Google IO大会上便已经有了地理围栏的展览.&lt;/p&gt;
&lt;p&gt;Meridian平台便提供Zones地理围栏功能, 这项功能允许用户在开发者推出的室内地图App上随意用多边形圈区域, 而当用户真正到达这些区域时, app会立马推送通知. 除了Meridian, 国外还有几家地理围栏平台, 比如PlaceCast, Digby Localpoint, Wifarer和ShopKick. 和上述几家最大的不同是, Meridian是通过Wifi传感而非GPS定位.&lt;/p&gt;
&lt;p&gt;而Google Lititude API也支持开发者在地图上标记多边形的围栏区域, App进入该趋于时便会收到push消息. 与iBeacons等技术不同的是, 这个push消息不是由基站发送, 而是云端推动的. 跟百度地图的地理围栏技术有些相似.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.leikeji.com/thread-546-1-1.html&#34;&gt;http://www.leikeji.com/thread-546-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning Makefile</title>
      <link>/zh/post/learning-makefile/</link>
      <pubDate>Thu, 05 Jun 2014 01:08:08 +0800</pubDate>
      <guid>/zh/post/learning-makefile/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_makefile/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;系统的学习了一下Makefile, 隐含规则部分没有详细看, 实际使用过程中也不会依靠这个东西的.&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;跟我一起学Makefile&lt;/li&gt;
&lt;li&gt;GNU Makefile Reference: &lt;a href=&#34;http://www.gnu.org/software/make/manual/make.html&#34;&gt;http://www.gnu.org/software/make/manual/make.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;另一个淘宝前辈的总结(简单向, 我的更偏向深入一些): &lt;a href=&#34;http://kenwublog.com/arrange-makefile-knowledges&#34;&gt;http://kenwublog.com/arrange-makefile-knowledges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;调试makefile: &lt;a href=&#34;http://coolshell.cn/articles/3790.html&#34;&gt;http://coolshell.cn/articles/3790.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;偶遇的好东西&#34;&gt;偶遇的好东西&lt;/h2&gt;
&lt;p&gt;自主学习的一个好处就是, 在研究的过程中会发现很多好玩的东西.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All Cheat Sheets in one page: &lt;a href=&#34;http://www.cheat-sheets.org/&#34;&gt;http://www.cheat-sheets.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个更加牛逼的东西, 在任何软件界面下按住command键不放即可显示快捷键 &lt;a href=&#34;http://www.mediaatelier.com/CheatSheet/&#34;&gt;http://www.mediaatelier.com/CheatSheet/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PopClip, 一个效率工具吧.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Root Nook Simple Touch</title>
      <link>/zh/post/root-nook-simple-touch/</link>
      <pubDate>Sat, 31 May 2014 23:14:24 +0800</pubDate>
      <guid>/zh/post/root-nook-simple-touch/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nookmanager-success.jpg&#34; alt=&#34;nookmanager-success&#34;&gt;&lt;/p&gt;
&lt;p&gt;今天断网了大半天, 然后玩了一会Calibre, 翻出了我的Nook3, 刚好利用这个假期打算把他root掉.&lt;/p&gt;
&lt;h2 id=&#34;使用nookmanager进行root&#34;&gt;使用NookManager进行root&lt;/h2&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;固件升级到官方1.2.1(我的原来是1.1.5的, 如果不升级那么root时会ModManager会安装失败)&lt;/li&gt;
&lt;li&gt;下载NookManager.img.&lt;/li&gt;
&lt;li&gt;使用dd命令将NookManager.img写入一个空的sd卡中.(我用Mac OS X系统, linux下类似, win下用相应工具)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ ls /dev/disk*
/dev/disk0   /dev/disk0s1 /dev/disk0s2 /dev/disk0s3 /dev/disk1   /dev/disk1s1
akagi201@akrmbp ~ $ sudo diskutil umount force /dev/disk1s1
Volume (null) on disk1s1 force-unmounted
akagi201@akrmbp ~ $ sudo dd if=/Users/akagi201/Downloads/NookManager.img of=/dev/disk1 bs=1m
64+0 records in
64+0 records out
67108864 bytes transferred in 49.549986 secs (1354367 bytes/sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;关掉Nook的电源, 插入sd卡, 然后开机, 会显示15秒的NookManager的信息.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nookmanager-start.jpg&#34; alt=&#34;nookmanager-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;选择&amp;quot;No, continue without wireless&amp;rdquo;, 选yes需要刷机之前设备有连过你附近的ap, 才能验证通过.(这个其实可以改进啦)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nookmanager-wifi.jpg&#34; alt=&#34;nookmanager-wifi&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;使用NookManager做一次备份! Rescue -&amp;gt; Backup -&amp;gt; Format remaining space on SD card -&amp;gt; Create backup. (需要花费15~45分钟, 最终备份文件大小是几百M)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nookmanager-backup.jpg&#34; alt=&#34;nookmanager-backup&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;使用USB线连接电脑和nook, 拷贝NookBackup分区下的backup.full.gz和backup.full.md5到电脑, 最好上传到网盘备份好.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Root! 备份之后, Back -&amp;gt; Back -&amp;gt; Main Menu -&amp;gt; Root -&amp;gt; Root my device (然后看到全是成功, 如果不成功说明你用其他方法root过或者没有升级到官方的1.2.1)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nookmanager-root.jpg&#34; alt=&#34;nookmanager-root&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/nookmanager-success.jpg&#34; alt=&#34;nookmanager-success&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;Back -&amp;gt; Exit -&amp;gt; 拔出SD卡 -&amp;gt; 设备自动重启 -&amp;gt; 选择Relaunch. 搞定.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://forum.xda-developers.com/showthread.php?t=2040351&#34;&gt;http://forum.xda-developers.com/showthread.php?t=2040351&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nookdevs.com/Nook_Simple_Touch/Rooting&#34;&gt;http://nookdevs.com/Nook_Simple_Touch/Rooting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Wireless Penetration</title>
      <link>/zh/post/wireless-penetration/</link>
      <pubDate>Wed, 28 May 2014 15:28:26 +0800</pubDate>
      <guid>/zh/post/wireless-penetration/</guid>
      <description>&lt;p&gt;src=&amp;quot;https://atlas.mindmup.com/akagi201/wireless_penetration/index.html&amp;rdquo; height=&amp;quot;100%&amp;rdquo; width = &amp;ldquo;100%&amp;ldquo;&amp;gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;之前
&lt;a href=&#34;http://www.zhihu.com/people/Akagi201&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;知乎&lt;/a&gt;
上有人私信我, 问我无线安全都需要了解哪些东西, 如何去学, 当时没有给他一个好的答案, 最近在研究无线安全攻防方面的东西, 刚好看到一个不错的东西整理一下框架, 然后, 慢慢补充细节.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.wirelessdefence.org&#34;&gt;http://www.wirelessdefence.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>无线基础之无线网卡</title>
      <link>/zh/post/wireless-device/</link>
      <pubDate>Mon, 05 May 2014 07:14:26 +0800</pubDate>
      <guid>/zh/post/wireless-device/</guid>
      <description>&lt;p&gt;今天利用一个上午的时间把gentoo装好了, 昨天因为网线的原因导致我这边网络一直超时, 郁闷死我了, 多亏我今天足智多谋发现了. 由于OpenWrt的代码仓库版本更新非常频繁, 所以开发分支里面的库和内核版本比一般的桌面linux发行版都要新. 有一个基本常识是host开发主机上面的库和编译工具版本要比源码使用的版本新, 否则就会出现一些奇怪的问题, 无法解决. 所以, 选择一个滚动升级的linux发行版用于开发是明智的选择(相信我, 不难的). 这样筛选后就只剩下Arch和Gentoo了, Arch比较不稳定(希望不被喷, Arch的wiki跟Gentoo一样丰富是好东西), 所以Gentoo是你最明智的选择.用Gentoo编译了一下openwrt, 比我之前用debian节省了至少一半的时间, 哈哈, 爽. BTW, 不要给Gentoo安装图形界面, 很废时间, 也会出现很多冲突, 那就需要你身边有个高手了(我还不是要靠低调之神Yokit的帮忙才解决一些问题).&lt;/p&gt;
&lt;p&gt;在进入无线研究之前你需要一套趁手的装备, 这套装备包括硬件和软件, 当然这个也就是我们要做的东西, 其中必然涉及一些硬件和软件的选型. 本文重点介绍一下网卡芯片的选型与相关知识.&lt;/p&gt;
&lt;h2 id=&#34;常见网卡接口&#34;&gt;常见网卡接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Peripheral_Component_Interconnect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PCI&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/USB&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;USB&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/PC_card&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PCMCIA&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Mini_PCI#Mini_PCI&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mini PCI&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/PCI_Express_Mini_Card#PCI_Express_Mini_Card&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PCI Express Mini&lt;/a&gt;
.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;底层芯片组&#34;&gt;底层芯片组&lt;/h2&gt;
&lt;p&gt;无论使用哪种接口的网卡, 他们的核心都是&amp;quot;芯片组&amp;rdquo;. 这采集关键所在, 我们要关注的电气性能也是针对芯片组的. 目前常见的WLAN芯片厂商有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;https://wikidevi.com/wiki/Atheros&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Atheros(已被高通收购)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://zh-cn.broadcom.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Broadcom(博通)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.intel.com/content/www/us/en/wireless-network/wireless-products.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Intel&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.ralinktech.com/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ralink(已被联发科收购)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.realtek.com.tw/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Realtek&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;驱动程序&#34;&gt;驱动程序&lt;/h2&gt;
&lt;p&gt;由于芯片的性能跟驱动的支持是分不开的, 所以, 良好的驱动支持, 也是我们要重点考虑的一项参数.
linux内核当前无线网卡驱动架构说明:
&lt;img src=&#34;http://akagi201.qiniudn.com/mac80211.bmp&#34; alt=&#34;mac80211&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到linux下的无线驱动程序经过了一段&amp;quot;发展期&amp;rdquo;, 最终以&amp;quot;mac80211驱动框架&amp;quot;作为最终的&amp;quot;主树结构&amp;rdquo;.
关于mac80211驱动框架的详细文档请查看: &lt;a href=&#34;http://wireless.kernel.org/en/developers/Documentation/mac80211&#34;&gt;http://wireless.kernel.org/en/developers/Documentation/mac80211&lt;/a&gt;.
mac80211是一个无线驱动的框架, 它提供了大量的API, 规范, 在这个框架下编写驱动程序能和其他的驱动具有良好的共享性, 兼容性(类似与windows下的NDIS框架的作用).&lt;/p&gt;
&lt;p&gt;一般来说, 各家芯片厂商都会提供配套的驱动程序, 并提供更新支持&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Atheros(AR系列)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://www.qca.qualcomm.com/resources/driverdownloads/&amp;gt;
&amp;lt;http://wireless.kernel.org/en/users/Drivers/Atheros&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Broadcom(BCM系列)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://zh-cn.broadcom.com/support/802.11/linux_sta.php&amp;gt;
&amp;lt;http://wiki.centos.org/zh/HowTos/Laptops/Wireless/Broadcom&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Intel&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://wireless.kernel.org/en/users/Drivers/iwlwifi&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Ralink(RT系类)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://www.mediatek.com/en/downloads/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;淘宝上卖的很多卡皇的内置芯片就是这种RT型号(所谓卡皇就是无良厂家违规的放大了无线发射功率, 大家还是慎重考虑, wifi近距离接触(贴着身体)还是有危害的, 通常半米到1米左右还是可以认为是安全的)&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Realtek(RTL系列)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://www.realtek.com.tw/DOWNLOADS/downloadsView.aspx?Langid=1&amp;amp;PNid=14&amp;amp;PFid=7&amp;amp;Level=5&amp;amp;Conn=4&amp;amp;DownTypeID=3&amp;amp;GetDown=false&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的, 我们在选择驱动的时候需要关注一下当前驱动是否支持USB(因为现在大多数人包括我自己都是使用外置网卡进行实验的).&lt;/p&gt;
&lt;h2 id=&#34;待续&#34;&gt;待续&lt;/h2&gt;
&lt;p&gt;上面我们提到过, 不同型号的网卡的&lt;em&gt;主要差别&lt;/em&gt;在于内置的芯片组, 但是, 一个无线网卡的好坏除了和上面说的芯片组, 驱动有关外, 还和他自身的一些物理, 电气特性有关, 下一篇我们会进一步与大家交流.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Wireless_network_interface_controller&#34;&gt;http://en.wikipedia.org/wiki/Wireless_network_interface_controller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freebuf.com/articles/wireless/33524.html&#34;&gt;http://www.freebuf.com/articles/wireless/33524.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/sudochen/article/details/8889719&#34;&gt;http://blog.csdn.net/sudochen/article/details/8889719&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;signature&#34;&gt;Signature&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Author: Akagi201(我的微信, 加我请注明: 真实姓名-公司/专长)&lt;/li&gt;
&lt;li&gt;Blog: &lt;a href=&#34;http://akagi201.org&#34;&gt;http://akagi201.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;AK创客空间qq群: 212106391 (加群暗号: ak)&lt;/li&gt;
&lt;li&gt;请支持本微信公众号, 分享给你的朋友们: AKmaker&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning Kernel</title>
      <link>/zh/post/learning-kernel/</link>
      <pubDate>Thu, 01 May 2014 06:14:08 +0800</pubDate>
      <guid>/zh/post/learning-kernel/</guid>
      <description>&lt;p&gt;我是从大二开始使用linux系统的, 当时除了玩单片机之外, 所有工作完全在linux完成, 克服了种种&amp;quot;困难&amp;rdquo;. 不过现在看来自己除了佩服自己当时的热情之外, 就只觉得自己太幼稚了. &amp;ldquo;在正确的时间做正确的事情, 用正确的工具做正确的事情.&amp;rdquo; 就像以前一直很偏爱C语言一样, 一定要写成内核模块, 内核线程&amp;hellip; 现在自己变得更加聪明了.&lt;/p&gt;
&lt;p&gt;我大学期间一直没有机会碰linux内核, 只有在大三下的时候, 在实验室玩ARM开发板, 才知道, 原来linux内核做了这么多的工作, 一个hello world能够轻松的运行起来, 背后有多少的东西在默默无闻的工作着.&lt;/p&gt;
&lt;p&gt;毕业后我按照自己的规划找了一份嵌入式软件开发的工作. 公司也还算给力, 给了我足够的时间来学习. 我当时是从驱动入手的, 主要看了一本书和一个英文文档, 分别是LDD3和LKMPG. 这本书我前段时间又看了一遍, 觉得这个不适合一个新手看, 难怪我当初看的那么累, 原因有是作者在书内容里无缝地介绍了软件架构, 代码复用等等对于新手来说高级的东西, 这些应该属于软件工程的内容, 这样当然有好处, 但是给人感觉就是复杂, 相比之下国内的书会简单直接很多. 另外LDD3是基于2.6内核的API写的驱动, 已经有大牛移植到linux3.x上面了.&lt;/p&gt;
&lt;p&gt;其实, 内核代码发展很快, 差几个版本基本就面目全非了, 所以, 要多看, 多思考, 有整体把握. 这样, 过段时间拿到最新的代码了, 自己也有能力跟踪进去.&lt;/p&gt;
&lt;p&gt;最近, 在linux社区上面看了几篇有趣的东西, 在HN上貌似也火了一下, 所以, 分享出来给大家玩下.&lt;/p&gt;
&lt;h2 id=&#34;eudyptula&#34;&gt;Eudyptula&lt;/h2&gt;
&lt;p&gt;模仿Matasano Crypto Challenge(集中48小时的练习, 培训参与者密码系统如何建立以及如何被攻击), 面向linux内核的一系列编程练习, 任务难度逐渐增加. 一切是从给little@eudyptula-challenge.org发一封邮件说你要加入开始的. 由于实际的内核开发就是通过邮件列表沟通的, 所以, 必须要熟悉邮件工具是必备技能.&lt;/p&gt;
&lt;p&gt;PS: 由于我发了邮件他还没回我, 呵呵, 后面等做了几个任务之后再跟大家分享一下.&lt;/p&gt;
&lt;h2 id=&#34;kernel-101&#34;&gt;Kernel 101&lt;/h2&gt;
&lt;p&gt;这篇文章最近在HN上比较火, 教你从0开始写一个kernel, 当然功能仅仅是打印一行信息而已. 对于新手来说还是比较好的学习材料. 源码就2个文件, 一段汇编主要功能就是跳转到C程序的kmain函数; 一段C代码, 将显存内容清空并赋值为一段字符串.&lt;/p&gt;
&lt;p&gt;其中几个关键知识点记录一下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x86的CPU启动后从地址[0xFFFFFFF0]处开始执行, 这个是设计CPU时写死的. 从芯片手册上可以查到. 下面提到的一些地址都是芯片手册中规定统一的, 所以x86架构才能够通用, 各种OS都能安装, 不需要繁琐的移植工作.&lt;/li&gt;
&lt;li&gt;启动流程: 上电 -&amp;gt; CPU[0xFFFFFFF0] -&amp;gt; 跳转到内存中BIOS代码 -&amp;gt; 根据BIOS配置将物理设备第一个扇区的代码copy到物理内存的[0x7c00]位置(即boot loader的代码) -&amp;gt; bootloader将内核代码加载到物理内存[0x100000](x86 CPU宏内核代码起始地址, 也就是后面我们编写的汇编程序的链接地址).&lt;/li&gt;
&lt;li&gt;汇编代码中使用了一些nasm的伪指令, 所以, um, 看注释就好.&lt;/li&gt;
&lt;li&gt;通常的内核开发还需要提供一个根文件系统文件的, 这个简单例子是不包含文件系统的.&lt;/li&gt;
&lt;li&gt;grub2下添加引导项的方法, 成败在于此, 需要注意你的/boot分区是否是一个独立分区, 如果不是独立分区那么ok, 安装作者的文章搞起; 如果你像我一样安装系统时候将/boot独立一个256M空间的分区, 那么要内核文件位置使用相对/boot相对地址. 另外注意, 要使用msdos2, 否则会失败.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$sudo vim /boot/grub/grub.conf

//在文件中其他引导项下面添加如下
menuentry &#39;Akagi201 Lovely Kernel&#39; {
    set root=&#39;hd0,msdos2&#39;
    multiboot /kernel-7001 ro
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;what-my-new-born-kernel-says&#34;&gt;What my new-born kernel says&lt;/h2&gt;
&lt;p&gt;um, 我改了一下颜色, 跟字符内容, 哈哈, 没啥技术含量啦!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/akgrub.png&#34; alt=&#34;akgrub&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/akkernel.png&#34; alt=&#34;akkernel&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;links&#34;&gt;links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Linux Kernel Module Programming Guide: &lt;a href=&#34;http://tldp.org/LDP/lkmpg/2.6/html/&#34;&gt;http://tldp.org/LDP/lkmpg/2.6/html/&lt;/a&gt; 看完这个你就能让内核输出hello world啦.&lt;/li&gt;
&lt;li&gt;LDD3-examples-3.x: &lt;a href=&#34;https://github.com/duxing2007/ldd3-examples-3.x&#34;&gt;https://github.com/duxing2007/ldd3-examples-3.x&lt;/a&gt; 你应该会注意到不同的branch对应不同的内核版本, 很赞吧!&lt;/li&gt;
&lt;li&gt;kernel 101 on HN: &lt;a href=&#34;https://news.ycombinator.com/item?id=7588205&#34;&gt;https://news.ycombinator.com/item?id=7588205&lt;/a&gt; 有人还做了FUSE版本, 作者也要出ARM版本了, 可以关注下, 上面作者有更多的细节解释.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>保护你的隐私, 从PGP开始</title>
      <link>/zh/post/protect-your-privacy-with-pgp/</link>
      <pubDate>Sat, 29 Mar 2014 07:11:08 +0800</pubDate>
      <guid>/zh/post/protect-your-privacy-with-pgp/</guid>
      <description>&lt;p&gt;以前大学还在玩ubuntu的时候, 天天逛ubuntu的中文论坛, 看到这么个家伙, &lt;a href=&#34;http://adam8157.info/about&#34;&gt;http://adam8157.info/about&lt;/a&gt;, 他的about页面一直放了一个&lt;code&gt;My PGP/GPG key ID: 2F39D84D&lt;/code&gt;, 我一直不知道是干什么用的, 我还特意到知乎上问了一下, 不过貌似知乎对这么被认为是可google的问题没兴趣(对八卦和吐槽感兴趣?), 没得到满意答案, 今天有个空挡, 还是自己研究下.&lt;/p&gt;
&lt;p&gt;PGP(OpenPGP)是一个历史悠久的电子加密和签章系统, 透过public key加密演算法, 保护个人电子资料, 不会在散布过程或存储媒体中被有心者窥视, 破坏或伪装. 不同于一般以CA(Certificate Authority, 认证机构)为基础的签章, 加密系统, PGP是分散式的系统, PGP没有中央的控制或信任机构, 因此不会被政府, 少数机构所控制,入侵. 在这个公权力无法被信任的年代, 我们正需要这样的系统, 保护我们的通讯安全.&lt;/p&gt;
&lt;h2 id=&#34;web-of-trust&#34;&gt;Web Of Trust&lt;/h2&gt;
&lt;p&gt;PGP是透过所谓的web of trust, 建构信任网. 也对于, 透过人际网路, 一对一的交换PGP key(public key), 安全的通讯管道, 建立在人和人之们的信任感上. 相对的, 以CA为基础的系统, 是透过少数集中的组织, 交换public key. 因此, CA容易受政府或少数机构的控制, 而破坏其安全性. 而web of trust则没这样的问题, 没有中央机构可以伪造你的PGP key. PGP的使用者, 透过web of trust确保所使用的 key, 不是政府或第三方所伪造的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web Of Trust的运作: &lt;a href=&#34;http://www.pgpi.org/doc/pgpintro/#p20&#34;&gt;http://www.pgpi.org/doc/pgpintro/#p20&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;伪造public-key&#34;&gt;伪造Public Key&lt;/h2&gt;
&lt;p&gt;CA为基础的系统, Public Key的散布是透过CA对Public Key进行签名. CA会有一份公开的Public Key, 透过使用对应的secret key对某Public Key签名, 由CA保证其正确性. 而使用者, 透过验证通讯对方的Public Key是否有CA的正确签名, 确保使用正确的Public Key. 这样的系统, 建立在对CA的信任, 因此CA必需是公信的第三者. 然而, 事实上没有绝对公信的第三者, 政治力量随时可能入侵CA, 透过CA的Key, 伪造任何人的Public Key. 因此, 像CA这类中央式的系统, 容易受外力影向, 进行大规模隐私侵害, 无法保护通信的自由和隐密. 事实上, 中国某CA运作单位, 就被怀疑有这种
&lt;a href=&#34;http://blog.nutsfactory.net/2010/02/02/remove-cnnic-cert-on-linux/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可能&lt;/a&gt;
.&lt;/p&gt;
&lt;h2 id=&#34;pgp工具&#34;&gt;PGP工具&lt;/h2&gt;
&lt;p&gt;PGP系统的实现, 有两项主要工具, PGP和GPG. PGP是原先的实现, 而GPG则是GNU实现的相容工具, 和PGP相容. 本文介绍GPG的使用.&lt;/p&gt;
&lt;h2 id=&#34;产生pgp-key&#34;&gt;产生PGP Key&lt;/h2&gt;
&lt;p&gt;GPG基本上会产生两对key, 一组用来sign(签章), 另一组用来encrypt(加密).  Encryption用途的key, 因为比较常被使用, 因此较容易受攻击. (透过分析加密的样本, 数量愈多, 愈可能分析出原本的key.) 因此, 一般建议定期更换加密用的 key. 然而, 更换key非常麻烦, 必需一一重新和拥有你的key的朋友交换. 因此, 签章用途的key通常是和加密用途的key分开的. 签章用途的key较少使用, 因此较不易被破解, 通常是永久使用. 在你更换新加密用途的key时, 能够使用签章用途的key, 为新的key签名. 因此, 你可以透过email或其它网路的方式散布你加密用途的新key. 收到新key的朋友, 就可以使用你签章用途的key, 验证你的新key.&lt;/p&gt;
&lt;p&gt;产生新的PGP key的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 两种安装方法
#1. brew install gnupg # 命令行和linux完全一样
#2. https://gpgtools.org/ # GUI界面, 其实命令行就够了

akagi201@akrmbp ~ $ gpg --gen-key
gpg (GnuPG) 1.4.16; Copyright (C) 2013 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

gpg: directory `/Users/akagi201/.gnupg&#39; created
gpg: new configuration file `/Users/akagi201/.gnupg/gpg.conf&#39; created
gpg: WARNING: options in `/Users/akagi201/.gnupg/gpg.conf&#39; are not yet active during this run
gpg: keyring `/Users/akagi201/.gnupg/secring.gpg&#39; created
gpg: keyring `/Users/akagi201/.gnupg/pubring.gpg&#39; created
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 4
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048)
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      &amp;lt;n&amp;gt;  = key expires in n days
      &amp;lt;n&amp;gt;w = key expires in n weeks
      &amp;lt;n&amp;gt;m = key expires in n months
      &amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0)
Key does not expire at all
Is this correct? (y/N) y

You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
    &amp;quot;Heinrich Heine (Der Dichter) &amp;lt;heinrichh@duesseldorf.de&amp;gt;&amp;quot;

Real name: Akagi201
Email address: akagi201@gmail.com
Comment: Bob Liu
You selected this USER-ID:
    &amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
You need a Passphrase to protect your secret key.

We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
...+++++
..+++++
gpg: /Users/akagi201/.gnupg/trustdb.gpg: trustdb created
gpg: key BAD7F7A3 marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   2048R/BAD7F7A3 2014-05-27
      Key fingerprint = E19A 2B9C B30F 8D0E 3F14  8C9F 7BAA 088C BAD7 F7A3
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;

Note that this key cannot be used for encryption.  You may want to use
the command &amp;quot;--edit-key&amp;quot; to generate a subkey for this purpose.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议选(3)或者(4)(我选了4), 产生只用来签章的key, 并将有效时间设定为永远. 在产生签章用途的key之后, 该key会存在keyring里, 通常是home目录下的.gnupg 子目录, 你能用gpg列出目前存在的key.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --list-keys
/Users/akagi201/.gnupg/pubring.gpg
----------------------------------
pub   2048R/BAD7F7A3 2014-05-27
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;

akagi201@akrmbp ~ $ gpg --list-secret-keys
/Users/akagi201/.gnupg/secring.gpg
----------------------------------
sec   2048R/BAD7F7A3 2014-05-27
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这列出你有一把PGP的Public Key, 接着列出你有一把Secret Key. 这两把key的ID都是0xBAD7F7A3(第二栏, 斜线后), 代表他们是同一对key. Secret Key是使用者收藏(前面有sec字样), 不能让别人知道的部分, 用在签名用途. 而public key则是公开给别人知道(pub字样), 用来验证你的签名.&lt;/p&gt;
&lt;p&gt;接着我们要产生加密用途的key.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --edit-key BAD7F7A3
gpg (GnuPG) 1.4.16; Copyright (C) 2013 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Secret key is available.

pub  2048R/BAD7F7A3  created: 2014-05-27  expires: never       usage: SC
                     trust: ultimate      validity: ultimate
[ultimate] (1). Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;

gpg&amp;gt; addkey
Key is protected.

You need a passphrase to unlock the secret key for
user: &amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot;
2048-bit RSA key, ID BAD7F7A3, created 2014-05-27

Please select what kind of key you want:
   (3) DSA (sign only)
   (4) RSA (sign only)
   (5) Elgamal (encrypt only)
   (6) RSA (encrypt only)
Your selection? 6
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048)
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      &amp;lt;n&amp;gt;  = key expires in n days
      &amp;lt;n&amp;gt;w = key expires in n weeks
      &amp;lt;n&amp;gt;m = key expires in n months
      &amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0) 2y
Key expires at Thu May 26 10:59:08 2016 CST
Is this correct? (y/N) y
Really create? (y/N) y
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
..+++++
.+++++

pub  2048R/BAD7F7A3  created: 2014-05-27  expires: never       usage: SC
                     trust: ultimate      validity: ultimate
sub  2048R/6E980A59  created: 2014-05-27  expires: 2016-05-26  usage: E
[ultimate] (1). Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;

gpg&amp;gt; quit
Save changes? (y/N) y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请选择(5)或(6)(这里我选择了6), 产生专用来加密用的public key. 这里将有效时间设为两年(2y), 可依据需要设定. 完成之后, 会看到一把subkey(前面有sub字样), 这里得到的key ID为0x6E980A59. 0x6E980A59为0xBAD7F7A3的subkey. 0x6E980A59的有效期限为2年, 因此, 两年之后你必须生成一把新的key, 以取代这把.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kagi201@akrmbp ~ $ gpg --list-sigs
/Users/akagi201/.gnupg/pubring.gpg
----------------------------------
pub   2048R/BAD7F7A3 2014-05-27
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
sig 3        BAD7F7A3 2014-05-27  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
sub   2048R/6E980A59 2014-05-27 [expires: 2016-05-26]
sig          BAD7F7A3 2014-05-27  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以看到, 0xBAD7F7A3和0x6E980A59这两把key都用0xBAD7F7A3这把key签章过(前面有sig字样). 也就是0xBAD7F7A3 有一个self-sign, 自已签自己.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --armor --export BAD7F7A3
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1

mQENBFOD/ZQBCADQNTAV2KI+37d/Ep1ginwR2AoMTPe4AbhGVBr5LJsWbrW/y/Ap
Fyar6eAcT2OLAASpAyJNZpGxrG5QmKRjvcC/Bdx4mudWExs1o3aUwGIeCCUBVBdj
r0g2kZji/UbuaArRWVBotl/DIqvYswKM762FnQoOKTlMlj45U1dY1WS2ZP8KFhHV
5RWqJknY8p42QC5Tl09m7TCxkAz7ms+qU8Ya6Af4vLdSo8V7bpbATD2BQtPTpfZt
3z9rezvDRcsWK4O3Cmx5z+Q6HjQZV7Wbg2L3Q0yUzHktMM997WmRlT3zyUYXeAxG
wZSAGKcVd4gvHOLiRB5GyuYr8lIQH0GN/uCzABEBAAG0J0FrYWdpMjAxIChCb2Ig
TGl1KSA8YWthZ2kyMDFAZ21haWwuY29tPokBOAQTAQIAIgUCU4P9lAIbAwYLCQgH
AwIGFQgCCQoLBBYCAwECHgECF4AACgkQe6oIjLrX96OgqggAr21OZvGgqwo59G7H
9QGjwVD5OliJgAUuykEuzCv4ATKm+7Y/g/HgGUqIILKzknOPCe2VGTs+6RA98zWk
9nbdCUEu7oUZTBYq5h1uuPkm4FoJyyrwatSNChqJ4qav6jpZDqGnHwNeEwdY1WNG
uoC+MDM38u5KET6TnqYgmd5B0HWlUuiUx57uKE70vPRpziNDloeLzKdfD0fibKHN
ZFOgJJZkoPhr/yigqmQEfdrajTY4YGEy/2HYIULZYQs0paRe0SVw0UqbDZanOvlr
KOv6XFtH66DjY0pTgUWUXfGylzJAAtgQXQOFDXURC2oYG9DRkvA8q5gaZpqJT4f9
3Awk0bkBDQRTg/98AQgAwTKF9C/72yRmtTVaLziH93eKSc8jKOPt+Ncio5l+Bdhj
lJqJLzQWBB8uRa76wcTKMUpPMOPAMYqZjMekbVIrKFfNHh3pD+y90M/rDkhM2M4Z
gV6XtHnjqhQ4woqejM6k1ADKgndZNoau0TlJ7TagPM33Nay43vHo/BPcx6rs4Ssa
oSnv0sf4PBJeDfhjna+LVAQ18/rPBRijL/Xh6Bn2PWTrmF59g2mmdzV3WMOMsC+I
VkuXP20Vg4B0hFi6t9Hx/B5JL9t/xEEo2YKRyia8F4vtraSlhbMwVnfPfWuG5YSh
AsBa1ByLxCbNdELoLwU69ZDmgFH2x8JdUcm2vslwLwARAQABiQElBBgBAgAPBQJT
g/98AhsMBQkDwmcAAAoJEHuqCIy61/ejD9MH/A3vij2gjaLl3u1CAQB6n8DUSiyr
+bzEkoLHcJDYAM49oM3GPnkCSLJVM7EYmnlR6GOO4PwXlr2GjoxIer+MDCJ8hq98
n+H/2kgV8me/DDSoI1WUiIrcVLBcvylqZv3UWN4Vz+hP48iS/CEtPO6up/l3UAL3
YMWpi96+pnPodjMXL8JcIHlvx8Syxz1J0REI1J7uiGqzvJ9wu4ASYAHtJgi3qsvS
0FvAJcbdWMRNs51Pi0C1SYeztV7yRih8lTjI9ylUoncY5nKPtHrXjCNfpe0fClHx
JLz3WwlAX8gFyM3C+dl/622e7EvK9hO/spn8kS3lHD3q2V3t8GtSM4RzsY4=
=G9Ls
-----END PGP PUBLIC KEY BLOCK-----
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;透过上面的指令, 你能将你的public key export出来(导出), 印在纸上, 或存在U盘上, 或者是贴在网路上散布. 然而, 别人如何确定这把key是你的?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --fingerprint
/Users/akagi201/.gnupg/pubring.gpg
----------------------------------
pub   2048R/BAD7F7A3 2014-05-27
      Key fingerprint = E19A 2B9C B30F 8D0E 3F14  8C9F 7BAA 088C BAD7 F7A3
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
sub   2048R/6E980A59 2014-05-27 [expires: 2016-05-26]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面指令能列出你的public key的fingerprint(指纹)印出来, 这相当于public key浓缩之后的特征(digest). 因此, 其它使用者只需比对这组fingerprint是否和public key的相符, 就能确定这把key的正确性. 因此, 通常你会把fingerprint 印在纸上, 面对面交给对方. 必要时, 还会检查对方的身份证, 护照或其它身份证明文件.&lt;/p&gt;
&lt;h2 id=&#34;交换key&#34;&gt;交换key&lt;/h2&gt;
&lt;p&gt;在开始交换key之前, 建议先把你的public key上传到key server, 别人只需从key server上下载你的key. key server 是由第三方所维护的, 只负责key的散布, 而不负责签名, 因此不会有前面所述伪造的问题.&lt;/p&gt;
&lt;p&gt;如下, 上传 0xBAD7F7A3这把key.(注意, 这里需要把shell的http代理关掉,否则上传失败) 上传完之后可以到&lt;a href=&#34;http://keys.gnupg.net/&#34;&gt;http://keys.gnupg.net/&lt;/a&gt;查询.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --send-keys BAD7F7A3
gpg: sending key BAD7F7A3 to hkp server keys.gnupg.net
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后, 你只需告诉别人你的key id和fingerprint, 其它使用者就能下载和验证完整的public key.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --recv-keys BAD7F7A3
gpg: requesting key BAD7F7A3 from hkp server keys.gnupg.net
gpg: key BAD7F7A3: &amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot; not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
akagi201@akrmbp ~ $ gpg --fingerprint
/Users/akagi201/.gnupg/pubring.gpg
----------------------------------
pub   2048R/BAD7F7A3 2014-05-27
      Key fingerprint = E19A 2B9C B30F 8D0E 3F14  8C9F 7BAA 088C BAD7 F7A3
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
sub   2048R/6E980A59 2014-05-27 [expires: 2016-05-26]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如, 本人的key ID是 0xBAD7F7A3. User ID为&amp;quot;Akagi201 (Bob Liu)&amp;quot;(前有uid字样). 你可以透过上面的指令下载我的 public key, 并验证fingerprint.&lt;/p&gt;
&lt;p&gt;在下载和验证完成别人的public key之后, 若对方是你信任的人, 你可以为他的key签名. 当你为别人的key签名之后, 对方可以分布你的签名, 加强他的public key的可信度, 于是认识你的朋友, 可以依据你的签名, 决定是否相信该public key. 你也可以依据朋友的签名, 决定是否相信其它人的 public key.(下面的例子中我自己没法再给我自己签名了)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --sign-key BAD7F7A3

pub  2048R/BAD7F7A3  created: 2014-05-27  expires: never       usage: SC
                     trust: ultimate      validity: ultimate
sub  2048R/6E980A59  created: 2014-05-27  expires: 2016-05-26  usage: E
[ultimate] (1). Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;

&amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot; was already signed by key BAD7F7A3
Nothing to sign with key BAD7F7A3

Key not changed so no update needed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的指令将使用你的secret key, 为 0xBAD7F7A3这把public key签章. 签完之后, 就可以看到0xBAD7F7A3这把key 多了一个签名. 你能将这个签名后的public key(再次)上传到key server, 或export成档案散布. 通常该public key 的原拥有者, 会希望取得你的签名.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --list-sigs
/Users/akagi201/.gnupg/pubring.gpg
----------------------------------
pub   2048R/BAD7F7A3 2014-05-27
uid                  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
sig 3        BAD7F7A3 2014-05-27  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
sub   2048R/6E980A59 2014-05-27 [expires: 2016-05-26]
sig          BAD7F7A3 2014-05-27  Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;加密&#34;&gt;加密&lt;/h2&gt;
&lt;p&gt;当你想要传送机密资料给其它人时, 可使用对方的public key为信件和资料加密. 只有对应的secret key, 才能解开该份信件或资料.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ gpg --armor --encrypt --output akmsg.asc akmsg.txt
You did not specify a user ID. (you may use &amp;quot;-r&amp;quot;)

Current recipients:

Enter the user ID.  End with an empty line: Akagi201

Current recipients:
2048R/6E980A59 2014-05-27 &amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot;

Enter the user ID.  End with an empty line:
akagi201@akrmbp ~ $ cat akmsg.asc
-----BEGIN PGP MESSAGE-----
Version: GnuPG v1

hQEMA4V0fiJumApZAQgAq5In+b2OiG7ruCfhbycUEUKgSTGrcSdErFuWHbWKpcSj
xItKaJX6s5FGGG01p4Q9h/kYzhOzwnxHmMDFszzcW9cxBSPXES5qpGJd5lO0PTCX
t7yma4geYmFG1zajkJzsnVyJl4NTvfnMgRcAKRqD5QZuo6vQNaURGsDtwcqY/iRt
6wD958HnBr3+OGkP6KCsjbhYsOrIaVnnfF0TEK0cxyCgu2743O8F9rwhwwTVBCMU
qHRXaHjRaGysflcnXlqHVRbHFYKTg+Mo2K2avricTKzu/bdV6J1jeCkqfXrbGKqD
aDxCmYZH1y7JmBNJJhYaWlth0b3Ir26+kO/RSOji2NJRAcJ1/bZK6uROY1LeuMps
G0zdH0ODNvV/sAe+9C23CqGFXrN/z4XdEHR1WyU3ZWUrPnEP4Z1hkQ2zy8ncy32I
92E6SyWit6R7KNbhHu8/A7jt
=F1tG
-----END PGP MESSAGE-----
akagi201@akrmbp ~ $ cat akmsg.txt
This is secret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如上面的指令, 使用0x6E980A59这把key(0xBAD7F7A3的subkey), 将akmsg.txt这份文件加密, 并存成akmsg.asc. 上面指令中, 只需输入对方的email address或者user ID(uid), 就会从你的keyring中, 找出对方用来加密的public key.&lt;/p&gt;
&lt;h2 id=&#34;解密&#34;&gt;解密&lt;/h2&gt;
&lt;p&gt;在你收到加密的文件时, 只需使用下面指令就可以使用存在keyring里的secret key, 为文件解密.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akagi201@akrmbp ~ $ rm akmsg.txt
akagi201@akrmbp ~ $ gpg --decrypt --output akmsg.txt akmsg.asc

You need a passphrase to unlock the secret key for
user: &amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot;
2048-bit RSA key, ID 6E980A59, created 2014-05-27 (main key ID BAD7F7A3)

gpg: encrypted with 2048-bit RSA key, ID 6E980A59, created 2014-05-27
      &amp;quot;Akagi201 (Bob Liu) &amp;lt;akagi201@gmail.com&amp;gt;&amp;quot;
akagi201@akrmbp ~ $ cat akmsg.txt
This is secret
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;提醒&#34;&gt;提醒&lt;/h2&gt;
&lt;p&gt;虽然可能性不是那么高, 但你永远不知道哪一天会需要这样的科技, 以保障你的通讯安全. 若不从现在开始建立你的web of trust, 需要时, 可能为时已晚. 请妥善保管你的secret key, 别让任何人有机可趁. 保护自己, 也保护朋友.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.codemud.net/~thinker/GinGin_CGI.py/show_id_doc/478&#34;&gt;http://www.codemud.net/~thinker/GinGin_CGI.py/show_id_doc/478&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>网络嵌入式设备框架</title>
      <link>/zh/post/network-device-framework/</link>
      <pubDate>Wed, 26 Mar 2014 07:46:08 +0800</pubDate>
      <guid>/zh/post/network-device-framework/</guid>
      <description>&lt;p&gt;这不是什么新鲜东西, 无线路由器很早前就开始使用了, 不过最近才慢慢理解其原理. 现在网络嵌入式设备的功能越来越强大了, 各芯片厂商的解决方法支持着这种复杂性.&lt;/p&gt;
&lt;h2 id=&#34;1-一个网络芯片架构&#34;&gt;1. 一个网络芯片架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-device-hardware.png&#34; alt=&#34;network-device-hardware&#34;&gt;&lt;/p&gt;
&lt;p&gt;大家应该看得出来, 这是一个DSL芯片. 其网络部分由一个switch core构成核心,  对外有3个交换口(粉红色的): 左侧为以太网MAC, 可外接以太网芯片MAC或PHY, 称为LAN端；右侧为DSL的TPS子层，按照DSL标准传输ATM/PTM数据，成为WAN端；上面的是一个PDMA片级总线，与片上系统SoC通信.&lt;/p&gt;
&lt;p&gt;另外还有几个额外的交换口, 主要是提供额外功能的: 一个QDMA用于扩展core外Mem; LTR和WTR是两个转换引擎, 当LAN或WAN端的数据包需要一些特殊处理时(如VLAN, PPPOE头等), 会被分别交换到这两个口进行转换后, 再发回Queue中. 再另外, LAN, WAN端各有一个classifier, 是预分类器, 在数据包进入switch core前, 先进行一个粗略的划分, 决定发往哪个端口.&lt;/p&gt;
&lt;p&gt;以上的这些功能都是switch core独立完成的, SoC系统只需对其进行简单的配置, 控制即可. 所以SoC的性能并不需要太高(CPU大概是130MHz的). 注意, 该switch core和一般以太网switch的区别, 首先其端口类型就不同, 所提供的功能也跟为复杂.&lt;/p&gt;
&lt;p&gt;这里给出一个简单的以太网switch芯片的架构, 如下图所示, 其核心就是一个register集, 对它们进行配置(内部EEPROM, 或外部MDIO总线), 可以实现port-VLAN, 二层filter等功能. 其结构相对简单, 因为其所有端口都是以太网口.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-switch.png&#34; alt=&#34;network-switch&#34;&gt;&lt;/p&gt;
&lt;p&gt;用该芯片接在上述DSL芯片的LAN端, 构成网络系统如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-switch-lan.png&#34; alt=&#34;network-switch-lan&#34;&gt;&lt;/p&gt;
&lt;p&gt;以太网switch可以自主实现port-VLAN功能, 并通过一个trunk口与switch core相连, 而switch core有很好的vlan_tag classifier功能. 另外WAN端实现了8个硬件通道PVCs, 且switch core也能对它进行很好的classifier. 综上, 就可以实现所谓的port-mapping功能, 只要一跟DSL接入线, 就可在家庭里实现IPTV, Internet, 可视电话等业务的分离.&lt;/p&gt;
&lt;p&gt;注意, 所有这些功能都是switch core自动完成的, 网络数据包不需要进入SoC的协议栈, 这和后面讲的一般的路由器是不同的.&lt;/p&gt;
&lt;h2 id=&#34;2-嵌入式片上系统&#34;&gt;2. 嵌入式片上系统&lt;/h2&gt;
&lt;h3 id=&#34;21-与外界的交互方式&#34;&gt;2.1 与外界的交互方式&lt;/h3&gt;
&lt;p&gt;这里的SoC系统主要功能有: 与外界用户的交互, 解析用户指令, 配置系统.&lt;/p&gt;
&lt;p&gt;解析指令对软件系统来说很简单, 配置系统, 前面也说了, 主要是读写一些register, 也很简单. 关键就在于与外界用户交互.&lt;/p&gt;
&lt;p&gt;很容易想到的一种方式是网络, SoC也连在switch core上, 有自己的IP, MAC. 当然它和switch core是片上bus相连的, 通信时并不需要MAC, 这里只是把自己伪装成一个通用的以太网设备, 可以被switch core和外界PC识别.&lt;/p&gt;
&lt;p&gt;要通信, 当然就需要协议栈了, 不过, 这里的SoC系统不需要处理额外(正常通信)的数据, 所以协议栈也选择简单的LWIP, 如之前的博文所述. 最常用的网络通信方式就http了, 另外还有telent等.&lt;/p&gt;
&lt;p&gt;呵呵, 连接192.168.1.1实际就是去连接其内部的SoC, 一般的交换机, 路由器都是这样的, 而不是什么端口. 当我还是一个超级菜鸟时, 这个问题困扰了好久, 纠结.&lt;/p&gt;
&lt;p&gt;另外, 嵌入式系统中, 还有一个最常用的交互方式是串口UART. UART是一个非常简单的I/O设备, 它通过直接读写管脚的电平信号(串行的)来实现输入输出, 没有任何额外的中断, 控制等机制. 虽然简单, 不能用以实现复杂, 可靠的功能, 但用作嵌入式系统的调试方法却非常有效.&lt;/p&gt;
&lt;p&gt;UART就像是嵌入式设备的键盘/显示器. 它是一种非常简单的硬件资源, 在它之上可以构建通用的I/O设备tty, 在tty之上, 就可以实现各种应用, 如shell等.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-uart.png&#34; alt=&#34;network-uart&#34;&gt;&lt;/p&gt;
&lt;p&gt;硬件资源UART, 虚拟层设备tty都是系统的资源, 在Uc/OS中, 一般作为全局量, 在其上的应用则通过task来完成. 如XSHELL_TASK中, 就是通过一个while(1)循环, 不停地通过tty_get_line()读取命令行. 注意, 该函数已经不是裸的硬件操作了, 而是加上了一个上层操作, 即识别\r\n来作为结束符, 也是通过一个while(1)循环来作的. 读到电平为空, 则忽略, 因为UART太简单了, 没有中断, 缓存机制等(没有详细去考究, 只是粗略地浏览了一下代码, 好像是这样的吧!).&lt;/p&gt;
&lt;p&gt;最后, 外界用户读写电平, 当然不同用示波器了. 呵呵, PC上装个串口驱动, 那么PC的键盘/显示器就为嵌入式板子所用啦.&lt;/p&gt;
&lt;h3 id=&#34;22-bootloader&#34;&gt;2.2 bootloader&lt;/h3&gt;
&lt;p&gt;这就像一个心结, 你一天不理解它, 就一天不能安心地开发嵌入式系统, 尽管你可以把软件写得很出色.&lt;/p&gt;
&lt;p&gt;传统的PC机上电后, cpu核的指令指针(如cs:ip)会指向系统内某段固化的代码, 如BIOS, 这些代码被烧录在rom存储器中, 断电也不会丢失. 它们会调用我们开发的代码(如操作系统软件、或一些简单的前后台程序).&lt;/p&gt;
&lt;p&gt;一个嵌入式怎么启动, 其实大意和PC(所有这种代码机器)差不多. 当然不同厂商的芯片, 也有各自的方式特点, 以公司的这款芯片来说(注意, 这里说的是芯片上集成的SoC子系统), 它有好几种方式启动.&lt;/p&gt;
&lt;p&gt;首先, 其芯片内集成了一个BootRom, 它里面的代码(也就是二进制的门电路)是在芯片的一部分, 即芯片生产出来就有的. 芯片对外有个引脚(boot-mode_pin), 把它接低, 则芯片上电后的ip指向该BootRom, 执行里面的代码. 这些代码很简单, 一般会实现BOOTP, tffp等功能, 从网络上下载OS的内核到内存中来运行. 这就是所谓的网络无盘系统的工作方式.&lt;/p&gt;
&lt;p&gt;不过现在好像这种方式用的少了, 存储器便宜啊. 一般都会把boot-mode_pin拉高, 这样上电后ip指向外部flash. 很容易想到flash和PC上的硬盘类似, 是差不多, 有点区别. PC上电后先执行BIOS, 由BIOS装载硬盘的bootloader扇区. 而嵌入式系统一般不这么麻烦, 它直接就在flash中运行这些代码.&lt;/p&gt;
&lt;p&gt;现在的cpu-core一般都是32位的, 即有4G物理寻址空间, 而嵌入式的SDRAM并不要那么大, 所有可以把外部flash和SDRAM一起编址:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-storage.png&#34; alt=&#34;network-storage&#34;&gt;&lt;/p&gt;
&lt;p&gt;系统上电后, ip指向2G处, 则可以直接在flash运行初始的代码, 只是速率比较慢, 所以开始的代码往往是把后面的一个image下载到SDRAM中去, 然后在SDRAM中运行.&lt;/p&gt;
&lt;p&gt;至于flash的基址为什么能是2G, 这是由CPU的地址总线和flash的SPI总线的特殊的电路连接方式决定的, 呵呵, 电子出身的应该不难理解. 而且, 有些芯片还提高一些外部引脚pin, 来为地址线加上一个offset(比如1M), 那么两个处理芯片就可以使用同一个flash的不同的部分了(0~1M, 1~2M), 而其内部只觉得都是从2G地址开始的.&lt;/p&gt;
&lt;p&gt;下面一个关键问题就是, flash中是什么, 怎么来的, 能改变吗?&lt;/p&gt;
&lt;p&gt;一般flash中的东西, 是由具体应用来决定的, 开头一般都是bootloader代码, 后面有一个image文件, 公司的网络系统, 需要一个启动配置文件, 也简单的放在flash中:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-flash-layout.png&#34; alt=&#34;network-flash-layout&#34;&gt;&lt;/p&gt;
&lt;p&gt;Bootloaer一般放在开头, 便于执行. 后面的则也可以直接这样按照物理空间分配, 复杂一点, 也可以做成文件系统fs, 如嵌入式linux. 主要包括一些配置文件, log信息文件. 最重要的是IMAGE文件, 一般要被加载到SDRAM中去运行, 这也是我们开发系统功能应用的关键.&lt;/p&gt;
&lt;p&gt;那这些内容怎么来的呢? 一般初始时, 会用特定的硬件工具厂商提供的一个初始的文件(格式就是上图所示)烧到flash中, 就像当年我们烧8051单片机一样, 再把flash焊在板子上. 如果运行过程中, 代码被改死了, 系统再也起不来了, 那对不起, 只能重新焊一个新的flash了. 而一个补救的方法是在flash中准备两个image, 板子上预留一个特殊的按键, 按下后启动新的image(前面讲的flash-offset方法). 还有一种方法, 是通过内部bootrom启动, 无盘启动. 实现当然需要一定的硬件支持, 如前面所述的那个boot-mode_pin不能焊死, 用一个跳冒, 或者通过一些特殊电路接在以太网上, 以太网事先有数据传输时, 则使用内启动, 如组播升级. 方法各不一啦.&lt;/p&gt;
&lt;p&gt;最后, flash里面的内容怎么变? 很简单, 它既然也在cpu的变址内, 直接用cpu把数据写到flash中不就行了. 一般用http服务, client会post一个image文件上来, server端检查没问题, 就写到flash中, 这就是手动升级.&lt;/p&gt;
&lt;h3 id=&#34;3-一个无线路由器的架构分析&#34;&gt;3. 一个无线路由器的架构分析&lt;/h3&gt;
&lt;p&gt;前面提到的公司芯片解决方案, SoC子系统的功能很有限, 通信数据包一般不会到SoC的协议栈. 而目前市场上的无线路由器系统, 系统中的CPU功能一般很强大, RAM配置也很强大, 一般都能运行大型系统软件, 如Linux.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-router-framework.png&#34; alt=&#34;network-router-framework&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是一块单独的芯片, 而其几乎包含了一个完整的PC机主板上的所有内容, CPU的功能还是很强劲了, 670MHz的MIPS核, 通过桥片连接数据总线. 这里的sys_bus差不多相当于PC中的PCI总线, 诸如USB控制器等都挂在其下. 这里主要看一下网络设备, 主要有两个, 一个802.11n标准的WLAN收发器, 一个4FE+2GE的以太网交换机.&lt;/p&gt;
&lt;p&gt;和之前介绍的DSL芯片不同, 他的两个网络接口都是接在系统总线上, 而没有通过一个switch-core交互. 因此, CPU内必须维护一个功能完整的协议栈, 而且SWC往往也被虚拟化为wan和lan口, 参见下面的结构图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/network-router-struct.png&#34; alt=&#34;network-router-struct&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先, 先明确一个概念, 在统计网络设备的端口数, 不要忘了还有一个端口连接CPU的. 比如, SWC对外有4FE+2GE, 而实际上它还有第七个端口连接到CPU. 然后就能理解有些数据传输只在这些只能得网络设备中完成了, 而有些则需要进入CPU的协议栈. 更准确的概念应该是, 片内CPU系统也相当于一个PC, 共同接在交换设备上.&lt;/p&gt;
&lt;p&gt;这里比较特殊的是这个SWC设备, 照理它的所有端口应该是等价的, 所处网段也相同, 但通过VLAN技术, 把3, 4, CPU端口化为一个VLAN, 而5, CPU化为另一个VLAN, 这是SWC硬件支持的port-mapping, 它能只允许同一个VLAN下的机器通信. 这里就有一个特殊的CPU端口, 它同属于两个VLAN, 称为trunk, SWC硬件在trunk口下收发数据时, 必须带有vlan_tag(802.1q). 在CPU系统内, 因为物理通路只有一个, 只能通过软件的方式来实现VLAN的划分(如Linux下的VLAN). 另外, 一般把wlan挂在LAN内, 所以在Linux中可以用一个虚拟Bridge设备来连接这两个设备. 下面来看几种数据交换的途径:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3, 4间通信, 在PC机发起的ARP协议阶段, SWC也学习并记录了MAC表, SWC可以直接交换.&lt;/li&gt;
&lt;li&gt;1, 2间通信, 也像ethernet交换机那样, 直接在wlan设备中交换吗? 没研究过wlan协议啊, 姑且这样认为吧.&lt;/li&gt;
&lt;li&gt;3, 1间通信, 是同一网段的, DMAC为PC1的MAC地址, 在SWC中会将它从CPU端口发出去, 当然会加上lan_vlan-tag, 因此会被netdev_eth设备接收到, 而该设备已经变成了bridge设备的一个端口, 因此bridge设备会接管该pkt, 并根据MAC表, 从netdev_wlan设备(已经是端口啦)发出, wlan设备受到pkt后, 根据802.11n协议, 发给对应的PC.&lt;/li&gt;
&lt;li&gt;5和其它通信, 不管是3, 4还是1, 2, 都是不同网段, 因此在PC的路由系统中, 会将数据发往gw-IP2, 即pkt的DMAC为片上CPU的MAC, 那么在SWC中会将pkt从CPU端口发出去, 当然会打上wan_vlan-tag, 因此会被netdev_eth-vlan设备接收, 并进入片上CPU系统的协议栈(注意, 之前的3种情况都不会进的). 此时, 片上CPU系统就充当了路由功能, 选择bridge设备下发, bridge设备中根据MAC选择对应端口下发.&lt;/li&gt;
&lt;li&gt;其它向5通信, 和上面一样, 只是方向反过来.&lt;/li&gt;
&lt;li&gt;片上CPU系统自身也有MAC, IP(192.168.1.1), 外部PC发送数据, 通过wlan, swc设备到达CPU系统的interface, interface发现是发给自己的, 则会传递给上层协议栈.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然这里只是最基本的情况, 现在的路由器设备已经集成了非常多的功能, 如DHCP, NAT, DNS等等.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zmkeil/archive/2013/05/26/3100096.html&#34;&gt;http://www.cnblogs.com/zmkeil/archive/2013/05/26/3100096.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>uhttpd实现框架</title>
      <link>/zh/post/httpd-framework/</link>
      <pubDate>Tue, 25 Mar 2014 07:14:08 +0800</pubDate>
      <guid>/zh/post/httpd-framework/</guid>
      <description>&lt;p&gt;uhttpd是一个简单的web服务器程序, 以前没怎么接触过, 所以这里主要是对web服务器设计的一些学习总结. OpenWrt系统中, 真正用到的(需要了解的), 其实不多, 主要就是cgi的处理, 包括与cgi程序的信息交互等, 最后一节详细描述一下.&lt;/p&gt;
&lt;h2 id=&#34;1-http协议概述&#34;&gt;1. HTTP协议概述&lt;/h2&gt;
&lt;p&gt;HTTP协议是目前互联网使用最广泛的应用层协议. 其协议框架很简单, 在一个TCP连接中, 以一问一答的方式进行信息交互. 具体讲, 就是客户端(如常见的浏览器)connect服务端的知名端口(通常是80), 建立一个TCP连接, 然后发送一个request; 服务器端对该request解析后, 发回相应的request应答, 并关闭TCP连接. 这就是一次交互, 之后客户端再有请求, 则重复上面的过程.&lt;/p&gt;
&lt;p&gt;交互报文格式如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/uhttpd-protocol.png&#34; alt=&#34;uhttpd-protocol&#34;&gt;&lt;/p&gt;
&lt;p&gt;Request报文首行为request-line, 其中, type有GET, POST, HEAD三种方式, 然后最重要的是URL, 他告诉服务器所请求的资源. Response报文首行为responsee-line, 其中最重要的是code, 他告知客户端相应情况(found, redirect, error等), 然后跟一个简单的可读的短语.&lt;/p&gt;
&lt;p&gt;两种报文后面具体的内容格式差不多, 都是一些headers(其中, 冒号前的str指明header类型), 然后以一个空行标识header结束, 后面是数据. 对于request, 只有POST类型的请求需要提交数据, 其他类型的是没有数据的. Response报文的数据就是URL所指定的资源文件(HTML, DOC, gif等).&lt;/p&gt;
&lt;h2 id=&#34;2-服务器架构&#34;&gt;2. 服务器架构&lt;/h2&gt;
&lt;p&gt;uhttpd作为一个简单的web服务器, 其代码量并不多, 而且组织结构比较清楚. 和其他网络服务器差不多, 其main函数进行一些初始化(首先parse config-file, 然后parse argv), 然后进入一个循环, 不断地监听, 每当有一个客户请求到达时, 则对他进行处理.&lt;/p&gt;
&lt;p&gt;对于web服务器, 所要做的处理主要就是分析URL, 判断出是file-request, cgi-request或lua-request, 这主要是根据URL的最前面的字符串(称为前缀prefix)得出的; 然后就用相应的形式进行处理. 如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/uhttpd-framework.png&#34; alt=&#34;uhttpd-framework&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-cgi-response流程&#34;&gt;3. cgi-response流程&lt;/h2&gt;
&lt;p&gt;前面已提到, openwrt系统中使用uhttpd服务, 主要是用cgi方式来回应客户请求的, 下面就对这种方式详细阐述.&lt;/p&gt;
&lt;h3 id=&#34;31-url解析&#34;&gt;3.1 URL解析&lt;/h3&gt;
&lt;p&gt;由上图红字所示, uh_cgi_request需要两个参数path info和interpreter, 其中, pin是一个struct, 包含了路径中各种有用信息; ipr指明所用的cgi程序, 因为一个服务器中可以有多个cgi程序.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/uhttpd-url.png&#34; alt=&#34;uhttpd-url&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示, docroot是服务器的资源目录, 是为了os准确定位资源位置, 由uhttpd的config文件设定, 如openwrt中为/www. 后面的是client传来的url, 开头的为cgi-prefix, 也是由uhttpd的config文件设定的, 它指明server端采用cgi处理方式, 如openwrt中的为/www/cgi-bin; 紧接着的是cgi的程序名, 它指明了使用哪个cgi程序; 再后面就是实际的path信息了, 在cgi方式中, 它会被当成参数供cgi程序使用.&lt;/p&gt;
&lt;h3 id=&#34;32-cgi处理框架&#34;&gt;3.2 CGI处理框架&lt;/h3&gt;
&lt;p&gt;要运行cgi程序, 首先意味着需fork出一个子进程, 并通过execl函数替换进程空间为cgi程序; 其次, 数据传递, 子进程替换了进程空间后, 怎么获得原信息, 又怎么把回馈数据传输给父进程(即uhttpd), 父进程又怎么接收这些数据.&lt;/p&gt;
&lt;p&gt;!(uhttpd-cgi)[http://akagi201.qiniudn.com/uhttpd-cgi.png]&lt;/p&gt;
&lt;p&gt;首先创建2个pipe, 这实际上是利用AF_UNIX协议域, 创建2个相连的socket_unix, 那么, 他们映射的文件描述符(即这里的fd[0], fd[1])就构成了一个pipe, 且这种关系即使fork后也仍然存在, 因为fork仅是增加了文件的引用次数, 而OS维护的file结构和socket结构都没变, 这就是父子进程间传递数据的方式. 然后fork出一个子进程.&lt;/p&gt;
&lt;p&gt;子进程中首先把2个管道的一端close, 注意这仅是使得文件引用次数变为1. 由于子进程待会要excel替换, 替换后rfd, wfd就不存在了, 因此, 先把他们dup2给知名的stdin, stdout, 这样即使execl替换后, ipt-&amp;gt;extu程序可以以此来和父进程传递数据. 另外, execl替换后, cgi程序仍需要之前的一些参数信息, 如PATH_INFO等, 这种情况下, 最简单的办法就是setenv, 把需要的参数设为环境变量.&lt;/p&gt;
&lt;p&gt;为什么要2个pipe, 因为子进程向父进程传递回馈数据需要一个out-pipe, 而若有post数据, 子进程还需要一个in-pipe, 从父进程读取post数据.&lt;/p&gt;
&lt;p&gt;父进程中首先也是close, 同上所述. 若有post数据, 先从http request-header中得到content-length, 为后面传递给子进程做准备. 然后进入一个循环(为什么要循环, 什么时候退出, 后面讲), 通过select轮询io, 超时, 中断的情况就不看了, 轮询的io一个是reader, 即从子进程读取回馈数据, 而若有post数据的话, 还要另一个io, writer, 向子进程写post数据. 主要的处理就是上图中红色字所示, 具体如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/uhttpd-post.png&#34; alt=&#34;uhttpd-post&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zmkeil/archive/2013/05/14/3078766.html&#34;&gt;http://www.cnblogs.com/zmkeil/archive/2013/05/14/3078766.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>在虚拟机上搭建OpenWrt平台</title>
      <link>/zh/post/openwrt-on-virtual-machine/</link>
      <pubDate>Tue, 25 Mar 2014 03:18:08 +0800</pubDate>
      <guid>/zh/post/openwrt-on-virtual-machine/</guid>
      <description>&lt;h2 id=&#34;1-openwrt平台搭建&#34;&gt;1. OpenWrt平台搭建&lt;/h2&gt;
&lt;h3 id=&#34;11-环境准备&#34;&gt;1.1 环境准备&lt;/h3&gt;
&lt;p&gt;系统Debian7.4, 安装好官网buildroot说明的必备软件包 &lt;a href=&#34;http://wiki.openwrt.org/doc/howto/buildroot.exigence&#34;&gt;http://wiki.openwrt.org/doc/howto/buildroot.exigence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意, 尽量使用较新的linux发行版, 因为openwrt比较新, 而且通常要在trunk分支下开发, 所以依赖的软件包都比较新, 避免繁琐的依赖关系问题.&lt;/p&gt;
&lt;h3 id=&#34;12-编译固件&#34;&gt;1.2 编译固件&lt;/h3&gt;
&lt;p&gt;使用git或者svn下载源码
修改&lt;code&gt;feeds.conf.default&lt;/code&gt;
然后更新软件索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./scripts/feeds update –a
./scripts/feeds install –a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意, 这里下载的知识编译固件用的控制文件(索引文件), 不包含源码.&lt;/p&gt;
&lt;p&gt;然后运行make menuconfig(省去一些检查测试步骤, 具体可看官网说明), 这里注意3点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Target system, 这个一定要选准.&lt;/li&gt;
&lt;li&gt;Target Image, 选择固件image的格式, 这里我们准备在x86的VM上运行, 可以选择VMDK, 直接编译出硬盘文件, 并且包含grub.&lt;/li&gt;
&lt;li&gt;根据需要选择软件包, 要想通过web登录配置, 4个地方要选: Base system -&amp;gt; uci, Libraries -&amp;gt; libuci-lua, LuCI全选, Network -&amp;gt; uhttpd.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意软件可以选择m或者y, 前者表示只编译出&lt;code&gt;xxx.ipk&lt;/code&gt;安装包文件, 用户需要时将它上载到路由器中, &lt;code&gt;opkg install xxx.ipk&lt;/code&gt; 安装, 后者表示直接编译在固件中.&lt;/p&gt;
&lt;p&gt;最后运行make, 开始编译(可以使用make -j4 V=s加速编译和增加打印编译出错信息), 自动创建dl, build_dir两个目录, 依次调用tools, toolchain, package, target目录中的Makefile编译(前两者是工具, 然后用这个工具编译后两者). 自动根据指示下载所需的源码包, 放在dl目录下, 然后解压到build_dir目录中进行编译. build_dir中有3个子目录, host是于平台无关的一些工具, toolchain中式特定平台的工具, ulibc中式C库, 应用程序等.&lt;/p&gt;
&lt;h3 id=&#34;13-vmware中运行openwrt&#34;&gt;1.3 VMware中运行OpenWrt&lt;/h3&gt;
&lt;p&gt;启动VMware, 新建虚拟机(custom), 以编译出的VMDK文件为硬盘, 直接power on就可以进入OpenWrt, 在目录/bin, /usr/bin等目录下, 有我们选择安装的应用程序的可执行文件, 运行他们实现各种功能.&lt;/p&gt;
&lt;h2 id=&#34;2-网络配置的简单示例&#34;&gt;2. 网络配置的简单示例&lt;/h2&gt;
&lt;p&gt;我们在虚拟机下运行, 虚拟机的网络模式有3种: nat, host-only, bridge. 我们安装完VMware后, 主机新增了2快虚拟网卡VMnet1, VMnet8, 前者相当于所有host-only模式的VM的交换机, 所有host-only模式的VM可通过它相互通信, 但不能与外界通信; 后者相当于素有nat模式的VM的交换机, 不同之处在于, 他可以NAT到主机的实际网口, 去访问外网(即相当于有个上行口(WAN口)), bridge模式指利用主机的实际网口与外界通信.&lt;/p&gt;
&lt;p&gt;我们为OpenWrt的VM准备2块网卡, 一块是bridge模式, 另一块是host-only模式; 同时运行另一VM(red hat), 只有一块host-only模式的网卡, 如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/openwrt-vmnet.png&#34; alt=&#34;openwrt-vmnet&#34;&gt;&lt;/p&gt;
&lt;p&gt;OpenWrt的网络配置文件为&lt;code&gt;/etc/config/network&lt;/code&gt;, 编辑写入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;configure interface lan
    option ifname eth0
    option proto dhcp
configure interface wan
    option igname eth1
    option proto dhcp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后重启网络 &lt;code&gt;/etc/init.d/network restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再写入2条路由&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Route add-net 10.10.10.0/24 dev eth0
Route add default dev eth1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再在VM-Redhat写入2条路由(注意: dev和gw的区别)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Route add-net 10.10.10.0/24 dev eth0
Route add default gw 10.10.10.130
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样, 实际局域网的主机就可通过OpenWrt这个路由器与host-only虚拟语句网的主机通信了, 当然前提是各主机应设一条网关路由到182.168.68.187&lt;/p&gt;
&lt;h2 id=&#34;3-应用程序开发&#34;&gt;3. 应用程序开发&lt;/h2&gt;
&lt;p&gt;应用程序开发有2种方法.&lt;/p&gt;
&lt;h3 id=&#34;31-方法一&#34;&gt;3.1 方法一&lt;/h3&gt;
&lt;p&gt;利用menuconfig, 直接与固件一起编译, 即预先把相关文件放到 &lt;code&gt;trunk/package/myapp&lt;/code&gt; 目录下, make menuconfig时就能找到该软件包, 选择(可以选y编译进固件中, 或m只编译成.ipk包)即可.&lt;/p&gt;
&lt;p&gt;比如, 在package目录下mkdir hello world, 里面放些什么则至关重要, 可以参考其他包的内容, 其中的Makefile的最关键的, 其他都可选, 比如我们这里还放了一个src子目录, 里面放helloworld.c, Makefile(它是真正编译用的).&lt;/p&gt;
&lt;p&gt;Makefile的内容可参考模板, 一般分为很多节, 第一节一般说明程序名称, 版本等; 第二节说明软件包的基本属性(他是一般包, 还是kernel包, SECTION, CATEGORY字段说明其在menuconfig中的位置, 一定要写准确, 该包的依赖关系等). 注意Makefile中Tab符不能乱用, 一般表示command, 这里的属性字段不用用Tab, 只能用空格.&lt;/p&gt;
&lt;p&gt;后面几节描述了他的编译安装方法. 一般就是把src里的内容copy到build_dir/uClib下, 然后用toolchain来编译, 最后install一节可以指明该app在固件中被放在哪个目录下(/bin, 或 /usr/bin等).&lt;/p&gt;
&lt;h3 id=&#34;32-方法二&#34;&gt;3.2 方法二&lt;/h3&gt;
&lt;p&gt;利用SDK, 就像android开发一样, 利用sdk编译出软件安装包, 上传到设备, 安装即可使用. 首先在make menuconfig的时候, 把build SDK选项选上, 那么, 固件编译好后, 在trunk/bin/x86下就有一个SDK.tar文件, 解压, 进入里面.&lt;/p&gt;
&lt;p&gt;可以发现里面的内容和trunk主目录下的非常相似, 也有package, buld_dir, dl等目录, 实际上它正是模拟了一个固件的编译环境, 这样就简单了, 如方法一所述, 在package目录下建立我们的app子目录, 放入必要的文件, 然后退回到SDK目录, 直接make即可, 编译好的.ipk包在SDK/bin/x86/package下.&lt;/p&gt;
&lt;p&gt;至于上传.ipk包到路由器上, 对于实际设备, 可以scp工具, 在VMware下没找到更好的方法.&lt;/p&gt;
&lt;h3 id=&#34;33-为什么要用ipk包&#34;&gt;3.3 为什么要用ipk包&lt;/h3&gt;
&lt;p&gt;ilk包是openwrt特有的, 为什么用这个呢, 直接把可执行文件copy到设备中不就行了吗? 回头看看hello world中的Makefile的最后一节install就ming明白了, ilk包li里不仅有可执行文件, 还有安装该文件的具体指示, 甚至还有其他一些配置, 启动文件, 以及他们的安装方式.&lt;/p&gt;
&lt;p&gt;联想network命令就是这样的, 进到package/conf下, 看他的Makefile最后, 其实就是拷贝文件.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/zmkeil/archive/2013/04/17/3027385.html&#34;&gt;http://www.cnblogs.com/zmkeil/archive/2013/04/17/3027385.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Gdbserver On OpenWrt</title>
      <link>/zh/post/gdbserver-on-openwrt/</link>
      <pubDate>Mon, 24 Mar 2014 02:56:08 +0800</pubDate>
      <guid>/zh/post/gdbserver-on-openwrt/</guid>
      <description>&lt;p&gt;编写的程序部署到OpenWrt上出错, 打日志是个好办法, 但是今天遇到的情况, 日志也不能显示出正确的程序流程, 实在诡异, 因此, 决定尝试调试器.&lt;/p&gt;
&lt;p&gt;熟悉在普通的电脑上使用gdb调试的基本方法: &lt;a href=&#34;http://www.ibm.com/developerworks/linux/library/l-gdb/&#34;&gt;http://www.ibm.com/developerworks/linux/library/l-gdb/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载&lt;gdb quick reference&gt;2张纸, 打印出来放在手边备用.&lt;/p&gt;
&lt;p&gt;路由器中的存储空间十分有限, OpenWRT的包管理器opkg提供的GDB占用大约1.5MB空间. 路由器本身有8M的存储空间, 目前只剩200KB了, GDB的大小不能接受. 相比之下, GDBServer的大小 不到100KB, 这是可以接受的.&lt;/p&gt;
&lt;h2 id=&#34;gdbserver远程调试方法&#34;&gt;gdbserver远程调试方法&lt;/h2&gt;
&lt;h3 id=&#34;路由器端&#34;&gt;路由器端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;安装gdbserver&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;opkg install gdbserver
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;进入目录, 运行gdbserver, 监听网络端口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gdbserver 192.168.8.1:4455 xxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pc端&#34;&gt;PC端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;根据OpenWrt SDK位置配置好PATH路径&lt;/li&gt;
&lt;li&gt;进入被调试的程序文件, 这是为了向gdb提供程序的调试信息.&lt;/li&gt;
&lt;li&gt;指定被调试的程序文件, 启动gdb.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mips-openwrt-linux-gdb xxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在gdb中连接远程调试器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;target remote 192.168.8.1:4455
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;等待崩溃&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;bt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果连接成功, 则此时就可以像平常一样使用gdb来调试程序了, 不过调试目标是位于路由器的程序. 使用这个方法可以很轻易的定位到程序错误的位置. 毕竟是动态调试.&lt;/p&gt;
&lt;h2 id=&#34;编译gdb和gdbserver方法&#34;&gt;编译gdb和gdbserver方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# gdb的编译
cd ~/gdb/gdb-7.3.1
mkdir bin
cd bin
../configure --prefix=/opt/gdb-7.3.1 --host=i686-pc-linux-gnu --target=mips-linux
make
make install

# gdbserver的编译
cd ~/gdb/gdb-7.3.1/gdb/gdbserver
mkdir bin
cd bin
export CC=/opt/openwrt/kamikaze_7.09/staging_dir_mips/bin/mips-linux-gcc
../configure --target=mips-linux --host=mips-linux
make
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;补充&#34;&gt;补充&lt;/h2&gt;
&lt;p&gt;如果上面的方法不能工作, 有可能是openwrt设备上的库被stripped了, 可以在host主机上使用没有stripped的库来远程调试.&lt;/p&gt;
&lt;h2 id=&#34;openwrt源码上编译工具链&#34;&gt;openwrt源码上编译工具链&lt;/h2&gt;
&lt;p&gt;在menuconfig上enable gdb 和 gdbserver.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Advanced configuration options (for developers) → Toolchain Options → Build gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Utilities → gdbserver
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;给你想调试的包增加调试信息&#34;&gt;给你想调试的包增加调试信息&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;添加CFLAGS到你要调试的package的Makefile中.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;TARGET_CFLAGS += -ggdb3
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;重新编译package带有CONFIG_DEBUG.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make package/busybox/{clean,compile} V=99 CONFIG_DEBUG=y
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;或者在menuconfig中使能debug info&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Global build settings &amp;gt; Compile packages with debugging info
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/gdb/current/onlinedocs/gdb/&#34;&gt;https://sourceware.org/gdb/current/onlinedocs/gdb/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://h4x3rotab.github.io/blog/2014/02/27/openwrtxia-de-gdbyuan-cheng-diao-shi/&#34;&gt;http://h4x3rotab.github.io/blog/2014/02/27/openwrtxia-de-gdbyuan-cheng-diao-shi/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/vastsmile/article/details/5614856&#34;&gt;http://blog.csdn.net/vastsmile/article/details/5614856&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git commit 规范</title>
      <link>/zh/post/git-commit-convention/</link>
      <pubDate>Mon, 24 Mar 2014 01:32:08 +0800</pubDate>
      <guid>/zh/post/git-commit-convention/</guid>
      <description>&lt;p&gt;最近发现自己的git log太乱了, 稍微整理一下规范.&lt;/p&gt;
&lt;h2 id=&#34;基本原则&#34;&gt;基本原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;永远不在&lt;code&gt;git commit&lt;/code&gt;后增加&lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt;来添加日志. 直接git commit [-a]然后会出现一个编辑界面.&lt;/li&gt;
&lt;li&gt;在.vimrc中添加一行, 来检查拼写和自动折行.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;autocmd Filetype gitcommit setlocal spell textwidth=72
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一行应该少于50个字, &lt;strong&gt;随后一个空行&lt;/strong&gt;, 然后写具体内容.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;举例&#34;&gt;举例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;总体格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;模块名: msg +补充信息关键字(time/issue/review) 补充信息(#issue号 可被github识别)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次提交用 &lt;code&gt;first blood&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录花费时间2d 3h&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;othermsg +time 2d 3h
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;修issue: 1234&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;othermsg +issue #1234
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;提交的同时, 有代码审查, 审查人user1, user2&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;othermsg +review @user1 @user2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;提交的同时, 和1112号代码审查相关联&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;othermsg +review 项目代码审查关键字-1112
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;任何项目管理工具(即使使用文本文件管理)都会很容易解析上述信息, 无论用的是git还是svn.&lt;/p&gt;
&lt;p&gt;另外更详细的信息会在代码中或者项目管理工具中出现, 不需要提交太多&amp;quot;othermsg&amp;rdquo;, 一两句概述的话或单词说清楚就行.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/q/1010000000395039&#34;&gt;http://segmentfault.com/q/1010000000395039&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ruby-china.org/topics/15737&#34;&gt;http://ruby-china.org/topics/15737&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ARM汇编:MOV, LDR, LDR伪指令之间区别</title>
      <link>/zh/post/mov-vs-ldr/</link>
      <pubDate>Wed, 19 Mar 2014 09:24:08 +0800</pubDate>
      <guid>/zh/post/mov-vs-ldr/</guid>
      <description>&lt;p&gt;在编译ARM汇编时, 用MOV指令编译有时会出错, 但是, 有时又对了, 还有LDR, 有时要加个&amp;quot;=&amp;rdquo;, 有时又不加了, 非常容易搞混.&lt;/p&gt;
&lt;h2 id=&#34;1-8位图数据&#34;&gt;1. &amp;ldquo;8位图&amp;quot;数据&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/8bit.jpg&#34; alt=&#34;8bit&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-mov指令&#34;&gt;2. MOV指令&lt;/h2&gt;
&lt;p&gt;MOV指令可以把立即数或者寄存器内容(注意: 这里绝对不可以是内存!!)传递给一个寄存器.
对于立即数是有要求的, 就是上边的&amp;quot;8位图&amp;quot;数据. 只能由一个8bit连续有效位通过偶数次移位得到的数.
它为什么会有这样的限制呢?
原因是, MOV本身就是一个32bit指令, 除了指令码本身, 他不可能再带一个可以表示32bit的数字, 所以用了其中的12bit来表示立即数, 其中4bit表示移位的尾数(循环右移, 且数值*2), 8bit用来表示要移位的一个基数.
如果立即数超过这个范围, 就没有办法用一条MOV指令给寄存器赋值(这里就要用到LDR伪指令了, 查看反汇编指令, 你会看到LDR伪指令此变成了两条指令~~).&lt;/p&gt;
&lt;h2 id=&#34;3-ldr指令&#34;&gt;3. LDR指令&lt;/h2&gt;
&lt;p&gt;首先呢, ldr指令既可以是大范围的地址读取伪指令, 也可以内存访问指令. 当它的第二个参数前面有&amp;quot;=&amp;quot;时, 表示伪指令, 否则表示内存访问指令.
LDR指令就是个单寄存器存储的ARM存储器访问指令, 补充了MOV指令不能访问内存的缺陷.
ARM是RISC结构的, 数据从内存到CPU之间的移动只能通过ldr/str指令(我说的是单个寄存器~~).
想要把数据从内存中某处读取到寄存器中, 只能用ldr.&lt;/p&gt;
&lt;h2 id=&#34;4-ldr伪指令&#34;&gt;4. LDR伪指令&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;LDR伪指令没有立即数范围的限制, 即可以直接赋值, 因为这是一条伪指令.
如果立即数在MOV的要求内, 系统会自动用一条汇编MOV指令来实现. 如果不在MOV的范围内, 就用其它的方式来实现, 比如变成了两条指令, 或者从PC偏移地址读取一个32位的数据给寄存器.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于LDR伪指令, 可以装载一个32bit立即数的说法并不正确, 因为在实际中并不是这一条语句装载了32bit立即数(跟上面的貌似一样, 呵呵~~), 比如:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;ldr r1,=0x70000000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其实真正的汇编代码是将某个地址的值传递给r1, 就是说需要一个地址存放0x70000000这个立即数, 在反汇编中,
如果仔细看会发现, 如果这个立即数可以用mov指令的表达形式来表达, 编译器就直接用mov了.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_7ec8fc2c01014epa.html&#34;&gt;http://blog.sina.com.cn/s/blog_7ec8fc2c01014epa.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>体验设计</title>
      <link>/zh/post/experience-design/</link>
      <pubDate>Sun, 16 Mar 2014 07:09:08 +0800</pubDate>
      <guid>/zh/post/experience-design/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/active-point.png&#34; alt=&#34;active-point&#34;&gt;&lt;/p&gt;
&lt;p&gt;受皓玥学姐的邀请, 酱油了一下bong openday的hackathon, 这不是第一次参加hackathon了, 不过算是第一次实际参与了吧. 虽说, 线上的形式会有点松懈没那么多的竞争的感觉.&lt;/p&gt;
&lt;h2 id=&#34;收获&#34;&gt;收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;认识了几个小伙伴, 还认识了2个岑徐媛, 咳咳.&lt;/li&gt;
&lt;li&gt;快速体验了一个开源免费的原型设计工具 pencil, 还是有点略难用, 收费软件应该用起来更加直观.&lt;/li&gt;
&lt;li&gt;也算给学姐帮了点小忙吧, 呵呵.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;成果物仓库&#34;&gt;成果物仓库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Akagi201/bongOpenPlatform&#34;&gt;https://github.com/Akagi201/bongOpenPlatform&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;潘小木的作品&#34;&gt;潘小木的作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/bong-open.jpg&#34; alt=&#34;bong-open&#34;&gt;
*
&lt;img src=&#34;http://akagi201.qiniudn.com/%E6%B1%87%E6%80%BB%E6%97%B6%E5%85%89%E6%9C%BA.jpg&#34; alt=&#34;汇总时光机&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Lua</title>
      <link>/zh/post/learning-lua/</link>
      <pubDate>Thu, 13 Mar 2014 12:45:08 +0800</pubDate>
      <guid>/zh/post/learning-lua/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/learning_lua/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;h2 id=&#34;学习的动机&#34;&gt;学习的动机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因为TI NSPIRE&lt;/li&gt;
&lt;li&gt;因为OpenWrt&lt;/li&gt;
&lt;li&gt;因为刚好看到一个不错的课程&lt;/li&gt;
&lt;li&gt;因为现在刚好有时间和兴致&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.56.com/w87/album-aid-12231435.html&#34;&gt;http://www.56.com/w87/album-aid-12231435.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MindMup</title>
      <link>/zh/post/mindmup/</link>
      <pubDate>Mon, 10 Mar 2014 01:52:18 +0800</pubDate>
      <guid>/zh/post/mindmup/</guid>
      <description>&lt;p&gt;因为自己看的一个视频课程使用的是思维导图的方式记录笔记的, 所以决定, 自己也选择一种思维导图吧, 经过多种思维导图软件的比较, 最后选择了mindmup(online)+freemind(local), 完全开源免费的解决方案, 主要是用了一下很顺手. 够智能, 够所见即所得. BTW, 因为知识记录这种长久的东西, 还是自己搭建或者使用开源的东西靠谱.&lt;/p&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Zero friction: 可以从任何地方, 任何设备访问. 可以使用MindMup Anonymous Public Storage用于公开的mindmap(不需要注册), google drive用于私人的mindmap.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Productive: 响应式设计来使用 desktop和mobile, 使用了html5技术.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Community-driven and Open: 开发是用户驱动, 新特性的优先级由用户投票决定.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mouse-and-touch-operations&#34;&gt;Mouse and touch operations&lt;/h2&gt;
&lt;p&gt;MindMup有丰富的快捷键接口, 但是大多数操作也同时可以使用鼠标或者触屏操作来实现.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;click and drag the center node: move map&lt;/li&gt;
&lt;li&gt;click and drag the background: move map&lt;/li&gt;
&lt;li&gt;scroll with trackpad/touchpad: move map&lt;/li&gt;
&lt;li&gt;click a node: change current selection&lt;/li&gt;
&lt;li&gt;shift+click a node: multi-select, add a node to selection&lt;/li&gt;
&lt;li&gt;shift+drag a node: manually position a node. Children of the root node can be pulled in any direction, lower level nodes can only be positioned in the direction of its parent relative to the root&lt;/li&gt;
&lt;li&gt;double-click a node: edit&lt;/li&gt;
&lt;li&gt;drag and drop a node between its siblings: reorder siblings&lt;/li&gt;
&lt;li&gt;drag and drop a node on another node: move node to a new parent&lt;/li&gt;
&lt;li&gt;drag a top level 1 node from left to right side of the root (or right-left): switch the position of the node(脑图只区分左右, 不区分上下)&lt;/li&gt;
&lt;li&gt;alt+click, ctrl+click and cmd+click: link between the currently selected node and the clicked node (only if they are not already related)&lt;/li&gt;
&lt;li&gt;drag an image onto a node: associate the image with the node as an icon&lt;/li&gt;
&lt;li&gt;drag an image onto the background: add the image as a child node of the currently selected node&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;keyboard-shortcuts&#34;&gt;keyboard shortcuts&lt;/h2&gt;
&lt;p&gt;MindMup对于所有的编辑操作都有快捷键. 在Mac os x上, Ctrl和Cmd键都被记作Ctrl键. 一些浏览器阻止某些键绑定, 所以, 如果Cmd+Space不工作的话, 尝试Ctrl+Space.&lt;/p&gt;
&lt;h3 id=&#34;node-manipulation&#34;&gt;node manipulation&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;shortcut&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Enter&lt;/td&gt;
&lt;td&gt;Add sibling&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift+Enter&lt;/td&gt;
&lt;td&gt;Add sibling above&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift+Enter&lt;/td&gt;
&lt;td&gt;Line break (when editing node text)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tab&lt;/td&gt;
&lt;td&gt;Add child&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift+Tab&lt;/td&gt;
&lt;td&gt;Insert parent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Space&lt;/td&gt;
&lt;td&gt;Edit node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift+Space&lt;/td&gt;
&lt;td&gt;Change node color&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;View or edit node attachment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;Add an image or change the existing image/icon associated with the node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Backspace or Delete&lt;/td&gt;
&lt;td&gt;Remove node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Up/Down Arrow keys&lt;/td&gt;
&lt;td&gt;Move node up/down&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;editing&#34;&gt;editing&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;shortcut&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+s&lt;/td&gt;
&lt;td&gt;Save&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+x or c&lt;/td&gt;
&lt;td&gt;Cut&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+v or p&lt;/td&gt;
&lt;td&gt;Paste&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Shift+v&lt;/td&gt;
&lt;td&gt;Paste Style only(粘贴所复制内容的格式)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+c or y&lt;/td&gt;
&lt;td&gt;Copy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u or Ctrl+z&lt;/td&gt;
&lt;td&gt;Undo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r or Ctrl+y or Ctrl+Shift+z&lt;/td&gt;
&lt;td&gt;Redo&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;selection&#34;&gt;selection&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;shortcut&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Arrow keys&lt;/td&gt;
&lt;td&gt;Select the node up/down/left/right of the currently selected one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + Arrow keys&lt;/td&gt;
&lt;td&gt;Add node up/down/left/right to selection (useful to multi-select siblings)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{&lt;/td&gt;
&lt;td&gt;Multi-select the current node and the entire subtree under it&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&lt;/td&gt;
&lt;td&gt;Multi-select only the subtree under the current node (not the node itself)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;Multi-select all the siblings of the current node (that have the same parent)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;Cancel multi-selection and select only the current node again&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 - 9&lt;/td&gt;
&lt;td&gt;Select all nodes of a particular level (eg 1 selects all first level nodes)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Select the root node and recenter view&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+f&lt;/td&gt;
&lt;td&gt;Find node by part of title&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;navigation-and-screen&#34;&gt;navigation and screen&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;shortcut&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ or f&lt;/td&gt;
&lt;td&gt;Fold or unfold children&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + or z&lt;/td&gt;
&lt;td&gt;Zoom in&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl - or Shift z&lt;/td&gt;
&lt;td&gt;Zoom out&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Esc, Ctrl+0&lt;/td&gt;
&lt;td&gt;Reset map view - select root node and bring it to the center of the screen(目前测试效果和0一样)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+b&lt;/td&gt;
&lt;td&gt;Convert floating toolbar to menu (press again to convert back)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Shift+b&lt;/td&gt;
&lt;td&gt;Hide top menu (press again to show)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;storage-options&#34;&gt;Storage options&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;MindMup Anonymous Public Storage: 免费, 公开, 你们的存储在Amazon&#39;s S3文件存储服务. 一旦保存, 变成只读. 任何对于一个map的修改会创建一个新的map和新的url. url是随机生成的, 只有知道了url, 任何人都可以访问.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MindMup Gold: Amazon&#39;s S3 文件存储服务. 没有匿名存储的很多限制, 我们知道谁拥有这个map, map的url是永久的, 不随着修改而改变.详看
&lt;a href=&#34;http://blog.mindmup.com/p/mindmup-gold.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mindmup-gold&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google Drive: 修改会保存在原有的文件.详看
&lt;a href=&#34;http://blog.mindmup.com/p/working-with-google-drive.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;working-with-google-drive&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Browser Storage: 这个是在你的浏览器中的html存储, 与我们的网站连接. 虽然他有一个url, 但是内容只可以在同一个浏览器的profile被访问. 存储是永久的, 所以你可以关掉浏览器和关机, 内容都不会丢失.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dropbox: 与Google Drive完全一样. 详细
&lt;a href=&#34;http://blog.mindmup.com/p/working-with-dropbox.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;working-with-dropbox&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GitHub: (需要你激活扩展)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mindmup.com/p/mouse-and-touch-operations.html&#34;&gt;http://blog.mindmup.com/p/mouse-and-touch-operations.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mindmup.com/p/keyboard-shortcuts.html&#34;&gt;http://blog.mindmup.com/p/keyboard-shortcuts.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mindmup.com/p/storage-options.html&#34;&gt;http://blog.mindmup.com/p/storage-options.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning Embedded System Note</title>
      <link>/zh/post/learning-embedded-system-note/</link>
      <pubDate>Sun, 09 Mar 2014 13:41:47 +0800</pubDate>
      <guid>/zh/post/learning-embedded-system-note/</guid>
      <description>&lt;iframe src=&#34;https://atlas.mindmup.com/akagi201/sundy_android_low_level/index.html&#34; height=&#34;100%&#34; width = &#34;100%&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;换工作这几个月的时间, 还是挺爽的, 时间完全自由支配. 把之前因为工作比较忙的原因没空学习的东西都恶补了一下, 这几个月太赞了, 积累了不少资源, 把openwrt玩遍了, 将ARM-linux嵌入式完整的学习了一遍, 并用思维导图做了笔记.&lt;/p&gt;
&lt;h2 id=&#34;精华部分&#34;&gt;精华部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;应用层所有的东西包括系统调用, C库, pthread库, socket等等全都在glibc的官方文档里面了&lt;a href=&#34;http://www.gnu.org/software/libc/manual/&#34;&gt;http://www.gnu.org/software/libc/manual/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;很多东西linux和android是相通的, 很多android的东西已经融入到了底层驱动中. 所以, 小米有android的深厚技术基础来发展linux, 相当easy.&lt;/li&gt;
&lt;li&gt;思维导图是个好东西, 用来索引记忆还是不错的. 长篇大论还是去别的地方找好了, 没必要记录太多东西.&lt;/li&gt;
&lt;li&gt;ARM交叉编译工具链下载地址 &lt;a href=&#34;http://www.linaro.org/&#34;&gt;http://www.linaro.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rtc驱动框图&#34;&gt;RTC驱动框图&lt;/h2&gt;
&lt;p&gt;学习了一种工具画流程图工具.&lt;/p&gt;
&lt;iframe id=&#34;embed_dom&#34; name=&#34;embed_dom&#34; frameborder=&#34;0&#34; style=&#34;border:1px solid #000;display:block;width:430px; height:320px;&#34; src=&#34;http://www.processon.com/embed/532d8ae60cf253b242881338&#34;&gt;&lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>无线产品开发流程概述</title>
      <link>/zh/post/wireless-device-workflow/</link>
      <pubDate>Sun, 09 Mar 2014 02:39:08 +0800</pubDate>
      <guid>/zh/post/wireless-device-workflow/</guid>
      <description>&lt;p&gt;本人做无线产品设计已经好多年, 做过的产品大概有三, 四十种, 简单的, 复杂的都有. 现如今我的设计一版成功的概率很大, 即使不能一版成功, 也可以在第一版中实现90%以上的功能, 性能, 朋友们因此还送给我了一下绰号&amp;quot;一版达人&amp;rdquo;. 我想其实我也不是有多么深不可测的技术水平, 可能跟别人相比, 我最大的优点就是细心, 并善于思考. 我想在这里简单地分享一下我的心得体会, 我在这里想大概讲述一下无线产品的开发流程.&lt;/p&gt;
&lt;p&gt;无线产品就是把物理接口上的数据转为在空间传输的电磁波. 物理接口就是CVBS, S/PDIF, HDMI, 网口, 串口, E1, T1, ADSL等, 具体采用什么接口由产品形态决定. 电磁波的特征, 如频率, 频宽, 调制方式等由相关的协议标准决定. 如蓝牙, Zigbee就是指定在2.4GHz频段运行的. 无线产品的硬件设计决定了产品的接口形式, 传输距离, 传输速度的问题. 软件设计决定了数据如传输. 这里主要探讨的是无线产品的硬件设计.&lt;/p&gt;
&lt;h2 id=&#34;无线产品的七大功能模块&#34;&gt;无线产品的七大功能模块&lt;/h2&gt;
&lt;p&gt;有了前面对无线产品的理解, 我把每个硬件产品都分为七大部分, 我想这应该是我首创的, 目前为止我还没有听过别的工程师这样说过.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/wireless-hardware.png&#34; alt=&#34;wireless-hardware&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU+RAM+Flash, 又可以称为最小系统, 是整个产品的核心, 负责所有部分的正常运转.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口, 接口可以分为内部接口和外部接口. 内部接口用于产品内部不同器件之间的连接, 如PCI, MII, I2S, LVDS等. 外部接口是产品与外部进行通信的接口, 如网口, 音视频接口, 天线接口等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;射频, 无线产品的射频设计是至关重要的, 整个产品的最重要的性能几乎全部体现在这里, 这部分在根本上决定了无线传输的距离, 可靠性.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电源, 电源是整个产品的&amp;quot;营养供给&amp;rdquo;, 保证了电源的&amp;quot;营养丰富, 健康&amp;rdquo;, 才能确保产品整体的稳定性.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟, 在大多数人眼中, 时钟可能都是一个不起眼的小角色, 但是, 在无线产品中, 很多实际问题都是由时钟及其附属电路引起的, 所以我向来都足够重视时钟电路.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位, 复位在整个产品中也许随处可见, 大部分芯片都需要进行复位, 可靠的复位是产品稳定工作的又一重要保证.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按键, LED, GPIO, 有人可能会说, 这部分还值得一提吗? 我认为值得. 按键与LED是最直观的UI, 无线产品中的其他部分几乎都与UI无关, 同时, 按键, LED一般都是连接在GPIO上的, GPIO往往又起到上电配置的作用, 因此, 我认为GPIO很重要.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一般开发流程&#34;&gt;一般开发流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/wireless-hardware-designflow.gif&#34; alt=&#34;wireless-hardware-designflow&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.beamsky.com/topics/wireless-product-design-overview.html&#34;&gt;http://www.beamsky.com/topics/wireless-product-design-overview.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>802.11ac路由选购技术攻略 -- 不花冤枉钱的ac网络架设指南</title>
      <link>/zh/post/802_11ac-hardware/</link>
      <pubDate>Sat, 08 Mar 2014 09:08:08 +0800</pubDate>
      <guid>/zh/post/802_11ac-hardware/</guid>
      <description>&lt;p&gt;802.11ac虽然还在草拟草案的阶段(
&lt;a href=&#34;http://grouper.ieee.org/groups/802/11/Reports/802.11_Timelines.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IEEE的时间表&lt;/a&gt;
), 但科技不待人. 对于高速WiFi高速无线传输的殷切需求, 各大厂家已经陆续推出旗舰无线路由, 价钱还不断下降, 连双核AC路由也进入千元以内消费级别之列. 802.11ac制式的无线路由应该如何选择?&lt;/p&gt;
&lt;h2 id=&#34;为什么要买ac路由-3天线的n900路由确实不够用吗&#34;&gt;为什么要买ac路由? 3天线的N900路由确实不够用吗?&lt;/h2&gt;
&lt;p&gt;为什么开头要先问这个问题, 因为购买一套802.11ac上网设备价钱不菲! 以旗舰1750ac为例, 很多人讨论的Asus ac66u要1050RMB, 双核D-Link DIR-868L要900RMB, 而匹配AC1750的PCI-E卡插网卡(3天线)要600RMB, 也就是说总的成本很可能在1500RMB以上!&lt;/p&gt;
&lt;p&gt;换句话说, 你确定用超过1500元去突破802.11n的速度极限值得吗?&lt;/p&gt;
&lt;p&gt;不卖关子了, 802.11n的WiFi无线的实际速度极限是: 200Mbps. 升级802.11ac是笔大投资, 要慎重考虑.&lt;/p&gt;
&lt;h2 id=&#34;ac1200-ac1300-ac1750购买前先了解ac制式&#34;&gt;AC1200, AC1300, AC1750…购买前先了解AC制式&lt;/h2&gt;
&lt;p&gt;AC路由的最高理论速度有好几种, 譬如说D-Link就已经有7款AC路由, 当然把自己的产品线过度复杂化未必是明智选择, Asus现在有3款, ac66, ac56u和ac68u. Asus的新款AC68也即将推出, 速度能达到AC1900.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/asus-rtac68u.png&#34; alt=&#34;ASUS AC products&#34;&gt;&lt;/p&gt;
&lt;p&gt;先说这些1200, 1750数值是怎么来的, 是不是1750的理论连接最高速度是1750Mbps? 不是的. 根据SmallnetBuilder总结的行业现行命名准则:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ac路由的标称速度 = n制式的理论最高速度 + ac制式的理论最高速度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/acrouter-speed.jpg&#34; alt=&#34;Proposed router class summary&#34;&gt;&lt;/p&gt;
&lt;p&gt;至于为什么ac制式会有不同速度和天线数量, 与下文要解释的QAM Coding传输模式有关.&lt;/p&gt;
&lt;p&gt;应该如何选择哪个速度的ac路由器? 除了​​考虑价格和家里上网接入的带宽之外, 十分重要的一点是接收端是否匹配. 例如说ac68是MIMO 3X3也就是3天线的产品, 它的ac理论极限速度是1300Mbps, 要匹配3天线的接收器才能发挥这个速度. 那3天线的接收器要多少钱? Asus自己出的要600多RMB.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/acnet.jpg&#34; alt=&#34;acnet&#34;&gt;
3天线ac接收器的价钱不菲, ASUS的这款要600多RMB.&lt;/p&gt;
&lt;p&gt;请注意了! 现在很多商家夸大USB AC接收器的接收能力! 例如这款Netgear的A6200, 在官网写明了是867Mbps的速率(ac双天线的极限速度), 但是不少商家却标称其是AC1750 USB网卡!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/netgear-A6200.jpg&#34; alt=&#34;netgear a6200&#34;&gt;&lt;/p&gt;
&lt;p&gt;这款Netgear A6200的真面目是2×2 MIMO的USB网卡.&lt;/p&gt;
&lt;p&gt;总的来说, 3天线的ac路由器就需要搭配3天线的接收网卡, 双天线就搭配双天线. 那么手机呢?和n制式时代一样, 都是单天线的天下. 例如Samsung Galaxy S4是用Broadcom 4335 WiFi芯片单天线.&lt;/p&gt;
&lt;h2 id=&#34;80211ac-coding和极限速度的关系&#34;&gt;802.11ac Coding和极限速度的关系&lt;/h2&gt;
&lt;p&gt;对比起现行主流的802.11n, 802.11ac提供更加复杂的数模转换无线传输方式(Modulation), 这是ac跑得快的核心因素. 什么是Modulation? 从Wiki借用一张图解释:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/QAM16_Demonstration.gif&#34; alt=&#34;QAM16_Demonstration&#34;&gt;&lt;/p&gt;
&lt;p&gt;16 QAM 的解码模式&lt;/p&gt;
&lt;p&gt;众所周知, WiFi信号是无线电波, 无线电波有相位和强弱的特征值. QAM的转换模式就是把数据包放到不同相位和不同强弱的电波上. 16-QAM就是有16个相位和强弱的信号点, 所以, 接收端通过一次读取16个信号点就可以获得16个数据包.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/modulation-data-rate.jpg&#34; alt=&#34;modulation-data-rate&#34;&gt;&lt;/p&gt;
&lt;p&gt;802.11n和ac Modulation的关系，现行的ac最主要在80MHz上运行&lt;/p&gt;
&lt;p&gt;从上图可以看出n和ac的编码差别: 802.11n支持64-QAM, 跑在40MHz, 而802.11ac可以支持256-QAM, 跑在160MHz. 简单说明, 就是n制式是64部车走在40米宽的路上, 802.11ac是256部车跑在160米宽的路上. 所以ac制式的理论速度比n快上几倍. 现行的ac最主要在80MHz上运行, 所以单天线ac的理论速度能跑到433Mbps, 双天线867Mbps, 三天线1300Mbps.&lt;/p&gt;
&lt;p&gt;上图的QAM速度仅仅是标准的QAM速度, 不同厂家可以作出优化, 例如ASUS的AC68声称能达到AC1900, Smallnetbuilder写了一篇分析文章分析ASUS无线路由的AC1900是怎么来的, 最后ASUS, Broadcom官方的解释是作出了一定程度的修改. 这又为大家选购AC路由增加了麻烦, ASUS的加速算法Buffalo未必支持, Broadcom的算法Atheros未必支持, 在选购时候特别要留意路由器和接收网卡的匹配. Upsangel和SmallNetBuider更加觉得, AC1900只是&amp;quot;作秀科技&amp;quot;的产物, 营销意义大于速度的实质提升:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://upsangel.com/router-2/ac1900-performance-and-price-trap/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标签陷阱？802.11AC“最高规格”ac1900路由器Router是否值得买&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ac实际传输速度到底比n快多少&#34;&gt;ac实际传输速度到底比n快多少?&lt;/h2&gt;
&lt;p&gt;什么N450, AC1750这些都是标称速度, 我们用户关心的是实际速度! 下面就列一下802.11ac和802.11n的无线路由器实际速度差距(约数, 不为精准参考):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N制式：双天线(N300/N600) – 80Mbps， 三天线（N450/N900) – 200Mbps&lt;/li&gt;
&lt;li&gt;AC制式：双天线(AC1200) – 300Mbps，三天线（AC1600/AC1750) – 350Mbps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说, 200Mb带宽的家庭用3天线的n制式可能吃饱, 稳定地吃饱的话要用ac. ac现时的极限速度在350Mbps左右, 200Mb以上的宽带上网很难用ac WiFi吃饱. 接着分析802.11ac的不足之处, 不要买了后悔.&lt;/p&gt;
&lt;h2 id=&#34;80211ac的弱项不足&#34;&gt;802.11ac的弱项不足&lt;/h2&gt;
&lt;h3 id=&#34;高频段传输--穿墙能力减弱&#34;&gt;高频段传输 = 穿墙能力减弱&lt;/h3&gt;
&lt;p&gt;频率越高穿墙性能越低(在WiFi这个频段适用, 如果在X射线的频段频率越高就穿透力越强, 见多普勒的光粒二像性). 还记得香港4G刚刚出炉的时候, 数码通打着的旗号就是信号好, 因为其用的4G频谱频率比其他电讯商的低. 上面说了ac由于要跑256-QAM, 在宽频段(80MHz)才能跑得到, 而80MHz只能在5GHz的高频段跑, 因为2.4GHz已经拥挤不堪互相干扰严重(不信你搜一下家里收到多少个邻居的2.4G信号, 我搜到20个). 所以如果你家很多墙, ac未必能发挥其快速性能.&lt;/p&gt;
&lt;h3 id=&#34;占用频宽倍增--更容易受干扰&#34;&gt;占用频宽倍增 = 更容易受干扰&lt;/h3&gt;
&lt;p&gt;由于要占用80MHz～160MHz的频宽作传输, 使得信号有更加大的机会被干扰. 例如最典型的例子是USB 3.0和2.4GHz的频率冲突:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/usbwifi5g.jpg&#34; alt=&#34;usbwifi5g&#34;&gt;&lt;/p&gt;
&lt;p&gt;USB3.0和WiFi 5GHz的频率重叠干扰&lt;/p&gt;
&lt;h3 id=&#34;欠缺第三方firmware支援&#34;&gt;欠缺第三方Firmware支援&lt;/h3&gt;
&lt;p&gt;如果你是DD-WRT/OpenWRT的玩家, 那么选购ac路由要特别注意了, 因为第三方软件和驱动的开发未必跟得上官方新硬件的开发. 可能没有第三方Firmware的支援, 不能刷ROM.(主要是硬件平台model太新, 开源界跟进还需要时间, 而不是ac路由器不容易支持开源固件)&lt;/p&gt;
&lt;h2 id=&#34;ac路由的选购&#34;&gt;AC路由的选购&lt;/h2&gt;
&lt;p&gt;本文集中谈到了802.11ac制式所引伸的选购问题, 而基本的无线路由器的选购原则绝对不能忽略, 包括路由CPU和内存的选择, 天线的选择等, 一定要参阅本站最热门的文章(台湾upsangel的博客):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://upsangel.com/dd-wrt/router-technical-buying-guide/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 买什么路由好? 技术结合实际的Router攻略! - 扔掉各大网站的&amp;quot;广告/导购&amp;quot;吧!&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说到怎么比较AC路由器的性能, 著名的网站SmallNetBuilder可以给我们不少参考, 其中最多人关心的AC WiFi速度比较图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/1750ac.jpg&#34; alt=&#34;1750ac&#34;&gt;&lt;/p&gt;
&lt;p&gt;AC1750的速度比较图, 上传+下载&lt;/p&gt;
&lt;p&gt;SmallNetBuider有很多有用的资讯, 对路由的评测比较专业和客观. 不要单看这些速度指标来买路由, 因为这些测试是在关闭所有防火墙和应用的情况下进行的测试, 实际用起来未必一样.&lt;/p&gt;
&lt;p&gt;Upsangel最后列一下主流的AC路由器, 如有遗漏请告知:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASUS：RT-AC66 (AC1750), AC68 (AC1900)、AC56u&lt;/li&gt;
&lt;li&gt;Belkin：AC1200 DB&lt;/li&gt;
&lt;li&gt;Buffalo：WZR-1166DHP (AC1200) 、WZR-1750DHP (AC 1750)&lt;/li&gt;
&lt;li&gt;D-Link：AC750、AC1000、AC1200、AC1300、AC1750&lt;/li&gt;
&lt;li&gt;Linksys：EA6300、EA6400、EA6500、EA6700，除第一款其他3款为AC1300&lt;/li&gt;
&lt;li&gt;NetGear：R6200、R6250、R6300&lt;/li&gt;
&lt;li&gt;TP-Link：Archer C7、TL-WDR7500&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**最后, Upsangel为大家奉上玩转路由器附加强大功能的攻略(架设VPN Server、共享Printer、Scanner、离线BT等)，请参考: **

&lt;a href=&#34;http://www.hkepc.com/forum/viewthread.php?tid=2025967&amp;amp;extra=page%3D1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;普通視像頭+OpenWRT變 IP CAM - OpenWRT, DD-WRT資源補完&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wemaker.cc/167&#34;&gt;http://wemaker.cc/167&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/zh/post/openwrt-10-years/</link>
      <pubDate>Sat, 08 Mar 2014 02:37:08 +0800</pubDate>
      <guid>/zh/post/openwrt-10-years/</guid>
      <description>&lt;p&gt;如果不是为了写这篇文章, 笔者还真没意识到OpenWrt这个项目已经10年了.&lt;/p&gt;
&lt;p&gt;在这个重新强调人工智能, 机器学习, 重新重视物理机械交互的新兴智能机器人的时代, 我们有理由相信因为其纯正的Linux味道, 小型化, 亲近物理交互的特征, 身为Linux社区与物理交互的最佳桥梁, OpenWrt会迎来新一轮的发展.&lt;/p&gt;
&lt;p&gt;一切都始于2002年12月, Linksys发布了定义家用无线路由器产品形态的WRT54G, 由于成本的原因, Linksys使用Linux作为固件而不是授权费用很高的VxWorks. 根据GPL条款, 据称是哥伦比亚大学法学院教授Eben Moglen向Linksys提出了开源要求, Linksys随即照办, 之后在一堆各种hack WRT54G固件中, 2004年生长出来了OpenWrt. 2005年到2007年, 最初的稳定版叫White Russian, 之后的Kamikaze延续到2010年, Backfire到2013年, 随后Attitude Adjustment发布, 而最新版的Barrier Breaker也已经在持续开发中, 据称将很快发布.&lt;/p&gt;
&lt;p&gt;从一开始, OpenWrt就是各类路由器hack固件中的领头羊, 并成为嵌入式Linux系统的核心贡献者之一, 特别是Linux on mips, 最近的内核更新代码有很大部分是由OpenWrt社区贡献的.&lt;/p&gt;
&lt;p&gt;在各种路由器的hack固件中, OpenWrt为什么能脱颖而出? 笔者认为关键原因是OpenWrt社区彻底的开源精神, 不要忽视&lt;a href=&#34;http://openwrt.org&#34;&gt;http://openwrt.org&lt;/a&gt;上面明晃晃的&amp;quot;Wireless Freedom&amp;quot;几个字. OpenWrt社区的组织者Gregers Petersen第一title是人类学家, 专注于自由软件及相关社会学研究. 以此为基因, OpenWrt社区聚集了一大批纯正的Linux各个方向的死忠级专家, 从而使OpenWrt具备了如下与传统nor flash嵌入式Linux截然不同的高级特征:&lt;/p&gt;
&lt;h2 id=&#34;1squashfs与jffs2文件系统的整合形成的overlayfs机制&#34;&gt;1.SquashFS与JFFS2文件系统的整合形成的overlayfs机制&lt;/h2&gt;
&lt;p&gt;对用户而言, OpenWrt的整个文件系统是完全动态可读写的, 而其中的固件部分是用SquashFS实施的只读压缩文件系统, 而用户所有的对文件系统的增删改都是用类似&amp;quot;差值&amp;quot;的形态存储在JFFS2文件系统中的, 二者用overlayfs机制黏合, 对用户完全透明. 因此我们可以在文件系统中肆意发挥, 随便折腾, 出现任何问题则可像手机一样恢复出厂设置, 并提供fail-safe模式帮助用户修复系统.&lt;/p&gt;
&lt;p&gt;而在传统的嵌入式Linux里, 固件是静态的, 对系统做任何一点与可运行程序相关的变动, 比如增加一个模块, 删除一个应用程序, 都要重新编译全部固件, 并重新刷写, 就好比你一个Android手机要升级微信就要重新刷机. 这种反人类的传统文件系统完全阻挡了非专业爱好者进入嵌入式Linux这一领域.&lt;/p&gt;
&lt;h2 id=&#34;2-uciunified-configuration-interface&#34;&gt;2. UCI(Unified Configuration Interface)&lt;/h2&gt;
&lt;p&gt;帮助用户在任何平台的OpenWrt上用同样的方法配置系统, 网络和应用. 在Boardcom的平台上, 在Atheros的平台上, 甚至x86的平台上, 修改系统配置均为同样的命令. 而UCI的机制并不是二进制硬件虚拟层实现的, 是由Linux shell脚本实现的. 这毫无疑问是一种别致的创新, 比Android来的轻巧得多. OpenWrt里的Linux shell脚本用得很帅很高端, 那种感觉怎么形容呢? 就好像精通十八般武艺的高手有一天特别复古地拿起铅笔刀在硬盘上刻出来了系统, 就是这种感觉.&lt;/p&gt;
&lt;h2 id=&#34;3-opkg包管理系统与丰富的软件源&#34;&gt;3. Opkg包管理系统与丰富的软件源&lt;/h2&gt;
&lt;p&gt;是一个与桌面级Linux使用的apt-get, yum等同级别的包管理系统, 使用形如: &lt;code&gt;opkg install xxxx-app&lt;/code&gt; 的命令从互联网软件源中安装大约3000余种各种软件. 软件数量虽然没法跟手机的应用市场比, 但是要知道, 这里头的任何一个软件都来头不小, 是经过Linux社区千锤百炼的东西, 一个应用折腾一个月都玩不够. 类型覆盖网络, 音频, 视频, 程序开发, Linux系统管理等. 当然, 如果是专业比较偏的东西OpenWrt的软件源里还是不够完善, 比如笔者团队用到的OpenCV的东西, 源里就没有, 就靠自己交叉编译了.&lt;/p&gt;
&lt;h2 id=&#34;4-luci-web界面系统&#34;&gt;4. Luci WEB界面系统&lt;/h2&gt;
&lt;p&gt;除CLI命令行终端界面外, 不同于桌面级Linux使用屏幕GUI作为交互界面, OpenWrt使用WEB界面交互. 而不同于传统路由器web管理界面的是, luci是用户可订制的, 安装了支持luci的软件后, WEB界面系统就中出现了新的模块, 而opkg本身也web化了.这个特征让用户感觉很像手机的app store.&lt;/p&gt;
&lt;h2 id=&#34;5积极-完整的社区&#34;&gt;5.积极, 完整的社区&lt;/h2&gt;
&lt;p&gt;OpenWrt与Arch Linux, Debian, FFmpeg, MinGW, PostgreSQL等开源领域重要的软件一起, 是Software in the Public Interest, Inc.资助和保护的项目, OpenWrt社区在美国, 欧洲, 中国, 俄罗斯有大量的追随者, 有不计其数的分支和代码贡献者. 社区活跃度非常高.&lt;/p&gt;
&lt;p&gt;这几个特征加起来, 赋予OpenWrt比肩桌面级Linux和现代移动操作系统(Android)的用户体验, 完全回避了传统嵌入式Linux的磨叽和枯燥, 使一个小小的路由器真正成为完整的, 现代的, 开放的计算系统, 降低了入门门槛, 产生了大量非嵌入式专业的爱好者群体. OpenWrt框架的奠定者们和广泛的代码贡献者们, 在桌面级和现代操作系统的理念下, 也使OpenWrt成为嵌入式Linux领域个性十足而广受追捧的佼佼者.&lt;/p&gt;
&lt;p&gt;OpenWrt社区的组织者Gregers Petersen在一次采访中提到, 除了传统的路由器用途, 在智能家居主控设备, 机器人, 飞行器, 工业控制设备, voIP设备等很多领域, 都有爱好者和商业项目在使用OpenWrt, 甚至有爱好者已经完整移植了Android系统并且真正打通了电话. 而嫁接到OpenWrt上的Arduino Yun, 使大家意识到Linux与物理世界交互一种非常简单的可能性, 这赋予了OpenWrt更大的想象空间.&lt;/p&gt;
&lt;p&gt;在新型智能设备和机器人的热潮中, OpenWrt的价值也越来越得到人们的重视. 相比Android系统, OpenWrt被认为是更加适应智能设备和机器人的平台. Android的整体设计构架全部着眼于重度依赖屏幕与人进行交互, 导致从硬件到软件的设计上都严重依赖于图形界面的展示, 有过多的GPU硬件加速和软件上的图形, 3D库, 而智能设备和机器人并不强调屏幕, 相对更多地依赖于机械, 网络与人进行交互, Android上的这些图形图像特征反倒成为影响功耗, 系统尺寸, 稳定性的负面因素. 再加之相对于Android的Java虚拟机对效率的严重损耗, OpenWrt直接的原生二进制代码得到了更高的计算效率.&lt;/p&gt;
&lt;p&gt;在这个重新强调人工智能, 机器学习, 重新重视物理机械交互的新兴智能机器人的时代, 我们有理由相信因为其纯正的Linux味道, 小型化, 亲近物理交互的特征, 身为Linux社区与物理交互的最佳桥梁, OpenWrt会迎来新一轮的发展.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wemaker.cc/322&#34;&gt;http://wemaker.cc/322&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>OpenWrt开发文档</title>
      <link>/zh/post/openwrt-developing/</link>
      <pubDate>Sat, 22 Feb 2014 02:44:08 +0800</pubDate>
      <guid>/zh/post/openwrt-developing/</guid>
      <description>&lt;h3 id=&#34;优秀文档中文项目-欢迎你的加入&#34;&gt;优秀文档中文项目-欢迎你的加入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://akmaker.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;AK创客空间&lt;/strong&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/AKmaker/openwrt-cn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;OpenWrt中文化项目&lt;/strong&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;wiki&#34;&gt;wiki&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/start&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki导航&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://downloads.openwrt.org/docs/buildroot-documentation.html#about&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;早期OpenWrt编译文档&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/about/toolchain&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;工具链&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/buildroot.exigence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;编译准备&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/build&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;编译&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/devel/feeds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;添加feeds&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/obtain.firmware.generate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Image Builder&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/obtain.firmware.sdk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SDK&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howtobuild/extroot.howtobuild&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rootfs on External Storage (extroot) (1/2)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/extroot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rootfs on External Storage (extroot) (2/2)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howtobuild/wireless-router-with-a-3g-dongle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wireless router which is connected to either a wired, a wireless or a 3G wireless connection&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howtobuild/single.package&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How to Build a Single Package&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开发&#34;&gt;开发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/devel/crosscompile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cross Compile&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://forum.openwrt.org/viewtopic.php?id=32330&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;外部编译器设置-(1/3)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://forum.openwrt.org/viewtopic.php?id=29804&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;外部编译器设置-(2/3)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://forum.openwrt.org/viewtopic.php?id=12436&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;外部编译器设置-(3/3)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/devel/packages&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Creating packages&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/devel/feeds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Feeds&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/devel/dependencies&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Using Dependencies&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://dev.openwrt.org/wiki/SubmittingPatches&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How To Submit Patches to OpenWrt&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/external_toolchain&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;External Toolchain - Use OpenWrt as External Toolchain (1/2)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://lists.openwrt.org/pipermail/openwrt-devel/2009-February/003774.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;External Toolchain - Use OpenWrt as External Toolchain (2/2)&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/openme_openwrt/article/details/7348452&#34;&gt;http://blog.csdn.net/openme_openwrt/article/details/7348452&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>移植OpenWrt到pcDuino</title>
      <link>/zh/post/port-openwrt-to-pcduino/</link>
      <pubDate>Wed, 19 Feb 2014 10:34:08 +0800</pubDate>
      <guid>/zh/post/port-openwrt-to-pcduino/</guid>
      <description>&lt;h3 id=&#34;openwrt&#34;&gt;OpenWrt&lt;/h3&gt;
&lt;p&gt;OpenWrt是一个高度模块化, 高度自动化的嵌入式Linux系统, 拥有强大的网络组件, 常常被用于工控设备, 电话, 小型机器人, 智能家居, 路由器以及VOIP设备中. OpenWrt支持各种处理器架构，无论是对ARM，X86，PowerPC或者MIPS都有很好的支持. 其多达3000多种软件包, 囊括从工具链(toolchain), 到内核(linux kernel), 到软件包(packages), 再到根文件系统(rootfs)整个体系, 使得用户只需简单的一个make命令即可方便快速地定制一个具有特定功能的嵌入式系统来制作固件. 其模块化设计也可以方便的移植各类功能到OpenWrt下, 加快开发速度.&lt;/p&gt;
&lt;p&gt;对于开发人员, OpenWrt是使用框架来构建应用程序, 而无需建立一个完整的固件来支持. 对于用户来说, 这意味着其拥有完全定制的能力, 可以用前所未有的方式使用该设备.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/openwrt-logo.png&#34; alt=&#34;openwrt-logo&#34;&gt;&lt;/p&gt;
&lt;p&gt;2014年12月19日小米路由器公测版正式发售, 也意味着OpenWrt进入国内主流科技企业的眼球. 然而OpenWrt到底是一款什么样的操作系统呢? 对于创客来讲, 怎么才能融入创客的设计, 下面就从零介绍如果在pcDuino上开发OpenWrt.&lt;/p&gt;
&lt;p&gt;OpenWrt项目始于2004年1月. 最早的OpenWrt版本基于Linksys为遵守GPL而放出的, 为WRT54G所编写的代码, 以及uclibc项目的buildroot. 这个版本以OpenWrt &amp;ldquo;stable release&amp;quot;之名为人所知, 使用广泛. 仍有许多OpenWrt应用程序是基于这一版的, 例如Freifunk-Firmware和Sip@Home.&lt;/p&gt;
&lt;p&gt;2005年初, 一些新的开发者进入了团队. 在封闭开发了数月之后, 团队决定发布OpenWrt的第一个experimental版本. 这个实验版本使用的build系统是基于buildroot2大改而成的, 而buildroot2来自于uclibc项目. OpenWrt使用官方版GNU/Linux内核代码, 只是额外添加了片上系统(SoC)的补丁和网络接口的驱动. 开发团队尝试重新实现GPL tarball中不同开发商的绝大多数专有代码. 其中有: 将新固件镜像文件直接写入闪存的自由工具(mtd), 配置无线局域网(wlcompat/wificonf), 通过proc文件系统对支持VLAN的switch(交换机)进行编程. 最初发布的OpenWrt的代号是&amp;quot;White Russian&amp;rdquo;, 来自于著名鸡尾酒的名称. 在OpenWrt发布0.9版的时候, White Russian的生命周期结束.&lt;/p&gt;
&lt;p&gt;下一个版本的开发正在我们的SVN中进行. 下面一张图将很清晰的反映OpenWrt的版本史. 从图上可以看出最新的稳定版本代号为Attitude Adjustment, 早期的稳定版本为Backfire 和 Kamikaze, 开发版本一直都是trunk. 各个版本的官方下载地址为 &lt;a href=&#34;https://dev.openwrt.org/wiki/GetSource&#34;&gt;https://dev.openwrt.org/wiki/GetSource&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/code_overview.png&#34; alt=&#34;code_overview&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;下载编译openwrt&#34;&gt;下载编译OpenWrt&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;安装依赖包(deb系列)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo aptitude install -y libncurses5-dev zlib1g-dev gawk flex patch git-core g++ subversion
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;OpenWrt的源代码管理默认用的是SVN, 当然你还可以用Git, 本教程中使用最新的trunk版本, 用SVN工具下载源码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;svn co svn://svn.openwrt.org/openwrt/trunk/ openwrt-pcduino
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以用Git下载&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://git.openwrt.org/openwrt.git
git clone git://git.openwrt.org/packages.git
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;扩展软件包package feeds, feeds即为包含到你的OpenWrt环境中的额外软件包的软件列表索引(类似linux发行版中的软件源, 不过此处为软件包的源码). 目前常用的feeds有:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;src-git packages git://git.openwrt.org/packages.git
src-svn xwrt http://x-wrt.googlecode.com/svn/trunk/package
src-git luci git://nbd.name/luci.git
src-git routing git://github.com/openwrt-routing/packages.git
src-git telephony http://feeds.openwrt.nanl.de/openwrt/telephony.git
src-svn phone svn://svn.openwrt.org/openwrt/feeds/phone
src-svn efl svn://svn.openwrt.org/openwrt/feeds/efl
src-svn xorg svn://svn.openwrt.org/openwrt/feeds/xorg
src-svn desktop svn://svn.openwrt.org/openwrt/feeds/desktop
src-svn xfce svn://svn.openwrt.org/openwrt/feeds/xfce
src-svn lxde svn://svn.openwrt.org/openwrt/feeds/lxde
src-link custom /usr/src/openwrt/custom-feed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般情况, 你至少需要含packages feeds, 其他可根据需求下载, 安装feeds.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;packages – 提供众多库, 工具等基本功能. 也是其他feed所依赖的软件源, 因此在安装其他feed前一定要先安装packages!&lt;/li&gt;
&lt;li&gt;luci – OpenWrt默认的GUI(WEB管理界面).&lt;/li&gt;
&lt;li&gt;xwrt – 另一种可替换LuCI的GUI&lt;/li&gt;
&lt;li&gt;qpe – DreamBox维护的基于Qt的图形界面, 包含Qt2, Qt4, Qtopia, OPIE, SMPlayer等众多图形界面.&lt;/li&gt;
&lt;li&gt;device – DreamBox维护与硬件密切相关的软件, 如uboot, qemu等.&lt;/li&gt;
&lt;li&gt;dreambox_packages – DreamBox维护的国内常用网络工具, 如oh3c, njit8021xclient等.&lt;/li&gt;
&lt;li&gt;desktop - OpenWrt用于桌面的一些软件包.&lt;/li&gt;
&lt;li&gt;xfce - 基于Xorg的著名轻量级桌面环境. Xfce建基在GTK+2.x之上, 它使用Xfwm作为窗口管理器.&lt;/li&gt;
&lt;li&gt;efl - 针对enlightenment.&lt;/li&gt;
&lt;li&gt;phone -针对fso, paroli.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Trunk中默认的feeds下载有packages、xwrt、luci、routing、telephony。如果你需要其他的软件包，你只需要打开源码根目录下面的feeds.conf.default文去掉你需要的软件包前面的#号，本教程中使用默认的软件，确定了软件源之后，更新源:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/feeds update -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装下载好的包:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/feeds install -a
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;OpenWrt源码目录结构, 执行上面命令之后你就可以得到全部的Openwrt源码.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目录结构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tools和toolchain包含了一些通用命令, 用来生成固件, 编译器, 和C库.&lt;/li&gt;
&lt;li&gt;build dir/host是一个临时目录, 用来储存不依赖于目标平台的工具.&lt;/li&gt;
&lt;li&gt;build dir/toolchain-&lt;arch&gt;用来储存依赖于指定平台的编译链. 只是编译文件存放目录无需修改.&lt;/li&gt;
&lt;li&gt;build dir/target-&lt;arch&gt;用来储存依赖于指定平台的软件包的编译文件, 其中包括linux内核, u-boot, packages, 只是编译文件存放目录无需修改.&lt;/li&gt;
&lt;li&gt;staging_dir是编译目标的最终安装位置, 其中包括rootfs, package, toolchain.&lt;/li&gt;
&lt;li&gt;package软件包的下载编译规则, 在OpenWrt固件中, 几乎所有东西都是.ipk, 这样就可以很方便的安装和卸载.&lt;/li&gt;
&lt;li&gt;target目标系统指嵌入式设备, 针对不同的平台有不同的特性, 针对这些特性, &amp;ldquo;target/linux&amp;quot;目录下按照平台&lt;arch&gt;进行目录划分, 里面包括了针对标准内核的补丁, 特殊配置等.&lt;/li&gt;
&lt;li&gt;bin编译完OpenWrt的二进制文件生成目录, 其中包括sdk, uImage, u-boot, dts, rootfs构建一个嵌入式系统完整的二进制文件.&lt;/li&gt;
&lt;li&gt;config存放着整个系统的的配置文件.&lt;/li&gt;
&lt;li&gt;docs里面不断包含了整个宿主机的文件源码的介绍, 里面还有Makefile为目标系统生成docs.&lt;/li&gt;
&lt;li&gt;include里面包括了整个系统的编译需要的头文件, 但是是以Make进行连接的.&lt;/li&gt;
&lt;li&gt;feeds扩展软件包索引目录.&lt;/li&gt;
&lt;li&gt;scripts组织编译整个OpenWrt的规则.&lt;/li&gt;
&lt;li&gt;tmp编译文件夹, 一般情况为空.&lt;/li&gt;
&lt;li&gt;dl所有软件的下载目录, 包括u-boot, kernel.&lt;/li&gt;
&lt;li&gt;logs如果编译出错, 可以在这里找到编译出错的log.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;配置OpenWrt编译系统&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/openwrt-buildroot.png&#34; alt=&#34;openwrt-buildroot&#34;&gt;&lt;/p&gt;
&lt;p&gt;在官方最新的trunk分支中已经支持pcDuino这个target了.&lt;/p&gt;
&lt;p&gt;具体配置如下:
A. 配置目标系统(Target System)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Target System (Allwinner A1x/A20/A3x) —&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B. 配置目标硬件(Target Profile)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Target Profile (pcDuino) —&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C. 配置编译出来的image, 配置rootfs文件系统的格式这里选择ext4, rootfs文件系统的大小这里设置(48M).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Target Images  —&amp;gt; 
[ ] ramdisk  —&amp;gt; 
*** Root filesystem archives *** 
[ ] cpio.gz
[*] tar.gz 
*** Root filesystem images *** 
[*] ext4
[ ] jffs2
[ ] squashfs
[*] GZip images
*** Image Options ***
(48) Root filesystem partition size (in MB)
(6000) Maximum number of inodes in root filesystem
(0) Percentage of reserved blocks in root filesystem
[ ] Include kernel in root filesystem  —&amp;gt;
[ ] Include DTB in root filesystem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;D. 选择编译交叉编译器, 还有开发SDK.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[*] Build the OpenWrt Image Builder
[*] Build the OpenWrt SDK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E. 配置无线网卡, V2/V3都是用的rtl8188cus无线网卡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Kernel modules  —&amp;gt;
Wireless Drivers  —&amp;gt;
-*- kmod-cfg80211…………………. cfg80211 – wireless configuration API
&amp;lt;*&amp;gt; kmod-lib80211……………………………… 802.11 Networking stack
{M} kmod-mac80211………………… Linux 802.11 Wireless Networking Stack
&amp;lt;M&amp;gt; kmod-rtl8192cu………………….. Realtek RTL8192CU/RTL8188CU support
{M} kmod-rtlwifi……………………………. Realtek common driver part 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F. LucI系统快速配置接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LuCI  —&amp;gt;

1. Collections  —&amp;gt;
{*} luci
&amp;lt;M&amp;gt; luci-ssl……………………. Standard OpenWrt set with HTTPS

4. Themes  —&amp;gt; 
-*- luci-theme-base…………………………. Common base for all
-*- luci-theme-bootstrap……………………… Bootstrap Theme
&amp;lt;*&amp;gt; luci-theme-freifunk-bno……………….. Freifunk Berlin Nordost Theme
&amp;lt;*&amp;gt; luci-theme-freifunk-generic………………….. Freifunk Generic Theme
&amp;lt;*&amp;gt; luci-theme-openwrt……………………………………. OpenWrt.org

5. Translations  —&amp;gt;
&amp;lt;*&amp;gt; luci-i18n-chinese………………….. Chinese (by Chinese Translators)
-*- luci-i18n-english………………………………………… English
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;编译OpenWrt系统&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make –j 8 V=s 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于OpenWrt整个系统非常庞大, 编译很慢. &amp;ldquo;-j 8&amp;rdquo; 表示用8线程进行编译, &amp;ldquo;V=s&amp;quot;编译的时候显示编译信息. 如果你的电脑是4核建议你用8线程进行编译, 双核建议你使用4线程. 这里测试8线程编译需要一个小时才能编译完成.&lt;/p&gt;
&lt;h3 id=&#34;构建pcduino-bsp&#34;&gt;构建pcDuino BSP&lt;/h3&gt;
&lt;p&gt;由于OpenWrt的u-boot用的是u-boot-2013的版本, 目前只支持SD卡启动, 而且内核用的是3.12.5版本. 另外我们的3.4.29的内核用的是全志fex, 而且3.12.5用的是linux官方的kernel使用的是dts设备树.这样的话我们就不能用之前的BSP方案, 我们要自己做一个从SD卡启动的系统.&lt;/p&gt;
&lt;p&gt;pcDuino从SD卡启动顺序是A10—&amp;gt;u-boot–&amp;gt;uImage–&amp;gt;OpenWrt.&lt;/p&gt;
&lt;p&gt;根据全志官网的说明, 这些软件都必须放在SD卡固定的地址. 那么首先要对A10进行分区. 根据全志芯片的说明, 需要对SD卡进行下表固定分区.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/a10-flash.png&#34; alt=&#34;a10-flash&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先格式化TF卡前面的1M空间, 这里是将TF卡通过读卡器插入到PC的虚拟机. 可以看出TF卡的设备是sdb.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       195G   60G  126G  33% /
udev            989M  4.0K  989M   1% /dev
tmpfs           400M  940K  399M   1% /run
none            5.0M     0  5.0M   0% /run/lock
none            998M   76K  998M   1% /run/shm
/dev/sdb1       3.8G   12K  3.8G   1% /media/0005-559B

sudo dd if=/dev/zero of=/dev/sdb bs=1M count=1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;写入u-boot-spl.bin和u-boot.bin. OpenWrt的生成的二进制文件都在openwrt/trunk/bin/sunxi目录下, 这里OpenWrt做了一些工作将u-boot-spl.bin和u-boot.bin合在了一起, 只需要把openwrt-sunxi-pcDuino-sunxi-with-spl.bin写到&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd  uboot-sunxi-pcDuino
pillar@monster:~/openwrt/trunk/bin/sunxi/uboot-sunxi-pcDuino$ ls 
openwrt-sunxi-pcDuino-sunxi-spl.bin       openwrt-sunxi-pcDuino-u-boot.bin
openwrt-sunxi-pcDuino-sunxi-with-spl.bin
sudo dd if=openwrt-sunxi-pcDuino-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候把SD卡插到板子上, 重新上电就会看到下面打印信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;U-Boot 2013.10-rc2 (Jan 15 2014 – 17:48:38) Allwinner Technology
CPU:   Allwinner A10 (SUN4I)
Board: pcDuino
I2C:   ready
DRAM:  1 GiB
MMC:   SUNXI SD/MMC: 0

*** Warning – bad CRC, using default environment
In:    serial
Out:   serial
Err:   serial
Net:   emac
Hit any key to stop autoboot:  0

sun4i#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以看到u-boot已经完全启动了, 上面的时间是编译的时间. 上面的信息还可以看到我们的环境变量没有设置, 它使用的是默认的环境变量. 前面介绍, 系统建立在分区表不同的地方, 但是我们现在SD卡还没有分区表, 我们需要先建立分区表再做环境变量.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;建立分区表. 重新把SD卡插回到电脑的虚拟机里面, 使用fdisk创建分区表. 具体的分区见下操作, 步骤的说明请看#后面的注释.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pillar@monster:~/openwrt/trunk/bin/sunxi$ sudo fdisk /dev/sdb 
[sudo] password for pillar: 
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0x97bf3019.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won’t be recoverable.
Warning: invalid flag 0×0000 of partition table 4 will be corrected by w(rite) 
Command (m for help): m   #帮助 
Command action 
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   l   list known partition types
   m   print this menu
   n   add a new partition   #创建分区
   o   create a new empty DOS partition table
   p   print the partition table  #查看分区
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition’s system id   #改变分区类型
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only) 

Command (m for help): p             #查看分区
Disk /dev/sdb: 4027 MB, 4027580416 bytes
124 heads, 62 sectors/track, 1023 cylinders, total 7866368 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x97bf3019

Device Boot      Start         End      Blocks   Id  System

#没有分区 

Command (m for help): n      #创建分区 

Partition type: 
   p   primary (0 primary, 0 extended, 4 free)    #主分区 
   e   extended                                   #扩展分区 

Select (default p):                            #选择默认主分区
Using default response p
Partition number (1-4, default 1):                #分区号为1
Using default value 1
First sector (2048-7866367, default 2048):         #选择默认值
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-7866367, default 7866367): 34815 #这个根据全志的手册来第一个分区必须这么大

Command (m for help): p                       #查看分区 

Disk /dev/sdb: 4027 MB, 4027580416 bytes
124 heads, 62 sectors/track, 1023 cylinders, total 7866368 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x97bf3019

   Device Boot      Start         End      Blocks   Id  System 
/dev/sdb1            2048       34815       16384   83  Linux  #创建的第一个分区

Command (m for help): n                    #再创建一个分区 
Partition type:
   p   primary (1 primary, 0 extended, 3 free) 
   e   extended 

Select (default p):                          #主分区
Using default response p 
Partition number (1-4, default 2):              #第二个主分区
Using default value 2
First sector (34816-7866367, default 34816):      #默认大小从34816开始
Using default value 34816
Last sector, +sectors or +size{K,M,G} (34816-7866367, default 7866367): #默认全部分到第二分区 

Using default value 7866367 

Command (m for help): p                       #再一次查看分区 

Disk /dev/sdb: 4027 MB, 4027580416 bytes
124 heads, 62 sectors/track, 1023 cylinders, total 7866368 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x97bf3019

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048       34815       16384   83  Linux
/dev/sdb2           34816     7866367     3915776   83  Linux

#可以看出创建了两个分区都为linux类型，但是u-boot只能识别第一个分区为FAT32分区 

Command (m for help): t            #修改分区类型
Partition number (1-4): 1            #选择修改哪个分区
Hex code (type L to list codes): L      #列出所有类型

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 &amp;lt;32M      40  Venix 80286     85  Linux extended  c7  Syrinx
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT
 f  W95 Ext’d (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor
14  Hidden FAT16 &amp;lt;3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep
1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT
1e  Hidden W95 FAT1 80  Old Minix

Hex code (type L to list codes): c             #选择FAT32
Changed system type of partition 1 to c (W95 FAT32 (LBA))

Command (m for help): p                  #再一次查看分区 

Disk /dev/sdb: 4027 MB, 4027580416 bytes
124 heads, 62 sectors/track, 1023 cylinders, total 7866368 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x97bf3019

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1        2048       34815     16384    c  W95 FAT32 (LBA)#已经修改过了了
/dev/sdb2           34816     7866367     3915776   83  Linux

Command (m for help): w                                   #保存分区表
The partition table has been altered! 
Calling ioctl() to re-read partition table.
WARNING: If you have created or modified any DOS 6.x
partitions, please see the fdisk manual page for additional
information.
Syncing disks.
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;格式化分区. 刚才创建了分区, 但是没有格式化, 我们还是不能使用.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :~/openwrt/trunk/bin/sunxi$ ls /dev/sdb  #查看已经分好的分区
sdb   sdb1  sdb2
pillar@monster :~/openwrt/trunk/bin/sunxi$ mkf        #查看有哪些分区类型
mkfifo        mkfontscale   mkfs.bfs      mkfs.ext2     mkfs.ext4     mkfs.minix    mkfs.ntfs
mkfontdir     mkfs          mkfs.cramfs   mkfs.ext3     mkfs.ext4dev  mkfs.msdos    mkfs.vfat 

pillar@monster :~/openwrt/trunk/bin/sunxi$ sudo mkfs.vfat /dev/sdb1 #第一个分区格式化为fat分区
[sudo] password for pillar:
mkfs.vfat 3.0.12 (29 Oct 2011)

pillar@monster :~/openwrt/trunk/bin/sunxi$ sudo mkfs.ext4 /dev/sdb2 #第二个分区格式化为ext4分区，这里需要几分钟

mke2fs 1.42 (29-Nov-2011)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
244800 inodes, 978944 blocks
48947 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=1002438656
30 block groups
32768 blocks per group, 32768 fragments per group
8160 inodes per group
Superblock backups stored on blocks:
         32768, 98304, 163840, 229376, 294912, 819200, 884736

Allocating group tables: done
Writing inode tables: done
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;挂载分区&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :~/openwrt/trunk/bin/sunxi$ sudo mount /dev/sdb1 /media/1
pillar@monster :~/openwrt/trunk/bin/sunxi$ sudo mount /dev/sdb2 /media/2
pillar@monster :~/openwrt/trunk/bin/sunxi$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       195G   60G  126G  33% /
udev            989M  4.0K  989M   1% /dev
tmpfs           400M  944K  399M   1% /run
none            5.0M     0  5.0M   0% /run/lock
none            998M   76K  998M   1% /run/shm
/dev/sdb1        16M     0   16M   0% /media/1
/dev/sdb2       3.7G  7.5M  3.5G   1% /media/2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;制作u-boot环境变量文件. 刚刚创建了分区, 这里只需要将环境变量文件, 还有uImage拷贝到第一分区让u-boot读取, 就可以引导系统了. 下面开始制作u-boot环境变量文件.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :/media/1$ vim boot.cmd
  1 setenv bootargs console=ttyS0,115200 root=/dev/mmcblk0p2 rootwait panic=10 ${extra}
  2 fatload mmc 0 0×46000000 uImage
  3 fatload mmc 0 0×49000000 sun4i-a10-pcduino.dtb
  4 fdt_high ffffffff
  5 bootm 0×46000000 – 0×49000000
pillar@monster :/media/1$mkimage -C none -A arm -T script -d boot.cmd boot.scr
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;将系统文件拷贝到第一和第二分区.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :/media/1$ cp ~/openwrt/trunk/bin/sunxi/sun4i-a10-pcduino.dtb .
pillar@monster :/media/1$ cp ~/openwrt/trunk/bin/sunxi/openwrt-sunxi-uImage uImage 
pillar@monster :/media/1$ ls           #第一分区文件
boot.scr  sun4i-a10-pcduino.dtb    uImage
pillar@monster :/media$ sudo dd if=~/openwrt/trunk/bin/sunxi/openwrt-sunxi-root.ext4 of=/dev/sdb2 bs=1M                   #拷贝第二分区文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了, 现在整个的从SD启动的BSP已经最好了.&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;发布并烧写系统. 现在把系统做好了, 你可以发布你制作的系统, 然后别人可以通过win32diskimager来把你的系统写入到他的SD卡, 他就可以和你一起玩OpenWrt了.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :/media$ sudo dd if=/dev/sdc of=OpenWrt.img  bs=4M 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在把OpenWrt.img拷贝到windows上, 把你新的SD卡插到电脑开始用win32diskimager写入&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/win32-disk-imager.png&#34; alt=&#34;win32-disk-imager&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置openwrt系统&#34;&gt;配置OpenWrt系统&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;让系统上网&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/config/network
config interface ‘net’
        option ifname ‘eth0′
        option proto ‘dhcp’
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设置固定的mac地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当系统的启动的时候发现mac地址老是在变，这就会出现一个问题, 有时候能获取到ip, 有时候获取不到ip. 这里可以做一个系统服务, 让系统开机保存mac地址, 然后再开机的时候恢复之前的mac地址.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在/etc/init.d/mac里面编写如下脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh /etc/rc.common
START=18
STOP=91
start() {
if [ -f /mac ]; then
dd if=/mac bs=1 count=17 of=/tmp/mac &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
mac_addr=`cat /tmp/mac`
else
mac_file=/sys/class/net/eth0/address
dd if=$mac_file bs=1 of=/mac count=17 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
mac_addr=`cat /tmp/mac`
fi
ifconfig eth0 down
ifconfig eth0 hw ether $mac_addr
#if failed, save current mac address
if [ $? -ne 0 ]; then
mac_file=/sys/class/net/eth0/address
dd if=$mac_file bs=1 of=/mac count=17 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
fi
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;指定运行的模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;/etc/rc.d/rc则根据其参数指定的运行模式(运行级别, 你在inittab文件中可以设置)来执行相应目录下的脚本. 凡是以Kxx开头的, 都以stop为参数来调用. 凡是以Sxx开头的, 都以start为参数来调用. 调用的顺序按xx 从小到大来执行. 例如, 假设缺省的运行模式是3, /etc/rc.d/rc就会按上述方式调用.
由于设定mac地址要在network之前. 所以要创建链接:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln  -s   /etc/init.d/mac   /etc/rc.d/S18mac
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;开启wifi&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;openwrt启动之后输入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@OpenWrt :/# ifconfig
eth0      Link encap:Ethernet  HWaddr AE:DB:9A:D9:31:DE
inet addr:192.168.1.119  Bcast:192.168.1.255  Mask:255.255.255.0
inet6 addr: fe80::acdb:9aff:fed9:31de/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:696 errors:0 dropped:0 overruns:0 frame:0
TX packets:640 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:86028 (84.0 KiB)  TX bytes:377264 (368.4 KiB)
Interrupt:17 Base address:0×4000 

lo        Link encap:Local Loopback
inet addr:127.0.0.1  Mask:255.0.0.0
inet6 addr: ::1/128 Scope:Host
UP LOOPBACK RUNNING  MTU:65536  Metric:1
RX packets:16 errors:0 dropped:0 overruns:0 frame:0
TX packets:16 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:1786 (1.7 KiB)  TX bytes:1786 (1.7 KiB)

wlan0     Link encap:Ethernet  HWaddr 00:7A:03:00:29:F4
inet6 addr: fe80::27a:3ff:fe00:29f4/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:0 errors:0 dropped:0 overruns:0 frame:0
TX packets:7 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:0 (0.0 B)  TX bytes:864 (864.0 B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保ethX和wlanX都有. openwrt的root密码是没有设置, 你需要从serial debug进入系统设置root密码, 设置方法如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;passwd  root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在同一个局域网内你的PC的浏览器上输入: ethX的ip, 这里是192.168.1.119.就会出现下面界面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/luci-login.png&#34; alt=&#34;luci-login&#34;&gt;&lt;/p&gt;
&lt;p&gt;输入你刚才设置的密码, 进入系统管理界面, 默认是进入状态标签, 这里你可以看到整个系统的运行的状态.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/system-status.png&#34; alt=&#34;system-status&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你对当前页面不太习惯, 而且在使用上语言上也有些困难, 你可以进入system标签, 在System Properties里面设置language and style如下图所示. 设置完之后save &amp;amp; apply, 重新刷新一下浏览器就可以使用你设置的语言和主题.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/luci-theme.png&#34; alt=&#34;luci-theme&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面进入网络标签栏设置wifi节点, 这个部分是openwrt比较复杂的一个部分, 这个部分的设置直接决定着你的openwrt能不能使用.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/luci-wifi.png&#34; alt=&#34;luci-wifi&#34;&gt;&lt;/p&gt;
&lt;p&gt;添加新接口, 选择静态ip, 新接口的名称, 你需要用英文自定义一个名字, 在包括一下接口里面选择无线网络. 设置完之后提交, 进入下一个页面继续设置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/luci-interface.png&#34; alt=&#34;luci-interface&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本设置设置完成之后, 进入防火墙设置, 这里wifi必须选择为lan口. 设置完成之后保存应用. 这个时候你电脑就可以连接使用openwrt这个路由器了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/pc-wifi.png&#34; alt=&#34;pc-wifi&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/luci-wifi-net.png&#34; alt=&#34;luci-wifi-net&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击修改后进入防火墙设置标签栏, 分配防火墙区域为wan, 设置完成之后保存&amp;amp;应用.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://akagi201.qiniudn.com/luci-firewall.png&#34; alt=&#34;luci-firewall&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;制作内核补丁&#34;&gt;制作内核补丁&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;清空恢复上一个全新的内核&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make target/linux/{clean,prepare} V=s QUILT=1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;到内核源码目录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd build_dir/target-*/linux-*/linux-3.*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;建立git代码仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git init
git add * -f
git commit -am &amp;quot;initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;修改你的代码, 这里我给我的代码添加&lt;code&gt;rtl8188cus&lt;/code&gt;驱动.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mkdir drivers/net/wireless/rtl8192cus

cp  /home/pillar/openwrt/openwrt-pcDuino/RTL8188C_8192C_USB_linux_v4.0.2_9000.20130911/driver/rtl8188C_8192C_usb_linux_v4.0.2_9000.20130911/*   drivers/net/wireless/rtl8192cus/ -rf

vim  drivers/net/wireless/Kconfig
284  source “drivers/net/wireless/rtl8192cus/Kconfig”

vim drivers/net/wireless/rtl8192cus/Kconfig
  1 config RTL8192CU_SW
  2 tristate “Realtek 8192C USB WiFi for SW”
  3 depends on USB
  4 select WIRELESS_EXT
  5 select WEXT_PRIV

vim  drivers/net/wireless/Makefile
28             obj-$(CONFIG_RTL8192CU_SW)  += rtl8192cus/

vim  drivers/net/wireless/rtl8192cus/Makefile
575  obj-$(CONFIG_RTL8192CU_SW) := $(MODULE_NAME).o 

579  export CONFIG_RTL8192CU_SW = m
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;建立git分支, 并制作补丁&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git branch rtl8192
git checkout rtl8192
git add * -f
git commit -a -m  &amp;quot;add rtl8192cus for pcDuino&amp;quot;
git format-patch -M master  #会生成0002-add-rtl8192cus-for-pcDuino.patch 

cp  0001-add-rtl8192cus-for-pcDuino.patch patches/
cd ../../../../
make target/linux/update package/index V=s
cp  build_dir/target-arm_cortex-a8+vfpv3_uClibc-0.9.33.2_eabi/linux-sunxi/linux-3.12.5/patches/0001-add-rtl8192cus-for-pcDuino.patch target/linux/sunxi/patches-3.12/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;检测是否生效, 执行完之后就是&lt;code&gt;rtl8192&lt;/code&gt;分支的代码了.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make target/linux/{clean,prepare} V=s QUILT=1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;配置内核应用选项&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make kernel_menuconfig
         Device Drivers  —&amp;gt; 
                   [*] Network device support  —&amp;gt; 
                                     [*]   Wireless LAN  —&amp;gt; 
                                                          &amp;lt;*&amp;gt;   Realtek 8192C USB WiFi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的patch的制作方法请参考: &lt;a href=&#34;http://wiki.openwrt.org/doc/devel/patches&#34;&gt;http://wiki.openwrt.org/doc/devel/patches&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;建立app服务器&#34;&gt;建立App服务器&lt;/h3&gt;
&lt;p&gt;OpenWrt通过opkg来管理安装整个系统的软件. 目前有很多OpenWrt的软件源, 但是哪些都是针对于MIPS平台的, pcDuino使用的ARM平台, 我们必须自己搭建软件源. 查看了一下MIPS平台的服务器, 其实很简单的, 就是一个apache服务器, 而且OpenWrt编译完成之后, 在openwrt/trunk/bin/sunxi/packages下面已经生成了软件源. 我们只需要将他们联系起来就行了, 这里是在我的PC的虚拟机上搭建的.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sudo apt-get install apache2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改https的根目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :~/openwrt$ vim /etc/apache2/sites-available/default
4     DocumentRoot /home/pillar/openwrt/trunk/bin/sunxi/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启服务器使修改过的配置生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :~/openwrt$ sudo /etc/init.d/apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改pcDuino上OpenWrt的源配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@OpenWrt :/# vim /etc/opkg.conf
src/gz barrier_breaker http://192.168.1.125/packages
dest root /
dest ram /tmp
lists_dir ext /var/opkg-lists
option overlay_root /overlay
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的IP为我们电脑虚拟机的IP, 下面更新一下软件源.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# opkg update
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;应用程序开发&#34;&gt;应用程序开发&lt;/h3&gt;
&lt;p&gt;OpenWrt上面应用程序开发有两种方式, 一种是利用OpenWrt SDK, 一种是利用OpenWrt源码. 这里主要介绍利用OpenWrt源码, 进行开发应用程序, 制作成ipk软件可以安装.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入package目录, 创建软件目录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#cd   /home/pillar/openwrt/trunk/package
#mkdir example1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;进入example1目录, 创建Makefile文件和代码路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#cd example1
#touch Makefile
#mkdir  src
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该Makefile具体内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;#User mode tool example
include $(TOPDIR)/rules.mk
include $(INCLUDE_DIR)/kernel.mk
PKG_NAME:=example1
PKG_RELEASE:=1
PKG_BUILD_DIR := $(KERNEL_BUILD_DIR)/$(PKG_NAME)
include $(INCLUDE_DIR)/package.mk

define Package/example1
　SECTION:=utils
　CATEGORY:=Base system
　TITLE:=Build for example1 commands
endef

define Package/example1/description
　This package contains an utility useful to use example1 commands.
endef

define Build/Prepare
　　mkdir -p $(PKG_BUILD_DIR)
　　$(CP) ./src/* $(PKG_BUILD_DIR)/
endef 

target=$(firstword $(subst -, ,$(BOARD)))
MAKE_FLAGS += TARGET=&amp;quot;$(target)&amp;quot;
TARGET_CFLAGS += -Dtarget_$(target)=1 -Wall

define Build/example1/compile
　　$(MAKE) -C “$(LINUX_DIR)” \
　　　CROSS_COMPILE=”$(TARGET_CROSS)” \
　　　ARCH=”$(LINUX_KARCH)” \
　　　SUBDIRS=”$(PKG_BUILD_DIR)” \
　　　EXTRA_CFLAGS=”$(BUILDFLAGS)”
endef 

define Package/example1/install
　　$(INSTALL_DIR) $(1)/sbin
　　$(INSTALL_BIN) $(PKG_BUILD_DIR)/example1 $(1)/sbin/
endef 

$(eval $(call BuildPackage,example1))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进入src目录, 创建相关源文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd src 
touch example１.c Makefile 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;example１.c　具体内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
　　printf(“Hello, world\n”);
　　return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Makefile文件具体内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;.NOTPARALLEL: 
#OCTEON_ROOT=$(PWD)/src/ 
CC=~/openwrt/main/staging_dir/toolchain-mips64_gcc-4.4.1_eglibc-2.10.1/usr/bin/mips64-openwrt-linux-gnu-gcc
CFLAGS=-mips64r2 -mabi=64 -march=octeon -mtune=octeon
LFLAGS=
.PHONY: all
all: example1
example1:example1.c
　　${CC} ${CFLAGS} ${LFLAGS} -W -g -Wall -Wno-unused-parameter -DUSE_RUNTIME_MODEL_CHECKS=1 \
　　　　-o $@ example1.c
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;回到主路径/home/pillar/openwrt/trunk/, 编译选项配置保存并编译.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make menuconfig
　　Base system —&amp;gt;
　　　example1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项设置为M, 保存退出.
然后编译该模块:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make package/example1/compile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;更新package&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make package/ example1/install
make package/index
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;内核驱动开发&#34;&gt;内核驱动开发&lt;/h3&gt;
&lt;p&gt;OpenWrt开发内核驱动有多种方式, 前面讲到的制作内核补丁也是一种开发方法. 这里介绍直接在OpenWrt系统上开发内核驱动, 把内核驱动做成ipk软件包的形式.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立工作目录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd  openwrt/trunk/package
mkdir example
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;进入example目录, 创建Makefile文件和代码路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd example 
mkdir src
vim Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;# Kernel module example
include $(TOPDIR)/rules.mk
include $(INCLUDE_DIR)/kernel.mk
PKG_NAME:=example
PKG_RELEASE:=1
include $(INCLUDE_DIR)/package.mk

define KernelPackage/example
　　SUBMENU:=Other modules
　　DEPENDS:=@TARGET_octeon
　　TITLE:=Support Module for example
　　AUTOLOAD:=$(call AutoLoad,81,example)
　　FILES:=$(PKG_BUILD_DIR)/example/example.$(LINUX_KMOD_SUFFIX)
endef

define Build/Prepare
　　mkdir -p $(PKG_BUILD_DIR)
　　$(CP) -R ./src/* $(PKG_BUILD_DIR)/
endef 

define Build/Compile
　　$(MAKE) -C “$(LINUX_DIR)” \
　　　　CROSS_COMPILE=”$(TARGET_CROSS)” \
　　　　ARCH=”$(LINUX_KARCH)” \
　　　　SUBDIRS=”$(PKG_BUILD_DIR)/example” \
　　　　EXTRA_CFLAGS=”-g $(BUILDFLAGS)” \
　　　　modules
endef 

$(eval $(call KernelPackage,example))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进入src目录, 创建代码路径和相关源文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd src
mkdir example
cd example
vim example.c
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;

/* hello_init —- 初始化函数, 当模块装载时被调用, 如果成功装载返回0, 否则返回非0值 */ 

static int __init hello_init(void)
{
　　　printk(&amp;quot;I bear a charmed life.\n&amp;quot;);
　　　return 0;
} 

/ * hello_exit —- 退出函数, 当模块卸载时被调用 */
static void __exit hello_exit(void) 
{
　　　printk(&amp;quot;Out, out, brief candle\n&amp;quot;);
} 

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
MODULE_AUTHOR(&amp;quot;Pillar_zuo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;vim Kconfig

config EXAMPLE
　　tristate &amp;quot;Just a example&amp;quot;
　　default n
　　help
　　　This is a example, for debugging kernel model.
　　　If unsure, say N.

vim Makefile

obj-m := example.o
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;回到OpenWrt源码根目录下&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;make menuconfig
　　Kernel modules —&amp;gt;
　　　　Other modules —&amp;gt;
　　　　　　kmod-example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项设置为M, 保存退出
然后编译该模块:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make package/example/compile
make package/index
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;在OpenWrt系统里面就可以用opkg下载使用了.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用openwrt-sdk&#34;&gt;使用OpenWrt SDK&lt;/h3&gt;
&lt;p&gt;OpenWrt为了避免每次都重新编译系统, 引入了SDK机制. 我们在发布系统的时候也需要发布SDK, 具体的使用方法请下面例子.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解压SDK&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pillar@monster :~/openwrt/trunk/bin/sunxi$ tar xvf OpenWrt-SDK-sunxi-for-linux-x86_64-gcc-4.6-linaro_uClibc-0.9.33.2.tar.bz2
cd  OpenWrt-SDK-sunxi-for-linux-x86_64-gcc-4.6-linaro_uClibc-0.9.33.2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;建立软件工作目录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd package
mkdir helloworld
vim Makefile    #这个Makefile可以作为模板
##############################################
# OpenWrt Makefile for helloworld program
#
#
# Most of the variables used here are defined in
# the include directives below. We just need to
# specify a basic description of the package,
# where to build our program, where to find
# the source files, and where to install the
# compiled program on the router.
#
# Be very careful of spacing in this file.
# Indents should be tabs, not spaces, and
# there should be no trailing whitespace in
# lines that are not commented.
#
############################################## 

include $(TOPDIR)/rules.mk 

# Name and release number of this package 
PKG_NAME:=helloworld 
PKG_RELEASE:=1 

# This specifies the directory where we’re going to build the program.
# The root build directory, $(BUILD_DIR), is by default the build_mipsel
# directory in your OpenWrt SDK directory

PKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)
include $(INCLUDE_DIR)/package.mk

# Specify package information for this program.
# The variables defined here should be self explanatory.
# If you are running Kamikaze, delete the DESCRIPTION
# variable below and uncomment the Kamikaze define
# directive for the description below

define Package/helloworld
    SECTION:=utils
    CATEGORY:=Utilities
    TITLE:=Helloworld — prints a snarky message
endef 

# Uncomment portion below for Kamikaze and delete DESCRIPTION variable above
define Package/helloworld/description
        If you can’t figure out what this program does, you’re probably
        brain-dead and need immediate medical attention.
endef 

# Specify what needs to be done to prepare for building the package.
# In our case, we need to copy the source files to the build directory.
# This is NOT the default.  The default uses the PKG_SOURCE_URL and the
# PKG_SOURCE which is not defined here to download the source from the web.
# In order to just build a simple program that we have just written, it is
# much easier to do it this way. 

define Build/Prepare
    mkdir -p $(PKG_BUILD_DIR)
    $(CP) ./src/* $(PKG_BUILD_DIR)/
endef 

# We do not need to define Build/Configure or Build/Compile directives
# The defaults are appropriate for compiling a simple program such as this one
# Specify where and how to install the program. Since we only have one file,
# the helloworld executable, install it by copying it to the /bin directory on
# the router. The $(1) variable represents the root directory on the router running
# OpenWrt. The $(INSTALL_DIR) variable contains a command to prepare the install
# directory if it does not already exist.  Likewise $(INSTALL_BIN) contains the
# command to copy the binary file from its current location (in our case the build
# directory) to the install directory. 

define Package/helloworld/install
    $(INSTALL_DIR) $(1)/bin
    $(INSTALL_BIN) $(PKG_BUILD_DIR)/helloworld $(1)/bin/
endef 

# This line executes the necessary commands to compile our program.
# The above define directives specify all the information needed, but this
# line calls BuildPackage which in turn actually uses this information to
# build a package.

$(eval $(call BuildPackage,helloworld))
mkdir src
cd src
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写自己的软件, 这里以helloworld为例.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;vim helloworld.c

#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
    printf(“Hell! O’ world, why won’t my code compile?\n\n”); 
    return 0;
}

vim Makefile

# build helloworld executable when user executes &amp;quot;make&amp;quot;
helloworld: helloworld.o 
    $(CC) $(LDFLAGS) helloworld.o -o helloworld

helloworld.o: helloworld.c 
    $(CC) $(CFLAGS) -c helloworld.c 

# remove object files and executable when user executes &amp;quot;make clean&amp;quot;
clean:
    rm *.o helloworld
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编译软件, 回到SDK根目录下.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd ../../
make V=s
pillar@monster :~/openwrt/trunk/bin/sunxi/OpenWrt-SDK-sunxi-for-linux-x86_64-gcc-4.6-linaro_uClibc-0.9.33.2$ ls bin/sunxi/packages/
helloworld_1_sunxi.ipk  Packages  Packages.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;修改软件源根目录. 如果你不想每次都拷贝, 你可以把软件源的根目录下设置在&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;OpenWrt-SDK-sunxi-for-linux-x86_64-gcc-4.6-linaro_uClibc-0.9.33.2/bin/sunxi/packages 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以在OpenWrt系统里面下载安装.&lt;/p&gt;
&lt;h3 id=&#34;refs&#34;&gt;Refs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cnlearn.linksprite.com/?p=2724#tab-1392544656-1-91&#34;&gt;http://cnlearn.linksprite.com/?p=2724#tab-1392544656-1-91&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Protothreads</title>
      <link>/zh/post/protothreads/</link>
      <pubDate>Sat, 14 Dec 2013 09:04:08 +0800</pubDate>
      <guid>/zh/post/protothreads/</guid>
      <description>&lt;h2 id=&#34;specs&#34;&gt;Specs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有专用的机器代码, 纯c实现.&lt;/li&gt;
&lt;li&gt;不使用容易犯错的跳转指令.&lt;/li&gt;
&lt;li&gt;占用极少内存.&lt;/li&gt;
&lt;li&gt;在不在操作系统里用都可以提供blocking event-handlers(可阻塞的事件句柄??).&lt;/li&gt;
&lt;li&gt;提供给事件触发系统(event-driven)线性代码执行(linear code execution).&lt;/li&gt;
&lt;li&gt;提供顺序的控制流程(sequential flow of control)不需要使用复杂的状态机(state machine)或者完全的多线程(full multi-threading).&lt;/li&gt;
&lt;li&gt;Protothreads 是无优先级的, 因此, 一个上下文切换(context switch)只会发生在阻塞操作(blocking operations)上.&lt;/li&gt;
&lt;li&gt;Protothreads function as stackless, lightweight threads providing a blocking context cheaply using minimal memory per protothread (on the order of single bytes).&lt;/li&gt;
&lt;li&gt;Protothreads 是无栈的, 表示需要全局变量来保持变量用来跨上下文切换(across context switches).&lt;/li&gt;
&lt;li&gt;Protothread 的概念是被Adam Dunkels和Oliver Schmidt开发的.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;adam-dunkels&#34;&gt;Adam Dunkels&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;看了一下他的wiki页面, 原来这个人还是个牛人, 在嵌入式领域写了不少东西.&lt;/li&gt;
&lt;li&gt;博士, 瑞典的企业家和程序员, Thingsquare的创始人.&lt;/li&gt;
&lt;li&gt;IPSO Alliance的创始人, 推广对于小的设备(嵌入式和无线传感器)的IP网络通信. alliance&#39;s white paper的作者.&lt;/li&gt;
&lt;li&gt;他的工作主要是关注网络技术和小的嵌入式设备和无线传感器的分布式通信.&lt;/li&gt;
&lt;li&gt;作品有: uIP(micro-IP), lwIP, Protothreads, Contilki, uVNC, MiniWeb, phpstack, uBASIC.&lt;/li&gt;
&lt;li&gt;书籍: &amp;lt;Interconnecting Smart Objects with IP - the Next Internet&amp;gt;.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;quot;pt.h&amp;quot;
 
struct pt pt;
struct timer timer;
 
PT_THREAD(example(struct pt *pt))
{
  PT_BEGIN(pt);
 
  while(1) {
    if(initiate_io()) {
      timer_start(&amp;amp;timer);
      PT_WAIT_UNTIL(pt,
         io_completed() ||
         timer_expired(&amp;amp;timer));
      read_data();
    }
  }
  PT_END(pt);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Protothreads&#34;&gt;http://en.wikipedia.org/wiki/Protothreads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dunkels.com/adam/pt/index.html&#34;&gt;http://dunkels.com/adam/pt/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Adam_Dunkels&#34;&gt;http://en.wikipedia.org/wiki/Adam_Dunkels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Interconnecting-Smart-Objects-IP-Internet/dp/0123751659&#34;&gt;http://www.amazon.com/Interconnecting-Smart-Objects-IP-Internet/dp/0123751659&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hi.baidu.com/hyper99/item/bcf1dbc50af11247a8ba9422&#34;&gt;http://hi.baidu.com/hyper99/item/bcf1dbc50af11247a8ba9422&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Learning Perl</title>
      <link>/zh/post/learning-perl/</link>
      <pubDate>Sun, 03 Nov 2013 12:50:08 +0800</pubDate>
      <guid>/zh/post/learning-perl/</guid>
      <description>&lt;h2 id=&#34;books&#34;&gt;Books&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;小骆驼/大骆驼, 在知乎上搜了一下,还有草泥马什么的, 呵呵, 好多搞生物信息学的用Perl.&lt;/li&gt;
&lt;li&gt;Modern Perl: 我选择了这本, 原因是github上有该书地址, 还有因为如 
&lt;a href=&#34;http://www.modernperlbooks.com/mt/2009/01/why-modern-perl.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Why &amp;ldquo;Modern Perl&amp;rdquo;&lt;/a&gt;
 中所说的, 以前对于当时Perl的好的编程方法现在并不适用了.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;perlbrew: 方便的perl版本管理工具, 把多个perl版本下载到home目录, 然后可以随时切换,也可以关闭使用系统的perl.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://modernperlbooks.com/books/modern_perl/&#34;&gt;http://modernperlbooks.com/books/modern_perl/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chromatic/modern_perl_book&#34;&gt;https://github.com/chromatic/modern_perl_book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gugod/App-perlbrew/wiki/Perlbrew-%E4%B8%AD%E6%96%87%E7%AE%80%E4%BB%8B&#34;&gt;https://github.com/gugod/App-perlbrew/wiki/Perlbrew-中文简介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>在Mac OS X下配置OpenWrt Buildroot环境</title>
      <link>/zh/post/openwrt-buildroot-on-macosx/</link>
      <pubDate>Mon, 28 Oct 2013 15:00:08 +0800</pubDate>
      <guid>/zh/post/openwrt-buildroot-on-macosx/</guid>
      <description>&lt;h2 id=&#34;与linux相比会遇到的2个问题&#34;&gt;与linux相比会遇到的2个问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;OpenWrt需要一个case-sensitive filesystem, 而Mac OS X默认提供的文件系统是case-insensitive.&lt;/li&gt;
&lt;li&gt;Mac OS X下缺少大量的开发工具包, 在普通linux下都有.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用一个disk image(避免再次分区硬盘), 和Homebrew.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;steps&#34;&gt;steps&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Disk Image Creation
hdiutil create -size 20g -fs &amp;ldquo;Case-sensitive HFS+&amp;rdquo; -volname OpenWrt OpenWrt.dmg
hdiutil attach OpenWrt.dmg
这个命令会在当前目录创建一个20GB image, 并且attach他名字为&amp;quot;OpenWrt&amp;rdquo;, 执行后你会在Finder中看到OpenWrt volume, 是空的.
cd /Volumes/OpenWrt&lt;/li&gt;
&lt;li&gt;Packages installation
有两种类型的packages:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;XCode framework: Apple development SDK
. 包含了core compilers和libraries.&lt;/li&gt;
&lt;li&gt;Homebrew framework: a package manager用来下载开源components到你的系统.
brew install coreutils e2fsprogs ossp-uuid asciidoc binutils bzip2 fastjar flex getopt gtk2 intltool jikes hs-zlib openssl p5-extutils-makemaker python26 subversion rsync ruby sdcc unzip gettext libxslt bison gawk autoconf wget gmake ncurses findutils&lt;/li&gt;
&lt;li&gt;missing: bzip2 getopt(gnu-getopt代替, 将mac os x自带的/usr/bin/getopt 重命名备份，把gnu-getopt链接到/usr/local/bin/getopt) gtk2 jikes zlib p5-extutils-makemaker tar(gnu-tar代替) python26(python代替) rsync unzip gmake ncurses&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;easy-build&#34;&gt;Easy Build&lt;/h2&gt;
&lt;p&gt;不需要产生或下载不必要的packages.&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/easy.build&#34;&gt;http://wiki.openwrt.org/doc/howto/easy.build&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/easy.build.macosx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Setup MacOSX as an OpenWrt build environment&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.openwrt.org/doc/howto/buildroot.exigence.macosx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenWrt Buildroot – Installation on Mac OS X&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://forum.openwrt.org/viewtopic.php?id=34676&#34;&gt;https://forum.openwrt.org/viewtopic.php?id=34676&lt;/a&gt;
&lt;a href=&#34;http://digiland.tw/viewtopic.php?id=2105&#34;&gt;http://digiland.tw/viewtopic.php?id=2105&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/mirkerson/article/details/7287931&#34;&gt;http://blog.csdn.net/mirkerson/article/details/7287931&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>minicom on mac</title>
      <link>/zh/post/minicom-on-mac/</link>
      <pubDate>Sun, 27 Oct 2013 05:41:08 +0800</pubDate>
      <guid>/zh/post/minicom-on-mac/</guid>
      <description>&lt;h2 id=&#34;usb转串口驱动&#34;&gt;USB转串口驱动&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我使用的芯片是FTDI的根据FTDI官网的说明,需要下载VCP(Virtual COM Port)驱动.下载了64位的2.2.18版本,ps这东西版本也挺旧的了,是2012/08/08发布的.&lt;/li&gt;
&lt;li&gt;另外一种适配器基于Silicon Labs的CP2012芯片, Windows, Linux和 Mac下都有驱动&lt;a href=&#34;http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx&#34;&gt;http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ps: 另外一种常见得USB转串口驱动(Prolific PL2303):
在Prolific官网上面也有:(&lt;a href=&#34;http://www.prolific.com.tw/US/ShowProduct.aspx?pcid=41&amp;amp;showlevel=0041-0041)&#34;&gt;http://www.prolific.com.tw/US/ShowProduct.aspx?pcid=41&amp;amp;showlevel=0041-0041)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;参考文献中还有其他的驱动,有需要的可以到参考文献中去查.&lt;/li&gt;
&lt;li&gt;安装前先删除已有的USB转串口驱动(我跳过了)&lt;/li&gt;
&lt;li&gt;安装好之后,打开一个Terminal, 输入 ls /dev/cu.*, 找到包含有usbserial或类似的东西.我的结果:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    $ ls /dev/cu.*                                                             
    /dev/cu.Bluetooth-Incoming-Port /dev/cu.usbserial-AD02COJ7
    /dev/cu.Bluetooth-Modem
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;注意:一个serial device会在/dev下面出现2次, 一个是tty.&lt;em&gt;,用来 calling into UNIX systems, 一个是cu.&lt;/em&gt;, (Call-Up)用来从他们中 calling out(如: modems).我们想要从我们的Mac中call-out所以我们选用/dev/cu.*.&lt;/li&gt;
&lt;li&gt;TTY device与CU device的技术区别是:
/dev/tty.*会wait(或者listen)for DCD(data-carrier-detect),如:某人在response之前calling in.
/dev/cu.*不会assert DCD, 所以他们将总是立刻connect(respond or succeed).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;terminal-emulation&#34;&gt;Terminal emulation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GUI apps: Zterm(收费, 支持VT100 emulation), goSerial(不支持 VT100), SecureCRT for Mac(收费)&lt;/li&gt;
&lt;li&gt;Terminal apps: screen, minicom(recommend,and I used)&lt;/li&gt;
&lt;li&gt;built-in: screen(screen /dev/cu.usbserial-AD02COJ7 115200, 退出:  type CTRL-A, then CTRL-.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;minicom&#34;&gt;Minicom&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持VT100 emulation(which means it sorta kinda works with Meridian Mail (Function keys on a MacBook: fn + f-key))&lt;/li&gt;
&lt;li&gt;先运行minicom -s来配置, 修改device name和流控信息, 然后 Save setup as dfl(default) and Exit.&lt;/li&gt;
&lt;li&gt;每次运行minicom前都记得插入usb转串口.&lt;/li&gt;
&lt;li&gt;在minicom中, 命令都是 Ctrl-A &lt;key&gt;
修改port settings: Ctrl-A P
Command Summary: Ctrl-A Z
Quit Minicom: Ctrl-A X&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;screen&#34;&gt;screen&lt;/h2&gt;
&lt;p&gt;Mac自带的命令行工具, 可以用来连接USB虚拟串口, 使用方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;screen /dev/cu.SLAB_USBtoUART 115200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的/dev/cu.SLAB_USBtoUART是虚拟串口的设备文件节点, 确保装好了适配器的驱动, 插入适配器应该就会找到它们了. 电脑通过/dev/cu.&lt;em&gt;设备文件来连接其他串口设备, 通过/dev/tty.&lt;/em&gt; 接受来自其他设备的连接.&lt;/p&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://pbxbook.com/other/mac-tty.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在mac下使用串口方法&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.ftdichip.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FTDI官网&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://h4x3rotab.github.io/blog/2014/01/31/os-xxia-de-usbzhuan-uart/&#34;&gt;http://h4x3rotab.github.io/blog/2014/01/31/os-xxia-de-usbzhuan-uart/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Keep Gitting My CV With Markdown</title>
      <link>/zh/post/keep-gitting-my-cv-with-markdown/</link>
      <pubDate>Fri, 27 Sep 2013 00:43:08 +0800</pubDate>
      <guid>/zh/post/keep-gitting-my-cv-with-markdown/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;我还是决定一点一点的写吧, 自己的拖延症太厉害了.&lt;/li&gt;
&lt;li&gt;Github是个好东西, 现在好玩的东西也越来越多. 其实一个程序员的Github账号就是一份很好的简历.(像我们目前的公司不能联网, 我就不多说什么了, 好公司都不会这样)&lt;/li&gt;
&lt;li&gt;Github的
&lt;a href=&#34;https://github.com/github/markup&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;markup&lt;/a&gt;
是个优秀的渲染引擎, 支持markdown等标记语言. 而且, Github还带了简洁大气的css渲染. 也就是说, 直接把简历写成.rst或者.md放在Github上吧!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;my-cv-online-version&#34;&gt;My CV online version&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://cv.akagi201.org&#34;&gt;http://cv.akagi201.org&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;招聘网站&#34;&gt;招聘网站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://xjh.haitou.cc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;海投宣讲会查询系统&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;pdf version&lt;/li&gt;
&lt;li&gt;latex modern cv version&lt;/li&gt;
&lt;li&gt;简历: 海投, v2ex, 内推, linkedin&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://code6.github.io/blog/2013/04/15/keep-updating-your-cv/&#34;&gt;http://code6.github.io/blog/2013/04/15/keep-updating-your-cv/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hit9/resume.pdf/blob/master/resume.md&#34;&gt;https://github.com/hit9/resume.pdf/blob/master/resume.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://the5fire.com/a-good-resume.html&#34;&gt;http://the5fire.com/a-good-resume.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://resume.linkedinlabs.com&#34;&gt;http://resume.linkedinlabs.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://liresume.blogspot.com/2010/12/pro-tip-format-your-resume-using.html&#34;&gt;http://liresume.blogspot.com/2010/12/pro-tip-format-your-resume-using.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jianlidachu.com/&#34;&gt;http://jianlidachu.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://aadps.net/2013/342.html&#34;&gt;http://aadps.net/2013/342.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/ZhouMeichen/6697329&#34;&gt;https://gist.github.com/ZhouMeichen/6697329&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swachian/new-octopress/blob/master/source/_posts/2012-04-17-gimli-and-markdown-2-pdf.markdown&#34;&gt;https://github.com/swachian/new-octopress/blob/master/source/_posts/2012-04-17-gimli-and-markdown-2-pdf.markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fitbit Flex</title>
      <link>/zh/post/fitbit-flex/</link>
      <pubDate>Tue, 17 Sep 2013 14:32:08 +0800</pubDate>
      <guid>/zh/post/fitbit-flex/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;排斥英文的小伙伴们可以不用看了, 各种数据, 各种软件全是英文的.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;clients&#34;&gt;clients&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pc: &lt;a href=&#34;http://www.fitbit.com/setup&#34;&gt;http://www.fitbit.com/setup&lt;/a&gt; 下载安装 FitbitConnect, 貌似只有2个功能: 同步和升级固件.第一次使用会搜索设备, 然后搜到之后, 双击一下手环表示确认, 我勒个去, 太有科技感了.看配置信息(dashboard)会跳转到网页.&lt;/li&gt;
&lt;li&gt;Android: 只能看数据, 同步目前需要蓝牙4.0, wifi现在还不支持, 看fitbit的开发博客貌似正在beta阶段.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;update-firmware&#34;&gt;update firmware&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过pc端可以升级, 刚入手时候是50, 升级后变成64了. 具体多了哪些功能还不清楚, 总之越新越好. 升级过程有点慢, 手都不敢动, 很怕升级失败的说.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;specs&#34;&gt;Specs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;5个白点LED灯，一个蓝牙芯片，一个三轴加速度传感器，一个振动马达，还有一个主控芯片，微小的电池续航能力竟能达到5-7天。还有一块NFC标签, 用于支持NFC的手机同步的.&lt;/li&gt;
&lt;li&gt;五个LED灯是跟天线套在一个塑料壳上，有一层黑色胶布把它、电池和整块电路板绑在一起，合得比较紧密.&lt;/li&gt;
&lt;li&gt;蓝牙芯片使用的是Nordic的NRF8001.&lt;/li&gt;
&lt;li&gt;接下来有两片不明的芯片写有“NXE”和“NAI”字样，其中NAI芯片上还带有疑似二维码的信息.&lt;/li&gt;
&lt;li&gt;主控芯片用的是意法半导体的STM32L。电池容量未标清，目测可能是20mAh左右.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关于卡路里消耗的精度问题&#34;&gt;关于卡路里消耗的精度问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由于fitbit有庞大的数据库源，只要你输入了精确的身高+体重，fitbit就能基本了解你的步长和单步消耗卡路里的平均值，之后这些数据都会很准。&lt;/li&gt;
&lt;li&gt;所以初次使用，建议录入自己的精确身高和体重，以后记得更新体重的变化，这样会让数据更准。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;睡眠跟踪&#34;&gt;睡眠跟踪&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;睡前 拍打4-5下触发睡眠跟踪模式，早上醒来再同样操作即可。 在刚躺下的时候记得猛拍它，进入睡眠模式，这样早晨sync一下就能以图表的形式看到昨晚睡眠情况，中途醒了几次，深度睡眠浅度睡眠分别占了多少。我觉得一天几个小时就差不多了，再多真是挥霍生命。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;充电&#34;&gt;充电&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大概半小时就能冲到8成以上，但是足足充满需要两三小时的，充满电五颗LED会同时闪烁.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有任何可见的按钮，平时的操作是靠快速点击：啪啪两下，显示今日目标完成情况，5颗LED各代表20%完成度。。如果猛烈的啪啪啪啪啪点了好多下，就会进入睡眠模式，最左和最右两颗LED亮，再一次啪啪啪啪啪就会切回普通计步模式。而且LED绝大部分时候也是不会亮的，据说运动量达到了设定的目标会有震动和”happy dancing”&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.leiphone.com/chaijie-fitbit-flex.html&#34;&gt;http://www.leiphone.com/chaijie-fitbit-flex.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.fitbit.com/customer/portal/articles/798019&#34;&gt;https://help.fitbit.com/customer/portal/articles/798019&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tech2ipo.com/59590&#34;&gt;http://tech2ipo.com/59590&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://knewone.com/things/fitbit-flex/reviews/51af49127373c295b700001c&#34;&gt;http://knewone.com/things/fitbit-flex/reviews/51af49127373c295b700001c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zlz.im/fitbit-flex-review/&#34;&gt;https://zlz.im/fitbit-flex-review/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.fitbit.com/group/229BXW&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fitbit 官方中文小组&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://dev.fitbit.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fitbit API&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.douban.com/group/fitbit/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fitbit 豆瓣小组&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Compile Debian Kernel</title>
      <link>/zh/post/compile-debian-kernel/</link>
      <pubDate>Mon, 20 May 2013 20:27:08 +0800</pubDate>
      <guid>/zh/post/compile-debian-kernel/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/0/04/Debian_logo.png&#34; alt=&#34;Debian Logo&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;changes-to-the-pristine-kernel-source原始的kernel-source-wwwkernelorg&#34;&gt;Changes to the pristine kernel source(原始的kernel source, &lt;a href=&#34;http://www.kernel.org&#34;&gt;www.kernel.org&lt;/a&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pristine kernel source == upstream kernel source&lt;/li&gt;
&lt;li&gt;由于 licensing restrictions, unclear license information, failure to comply with the Debian Free Software Guidelines (DFSG), 部分的kernel被移除为了发布Debian archive的 main section(the source in the main section of the Debian archive). 这种搬移工具产生了 linux_version.orig.tar.xz tarball, 作为原始的上流源码(original upstream source). version是实际的upstream version.&lt;/li&gt;
&lt;li&gt;在2.6.31-1以后的版本中, 所有的已知的没有源码的firmware已经被从Debian package中移除了, 但是他们大多被包含在 firmware-nonfree package中.&lt;/li&gt;
&lt;li&gt;Reference:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.debian.org/vote/2006/vote_007&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Handling source-less firmware in the Linux kernel&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://lists.debian.org/debian-kernel/2006/10/msg00541.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;position statement&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://wiki.debian.org/KernelFirmwareLicensing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KernelFirmwareLicensing&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;debian-kernel-patches&#34;&gt;Debian kernel patches&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Debian kernel的源码: linux_version.orig.tar.xz(去掉license不合格的firmware) + Debian patches&lt;/li&gt;
&lt;li&gt;Debian patches: 必要的修复严重bug fixes 和 安全漏洞(security holes)&lt;/li&gt;
&lt;li&gt;Debian version of the kernel packages: version-revision(version: upstream kernel version, revision: patchlevel)&lt;/li&gt;
&lt;li&gt;接受patch的原则: fix a bug or add hardware support.&lt;/li&gt;
&lt;li&gt;patches introducing optional features 推荐提交到 upstream maintainer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一直保持最新的文档 
&lt;a href=&#34;http://kernel-handbook.alioth.debian.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Debian Linux Kernel Handbook&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Akagi201 dotfiles</title>
      <link>/zh/post/akagi201-dotfiles/</link>
      <pubDate>Mon, 20 May 2013 13:29:26 +0800</pubDate>
      <guid>/zh/post/akagi201-dotfiles/</guid>
      <description>&lt;h2 id=&#34;整理自己的-dotfiles&#34;&gt;整理自己的 dotfiles&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;很早就有这个想法了, 可是自己太懒惰了, 另外, 公司的事情属实让人很蛋疼, 一直搁浅到现在. 为了弥补我丢失的时光, 要求自己以后每天最早 10 点下班. 晚上用来整理自己的文档和笔记.&lt;/li&gt;
&lt;li&gt;本来想法很粗糙, 后来想到通过网上的大家来学习, 发现了比自己整理自己的糟糕配置更有效的方法. GitHub 真是个好东西. 我觉得 GitHub 是我们这代与上一代 Programmer 的明显差别的地方, 一定要好好利用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dotfiles-on-github&#34;&gt;dotfiles on GitHub&lt;/h2&gt;
&lt;h3 id=&#34;idgatt&#34;&gt;idgatt&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;idgatt: It&#39;s Dangerous to Go Alone! Take This! 的首字母, 不得不对老外的思维差异感到震惊, 呵呵, 个人觉得很丑, 有空熟悉了 github 命令和规则后.&lt;/li&gt;
&lt;li&gt;简单的说这个就是一个自动化脚本, 帮助你管理 oh my zsh 和 spf13-vim (呵呵, 刚巧我跟这位author 同样的兴趣)

&lt;a href=&#34;https://github.com/Akagi201/idgatt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;idgatt&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oh-my-zsh&#34;&gt;oh-my-zsh&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;zsh: 已经是 MAC OS X 的默认 shell 了, 比 bash 强大 n 倍, 兼容 bash, linux 默认 bash 坑了多少人啊(包括我). z 代表最终的意思, 可见其完美程度. 我现在用的还不多, 但交互操作显示和自动提示功能明显很强大. 慢慢熟悉.

&lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;oh-my-zsh&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spf13-vim&#34;&gt;spf13-vim&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;spf13-vim: vim 谁都知道, 那配置起来是相当的麻烦, 要至少花个半年时间吧, 这个配置有点缺点的, 一个是名字不太好看, 另外就是配置文件到处都是, 有点乱.

&lt;a href=&#34;https://github.com/spf13/spf13-vim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spf13-vim&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;my-dot-files&#34;&gt;My dot-files&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;终于整理好了自己的 
&lt;a href=&#34;https://github.com/Akagi201/dot-files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dot-files&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;refs&#34;&gt;Refs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;http://dotfiles.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dotfiles@GitHub&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
